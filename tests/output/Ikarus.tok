// ######################################################
// 
//   Kern des Skriptpakets "Ikarus"
//       Autor      : Sektenspinner
//       Co-Autor   : Gottfried, mud-freak, Neconspictor
// 	    Version    : 1.2.1
// 
// ######################################################
// ************************************************
//  Content:
// ************************************************
// \n    ## Preamble ##\n        -Versioncheck\n        -Logging Functions (preliminary) \n        -Parser Data Stack Hacking\n        \n    ## Basic Read Write ##\n        -Read/Write of Integers, Strings, Arrays, Bytes\n    \n    ## Basic zCParser related functions ##\n        -MEM_ReinitParser: Locate Parser data structures.\n        -Get and set instance offsets (e.g. MEM_PtrToInst)\n        -Jumps (via MEM_StackPos)\n        -MEM_GetFuncID and friends\n        -Address Operator _@ and friends\n        -Access static Arrays\n        \n    ## Preliminary MEM_Alloc and MEM_Free ##\n        -(De-)Allocation with Strings\n        \n    ## CALL Package ##\n        -ASM: Bytecode Streams and their execution\n        -CALL_Begin / End: The faster Mode of the package\n        -Parameter pushing\n        -Result poping\n        -calling conventions\n        \n    ## UTILITY ##\n        -MEM_SetShowDebug\n        -MEM_Copy\n        -MEM_Swap\n        -MEM_Clear\n        -MEM_Realloc\n        -MEM_Compare\n        \n    ## Windows Utilities ##\n        -LoadLibrary / GetProcAddress\n        -VirtualProtect / MemoryProtectionOverride\n        -MEM_MessageBox / MEM_InfoBox\n        \n    ## Arrays ##\n        -Alloc / Clear / Free / Size / Read / Write\n        -Insert / Push / Pop / Top\n        -IndexOf / RemoveIndex / RemoveValue[Once]\n        -Sort / Unique\n        -ToString\n        \n    ## String Tools ##\n        -GetCharAt / Length\n        -Substring / Prefix\n        -Compare\n        -STR_ToInt\n        -STR_IndexOf\n        -STR_Split\n        -STR_Upper\n        \n    ## Elaborate zCParser related functions ##\n        -MEM_(Find/Get)ParserSymbol\n        -MEM_Call[, ByID, ByString]\n        -Find function by Stack Offset\n        -Locate current execution position on machine stack\n            * MEM_GetCallerStackPos\n            * MEM_SetCallerStackPos\n        -Label / goto / while / repeat\n            * Split function into tokens\n            * Trace calculation of parameter\n            * patch function\n            * Handle first while\n            * Handle first goto\n            * Handle first repeat\n            \n    ## Access Menu Objects ##\n        -Find Menus and Menuitems by string\n        \n    ## zCObjects ##\n        -Commonly used objects (MEM_InitGlobalInst)\n        -Validity checks (Hlp_Is_*)\n        -Find zCClassDef and class name for object\n        -Create and delete vobs\n            * MEM_InsertVob\n            * MEM_DeleteVob\n        -Locate Objects in the worlds Hash table\n            * Evaluate hash function\n            * Find Objects by name\n            * Properly change object name\n        -Send trigger and untrigger\n        \n    ## Keyboard interaction ##\n        -MEM_KeyState\n        -MEM_InsertKeyEvent\n        \n    ## Read and Write Ini Values ##\n        -Reading\n            * In Gothic's configuration\n            * In the mod's configuration\n            * Get command line\n            * Get key assignment\n        -Writing\n            * in Gothic's configuration\n            * Apply changes and write to disk\n            \n    ## Benchmarking and time measurement ##\n        -Time Measurement\n            * Milliseconds\n            * Performance Counter\n        -Benchmark\n        \n    ## Logging and Debug ##\n        -Send Info/Warning/Error to zSpy\n        -Print the Stacktrace\n            * Print Stacktrace line\n            * Print full Stack Trace\n            * Exception handler\n            * Installing the exeption handler\n            \n    ## Revised functions ##\n        -Faster MEM_ReadInt / MEM_WriteInt\n        -Faster MEM_Alloc and MEM_Free\n        \n    ## MEM_InitAll\n
// #################################################
// 
//     Preamble
// 
// #################################################
// ----------------------------------------------
//    Versioncheck
//    If your Code relies on fixes introduced in
//    a certain version of Ikarus,
//    and you want to give your code to users
//    that may have old versions, use this:
// ----------------------------------------------
CONST
INT
IKARUS_VERSION
ASSIGN
INTEGER(10201)
SEMICOLON
// 2 digits for Major and Minor Revision number.
//  returns 1 if the version of Ikarus is the specified version or newer 
FUNC
INT
MEM_CHECKVERSION
PARENOPEN
VAR
INT
BASE
COMMA
VAR
INT
MAJOR
COMMA
VAR
INT
MINOR
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
MAJOR
GREATER
INTEGER(99)
OR
MINOR
GREATER
INTEGER(99)
PARENCLOSE
BRACKETOPEN
RETURN
FALSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
RETURN
BASE
MULTIPLY
INTEGER(10000)
PLUS
MAJOR
MULTIPLY
INTEGER(100)
PLUS
MINOR
LOWEREQUALS
IKARUS_VERSION
SEMICOLON
BRACKETCLOSE
SEMICOLON
// --------------------------------------
//   Logging functions
//   MEM_SendToSpy will be revised
//   by MEM_InitAll to print neatly
// --------------------------------------
//  should the next message have an error box? 
VAR
INT
MEMINT_FORCEERRORBOX
SEMICOLON
FUNC
VOID
MEM_SENDTOSPY
PARENOPEN
VAR
INT
ERRORTYPE
COMMA
VAR
STRING
TEXT
PARENCLOSE
BRACKETOPEN
//  Implementierung wird von MEM_InitAll ersetzt! 
PRINTDEBUG
PARENOPEN
CONCATSTRINGS
PARENOPEN
TEXT
COMMA
"<<< (This is a preliminary printing variant, use MEM_InitAll to get neat 'Q:' prefixed messages.) >>>"
PARENCLOSE
PARENCLOSE
SEMICOLON
//  Q: is the Ikarus mark 
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEM_ERRORBOX
PARENOPEN
VAR
STRING
TEXT
PARENCLOSE
BRACKETOPEN
MEMINT_FORCEERRORBOX
ASSIGN
TRUE
SEMICOLON
MEM_SENDTOSPY
PARENOPEN
ZERR_TYPE_FAULT
COMMA
TEXT
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEM_PRINTSTACKTRACE
PARENOPEN
PARENCLOSE
BRACKETOPEN
VAR
STRING
ERROR
SEMICOLON
ERROR
ASSIGN
"MEM_PrintStackTrace: Cannot print the stacktrace before MEM_InitAll was called!"
SEMICOLON
MEM_SENDTOSPY
PARENOPEN
ZERR_TYPE_FAULT
COMMA
ERROR
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEMINT_HANDLEERROR
PARENOPEN
VAR
INT
ERRORTYPE
COMMA
VAR
STRING
TEXT
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
ERRORTYPE
GREATEREQUALS
ZERR_PRINTSTACKTRACE
PARENCLOSE
BRACKETOPEN
CONST
INT
ONCE
ASSIGN
INTEGER(0)
SEMICOLON
IF
PARENOPEN
NOT
ONCE
OR
NOT
ZERR_STACKTRACEONLYFORFIRST
PARENCLOSE
BRACKETOPEN
ONCE
ASSIGN
TRUE
SEMICOLON
MEM_PRINTSTACKTRACE
PARENOPEN
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
IF
PARENOPEN
ERRORTYPE
GREATEREQUALS
ZERR_REPORTTOZSPY
PARENCLOSE
BRACKETOPEN
CONST
INT
ERRORBOXONCE
ASSIGN
INTEGER(0)
SEMICOLON
IF
PARENOPEN
ERRORTYPE
GREATEREQUALS
ZERR_SHOWERRORBOX
PARENCLOSE
AND
PARENOPEN
NOT
ZERR_ERRORBOXONLYFORFIRST
OR
NOT
ERRORBOXONCE
PARENCLOSE
BRACKETOPEN
MEMINT_FORCEERRORBOX
ASSIGN
TRUE
SEMICOLON
ERRORBOXONCE
ASSIGN
TRUE
SEMICOLON
BRACKETCLOSE
SEMICOLON
MEM_SENDTOSPY
PARENOPEN
ERRORTYPE
COMMA
TEXT
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEM_ERROR
PARENOPEN
VAR
STRING
ERROR
PARENCLOSE
BRACKETOPEN
MEMINT_HANDLEERROR
PARENOPEN
ZERR_TYPE_FAULT
COMMA
ERROR
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEM_WARN
PARENOPEN
VAR
STRING
WARN
PARENCLOSE
BRACKETOPEN
MEMINT_HANDLEERROR
PARENOPEN
ZERR_TYPE_WARN
COMMA
WARN
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEM_INFO
PARENOPEN
VAR
STRING
INFO
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
ZERR_REPORTTOZSPY
GREATER
ZERR_TYPE_INFO
PARENCLOSE
AND
PARENOPEN
ZERR_PRINTSTACKTRACE
GREATER
ZERR_TYPE_INFO
PARENCLOSE
BRACKETOPEN
RETURN
SEMICOLON
// dont waste time
BRACKETCLOSE
SEMICOLON
MEMINT_HANDLEERROR
PARENOPEN
ZERR_TYPE_INFO
COMMA
INFO
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEM_ASSERTFAIL
PARENOPEN
VAR
STRING
ASSERTFAILTEXT
PARENCLOSE
BRACKETOPEN
ASSERTFAILTEXT
ASSIGN
CONCATSTRINGS
PARENOPEN
"Assertion failed. Report this: "
COMMA
ASSERTFAILTEXT
PARENCLOSE
SEMICOLON
MEM_ERROR
PARENOPEN
ASSERTFAILTEXT
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
//  custom channel 
FUNC
VOID
MEM_DEBUG
PARENOPEN
VAR
STRING
MESSAGE
PARENCLOSE
BRACKETOPEN
MESSAGE
ASSIGN
CONCATSTRINGS
PARENOPEN
ZERR_DEBUG_PREFIX
COMMA
MESSAGE
PARENCLOSE
SEMICOLON
IF
PARENOPEN
ZERR_DEBUG_TOSCREEN
PARENCLOSE
BRACKETOPEN
PRINT
PARENOPEN
MESSAGE
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
IF
PARENOPEN
ZERR_DEBUG_ERRORBOX
PARENCLOSE
BRACKETOPEN
MEMINT_FORCEERRORBOX
ASSIGN
TRUE
SEMICOLON
BRACKETCLOSE
SEMICOLON
IF
PARENOPEN
ZERR_DEBUG_ERRORBOX
OR
ZERR_DEBUG_TOSPY
PARENCLOSE
BRACKETOPEN
MEM_SENDTOSPY
PARENOPEN
ZERR_DEBUG_TYPE
COMMA
MESSAGE
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// --------------------------------------
//   Parser Data Stack Hacking
// --------------------------------------
CLASS
MEMINT_HELPERCLASS
BRACKETOPEN
BRACKETCLOSE
SEMICOLON
VAR
MEMINT_HELPERCLASS
MEMINT_INSTUNASSIGNED
SEMICOLON
VAR
MEMINT_HELPERCLASS
MEMINT_POPDUMP
SEMICOLON
FUNC
INT
MEMINT_STACKPUSHINT
PARENOPEN
VAR
INT
VAL
PARENCLOSE
BRACKETOPEN
RETURN
PLUS
VAL
SEMICOLON
BRACKETCLOSE
SEMICOLON
// Vorsicht: Referenz wird gepusht!
FUNC
STRING
MEMINT_STACKPUSHSTRING
PARENOPEN
VAR
STRING
VAL
PARENCLOSE
BRACKETOPEN
RETURN
VAL
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
MEMINT_HELPERCLASS
MEMINT_STACKPOPINSTSUB
PARENOPEN
PARENCLOSE
BRACKETOPEN
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEMINT_STACKPOPINST
PARENOPEN
PARENCLOSE
BRACKETOPEN
MEMINT_POPDUMP
ASSIGN
MEMINT_STACKPOPINSTSUB
PARENOPEN
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEMINT_STACKPUSHINST
PARENOPEN
VAR
INT
VAL
PARENCLOSE
BRACKETOPEN
MEMINT_STACKPUSHINT
PARENOPEN
VAL
PARENCLOSE
SEMICOLON
MEMINT_STACKPOPINST
PARENOPEN
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEMINT_STACKPUSHVAR
PARENOPEN
VAR
INT
ADR
PARENCLOSE
BRACKETOPEN
MEMINT_STACKPUSHINST
PARENOPEN
ADR
PARENCLOSE
SEMICOLON
MEMINT_STACKPUSHINST
PARENOPEN
ZPAR_TOK_PUSHVAR
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// Alternative Formulierungen:
FUNC
INT
MEMINT_POPINT
PARENOPEN
PARENCLOSE
BRACKETOPEN
BRACKETCLOSE
SEMICOLON
FUNC
STRING
MEMINT_POPSTRING
PARENOPEN
PARENCLOSE
BRACKETOPEN
BRACKETCLOSE
SEMICOLON
FUNC
INT
MEMINT_STACKPOPINT
PARENOPEN
PARENCLOSE
BRACKETOPEN
BRACKETCLOSE
SEMICOLON
FUNC
STRING
MEMINT_STACKPOPSTRING
PARENOPEN
PARENCLOSE
BRACKETOPEN
BRACKETCLOSE
SEMICOLON
FUNC
INT
MEMINT_STACKPOPINSTASINT
PARENOPEN
PARENCLOSE
BRACKETOPEN
MEMINT_STACKPUSHINST
PARENOPEN
ZPAR_TOK_PUSHINT
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// --------------------------------------
//   MEM_Helper
// --------------------------------------
INSTANCE
MEM_HELPER_INST
PARENOPEN
C_NPC
PARENCLOSE
BRACKETOPEN
NAME
ASSIGN
MEM_HELPER_NAME
SEMICOLON
ID
ASSIGN
INTEGER(42)
SEMICOLON
//  unsterblich: 
FLAGS
ASSIGN
INTEGER(2)
SEMICOLON
ATTRIBUTE
SQUAREOPEN
ATR_HITPOINTS_MAX
SQUARECLOSE
ASSIGN
INTEGER(2)
SEMICOLON
ATTRIBUTE
SQUAREOPEN
ATR_HITPOINTS
SQUARECLOSE
ASSIGN
INTEGER(2)
SEMICOLON
//  irgendein Visual: 
MDL_SETVISUAL
PARENOPEN
SELF
COMMA
"Meatbug.mds"
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
VAR
OCNPC
MEM_HELPER
SEMICOLON
FUNC
VOID
MEMINT_GETMEMHELPER
PARENOPEN
PARENCLOSE
BRACKETOPEN
MEM_HELPER
ASSIGN
HLP_GETNPC
PARENOPEN
MEM_HELPER_INST
PARENCLOSE
SEMICOLON
IF
PARENOPEN
NOT
HLP_ISVALIDNPC
PARENOPEN
MEM_HELPER
PARENCLOSE
PARENCLOSE
BRACKETOPEN
// self zwischenspeichern
VAR
C_NPC
SELFBAK
SEMICOLON
SELFBAK
ASSIGN
HLP_GETNPC
PARENOPEN
SELF
PARENCLOSE
SEMICOLON
WLD_INSERTNPC
PARENOPEN
MEM_HELPER_INST
COMMA
MEM_FARFARAWAY
PARENCLOSE
SEMICOLON
MEM_HELPER
ASSIGN
HLP_GETNPC
PARENOPEN
SELF
PARENCLOSE
SEMICOLON
SELF
ASSIGN
HLP_GETNPC
PARENOPEN
SELFBAK
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// GOTHIC_BASE_VERSION == 1 ? g1Val : g2Val
FUNC
INT
MEMINT_SWITCHG1G2
PARENOPEN
VAR
INT
G1VAL
COMMA
VAR
INT
G2VAL
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
GOTHIC_BASE_VERSION
EQUALS
INTEGER(1)
PARENCLOSE
BRACKETOPEN
RETURN
G1VAL
SEMICOLON
BRACKETCLOSE
ELSE
BRACKETOPEN
RETURN
G2VAL
SEMICOLON
BRACKETCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// ######################################################
// 
//   Basic Read Write Operations
// 
// ######################################################
// --------------------------------------
//  Reading Parser-Data-Stack-Hacking
// --------------------------------------
FUNC
INT
MEM_READINT
PARENOPEN
VAR
INT
ADDRESS
PARENCLOSE
BRACKETOPEN
//  note: there will not be error handling once Ikarus is\n     * fully set up by MEM_InitAll. This function will be replaced. 
IF
PARENOPEN
ADDRESS
EQUALS
INTEGER(0)
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"MEM_ReadInt: address is NULL"
PARENCLOSE
SEMICOLON
RETURN
INTEGER(0)
SEMICOLON
BRACKETCLOSE
SEMICOLON
MEMINT_STACKPUSHVAR
PARENOPEN
ADDRESS
PARENCLOSE
SEMICOLON
MEMINT_STACKPUSHINT
PARENOPEN
MEMINT_STACKPOPINT
PARENOPEN
PARENCLOSE
PARENCLOSE
SEMICOLON
// als int nicht als var auf dem Stack
BRACKETCLOSE
SEMICOLON
FUNC
STRING
MEM_READSTRING
PARENOPEN
VAR
INT
ADDRESS
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
ADDRESS
EQUALS
INTEGER(0)
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"MEM_ReadString: address is NULL"
PARENCLOSE
SEMICOLON
RETURN
""
SEMICOLON
BRACKETCLOSE
SEMICOLON
MEMINT_STACKPUSHVAR
PARENOPEN
ADDRESS
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// --------------------------------------
//  Assignments
// --------------------------------------
// Alte Lesemethode wird nur zum Bootstrap des neuen Systems gebraucht.
FUNC
VOID
MEMINT_OLDWRITEINT
PARENOPEN
VAR
INT
ADDRESS
COMMA
VAR
INT
VAL
PARENCLOSE
BRACKETOPEN
//  other = address - MEM_NpcID_Offset 
MEM_HELPER
PERIOD
ENEMY
ASSIGN
ADDRESS
MINUS
MEM_NPCID_OFFSET
SEMICOLON
//  res wird nicht gebraucht, müllt aber sonst den Stack zu! 
VAR
INT
RES
SEMICOLON
RES
ASSIGN
NPC_GETTARGET
PARENOPEN
MEM_HELPER
PARENCLOSE
SEMICOLON
//  *(other + oCNpc_idx_offset) = val 
OTHER
PERIOD
ID
ASSIGN
VAL
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEMINT_PREPAREASSIGNMENTS
PARENOPEN
PARENCLOSE
BRACKETOPEN
//  sorgt dafür, dass MEMINT_Assign und MEMINT_StrAssign\n     * genau die Funktion von zPAR_OP_IS bzw. zPAR_TOK_ASSIGNSTR\n     * erfüllen.\n     * Diese Funktion wird nach Start von Gothic genau einmal aufgerufen. 
VAR
INT
SYMTAB
SEMICOLON
VAR
INT
MEMINT_ASSIGN_SYM
SEMICOLON
VAR
INT
MEMINT_ASSIGN_STACKPOS
SEMICOLON
VAR
INT
STACKSTART
SEMICOLON
// Navigation zum Code dieser Funktionen:
SYMTAB
ASSIGN
MEM_READINT
PARENOPEN
CONTENTPARSERADDRESS
PLUS
ZCPARSER_SYMTAB_TABLE_ARRAY_OFFSET
PARENCLOSE
SEMICOLON
STACKSTART
ASSIGN
MEM_READINT
PARENOPEN
CONTENTPARSERADDRESS
PLUS
ZCPARSER_STACK_OFFSET
PARENCLOSE
SEMICOLON
MEMINT_ASSIGN_SYM
ASSIGN
MEM_READINT
PARENOPEN
SYMTAB
PLUS
INTEGER(4)
MULTIPLY
PARENOPEN
MEMINT_ASSIGNPREDECESSOR
PLUS
INTEGER(1)
PARENCLOSE
PARENCLOSE
SEMICOLON
MEMINT_ASSIGN_STACKPOS
ASSIGN
MEM_READINT
PARENOPEN
MEMINT_ASSIGN_SYM
PLUS
ZCPARSYMBOL_CONTENT_OFFSET
PARENCLOSE
SEMICOLON
// alte Lesemethode braucht Npc
MEMINT_GETMEMHELPER
PARENOPEN
PARENCLOSE
SEMICOLON
VAR
C_NPC
OTHBAK
SEMICOLON
OTHBAK
ASSIGN
HLP_GETNPC
PARENOPEN
OTHER
PARENCLOSE
SEMICOLON
// Code überschreiben. Vorsicht: Der erste Aufruf soll auch klappen!
MEMINT_OLDWRITEINT
PARENOPEN
STACKSTART
PLUS
MEMINT_ASSIGN_STACKPOS
COMMA
PARENOPEN
ZPAR_OP_IS
SHIFTLEFT
INTEGER(0)
PARENCLOSE
BITOR
PARENOPEN
ZPAR_TOK_RET
SHIFTLEFT
INTEGER(8)
PARENCLOSE
BITOR
PARENOPEN
ZPAR_TOK_RET
SHIFTLEFT
INTEGER(16)
PARENCLOSE
BITOR
PARENOPEN
ZPAR_TOK_RET
SHIFTLEFT
INTEGER(24)
PARENCLOSE
PARENCLOSE
SEMICOLON
MEMINT_OLDWRITEINT
PARENOPEN
STACKSTART
PLUS
MEMINT_ASSIGN_STACKPOS
PLUS
INTEGER(4)
COMMA
PARENOPEN
ZPAR_TOK_RET
SHIFTLEFT
INTEGER(0)
PARENCLOSE
BITOR
PARENOPEN
ZPAR_OP_IS
SHIFTLEFT
INTEGER(8)
PARENCLOSE
BITOR
PARENOPEN
ZPAR_TOK_RET
SHIFTLEFT
INTEGER(16)
PARENCLOSE
BITOR
PARENOPEN
ZPAR_TOK_RET
SHIFTLEFT
INTEGER(24)
PARENCLOSE
PARENCLOSE
SEMICOLON
MEMINT_OLDWRITEINT
PARENOPEN
STACKSTART
PLUS
MEMINT_ASSIGN_STACKPOS
PLUS
INTEGER(8)
COMMA
PARENOPEN
ZPAR_TOK_ASSIGNSTR
SHIFTLEFT
INTEGER(0)
PARENCLOSE
BITOR
PARENOPEN
ZPAR_TOK_RET
SHIFTLEFT
INTEGER(8)
PARENCLOSE
BITOR
PARENOPEN
ZPAR_TOK_RET
SHIFTLEFT
INTEGER(16)
PARENCLOSE
BITOR
PARENOPEN
ZPAR_TOK_RET
SHIFTLEFT
INTEGER(24)
PARENCLOSE
PARENCLOSE
SEMICOLON
MEMINT_OLDWRITEINT
PARENOPEN
STACKSTART
PLUS
MEMINT_ASSIGN_STACKPOS
PLUS
INTEGER(12)
COMMA
PARENOPEN
ZPAR_TOK_RET
SHIFTLEFT
INTEGER(0)
PARENCLOSE
BITOR
PARENOPEN
ZPAR_TOK_ASSIGNSTR
SHIFTLEFT
INTEGER(8)
PARENCLOSE
BITOR
PARENOPEN
ZPAR_TOK_RET
SHIFTLEFT
INTEGER(16)
PARENCLOSE
BITOR
PARENOPEN
ZPAR_TOK_RET
SHIFTLEFT
INTEGER(24)
PARENCLOSE
PARENCLOSE
SEMICOLON
// alte Lesemethode muss aufräumen
MEM_HELPER
PERIOD
ENEMY
ASSIGN
INTEGER(0)
SEMICOLON
OTHER
ASSIGN
HLP_GETNPC
PARENOPEN
OTHBAK
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
VAR
MEMINT_HELPERCLASS
MEMINT_ASSIGNPREDECESSOR
SEMICOLON
FUNC
VOID
MEMINT_ASSIGN
PARENOPEN
PARENCLOSE
BRACKETOPEN
//  Hier soll stehen:\n     *  zPAR_OP_IS\n     *  zPAR_TOK_RET\n     *\n     * das schreibe ich da jetzt hin: 
MEMINT_PREPAREASSIGNMENTS
PARENOPEN
PARENCLOSE
SEMICOLON
// zPAR_TOK_CALL + 4 bytes
RETURN
SEMICOLON
// zPAR_TOK_RET
RETURN
SEMICOLON
// zPAR_TOK_RET
// zPAR_TOK_RET
// Summe: 8 Bytes
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEMINT_STRASSIGN
PARENOPEN
PARENCLOSE
BRACKETOPEN
//  Hier soll stehen:\n     *  zPAR_TOK_ASSIGNSTR\n     *  zPAR_TOK_RET\n     *\n     * das schreibe ich da jetzt hin: 
MEMINT_PREPAREASSIGNMENTS
PARENOPEN
PARENCLOSE
SEMICOLON
// zPAR_TOK_CALL + 4 bytes
RETURN
SEMICOLON
// zPAR_TOK_RET
RETURN
SEMICOLON
// zPAR_TOK_RET
// zPAR_TOK_RET
// Summe: 8 Bytes
BRACKETCLOSE
SEMICOLON
// --------------------------------------
//  Schreiboperationen
// --------------------------------------
FUNC
VOID
MEM_WRITEINT
PARENOPEN
VAR
INT
ADDRESS
COMMA
VAR
INT
VAL
PARENCLOSE
BRACKETOPEN
//  note: there will not be error handling once Ikarus is\n     * fully set up by MEM_InitAll. This function will be replaced. 
IF
PARENOPEN
ADDRESS
EQUALS
INTEGER(0)
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"MEM_WriteInt: address is NULL"
PARENCLOSE
SEMICOLON
RETURN
SEMICOLON
BRACKETCLOSE
SEMICOLON
MEMINT_STACKPUSHINT
PARENOPEN
VAL
PARENCLOSE
SEMICOLON
MEMINT_STACKPUSHVAR
PARENOPEN
ADDRESS
PARENCLOSE
SEMICOLON
MEMINT_ASSIGN
PARENOPEN
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEM_WRITESTRING
PARENOPEN
VAR
INT
ADDRESS
COMMA
VAR
STRING
VAL
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
ADDRESS
EQUALS
INTEGER(0)
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"MEM_WriteString: address is NULL"
PARENCLOSE
SEMICOLON
RETURN
SEMICOLON
BRACKETCLOSE
SEMICOLON
MEMINT_STACKPUSHSTRING
PARENOPEN
VAL
PARENCLOSE
SEMICOLON
MEMINT_STACKPUSHVAR
PARENOPEN
ADDRESS
PARENCLOSE
SEMICOLON
MEMINT_STRASSIGN
PARENOPEN
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// ------------------------------------------------
//   Byte-Zugriff
// ------------------------------------------------
FUNC
INT
MEM_READBYTE
PARENOPEN
VAR
INT
ADR
PARENCLOSE
BRACKETOPEN
RETURN
MEM_READINT
PARENOPEN
ADR
PARENCLOSE
BITAND
INTEGER(255)
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEM_WRITEBYTE
PARENOPEN
VAR
INT
ADR
COMMA
VAR
INT
VAL
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
VAL
BITAND
BITNOT
INTEGER(255)
PARENCLOSE
BRACKETOPEN
MEM_WARN
PARENOPEN
"MEM_WriteByte: Val out of range! Truncating to 8 bits."
PARENCLOSE
SEMICOLON
VAL
ASSIGN
VAL
BITAND
INTEGER(255)
SEMICOLON
BRACKETCLOSE
SEMICOLON
MEM_WRITEINT
PARENOPEN
ADR
COMMA
PARENOPEN
MEM_READINT
PARENOPEN
ADR
PARENCLOSE
BITAND
BITNOT
INTEGER(255)
PARENCLOSE
BITOR
VAL
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// --------------------------------------
//  Arrayzugriff
// --------------------------------------
FUNC
INT
MEM_READINTARRAY
PARENOPEN
VAR
INT
ARRAYADDRESS
COMMA
VAR
INT
OFFSET
PARENCLOSE
BRACKETOPEN
RETURN
MEM_READINT
PARENOPEN
ARRAYADDRESS
PLUS
INTEGER(4)
MULTIPLY
OFFSET
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEM_WRITEINTARRAY
PARENOPEN
VAR
INT
ARRAYADDRESS
COMMA
VAR
INT
OFFSET
COMMA
VAR
INT
VALUE
PARENCLOSE
BRACKETOPEN
MEM_WRITEINT
PARENOPEN
ARRAYADDRESS
PLUS
INTEGER(4)
MULTIPLY
OFFSET
COMMA
VALUE
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
MEM_READBYTEARRAY
PARENOPEN
VAR
INT
ARRAYADDRESS
COMMA
VAR
INT
OFFSET
PARENCLOSE
BRACKETOPEN
RETURN
MEM_READBYTE
PARENOPEN
ARRAYADDRESS
PLUS
OFFSET
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEM_WRITEBYTEARRAY
PARENOPEN
VAR
INT
ARRAYADDRESS
COMMA
VAR
INT
OFFSET
COMMA
VAR
INT
VALUE
PARENCLOSE
BRACKETOPEN
MEM_WRITEBYTE
PARENOPEN
ARRAYADDRESS
PLUS
OFFSET
COMMA
VALUE
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
//  Zurzeit in LeGo drin.\nfunc string MEM_ReadStringArray (var int arrayAddress, var int offset) {\n    return MEM_ReadString (arrayAddress + offset * sizeof_zString);\n};
FUNC
VOID
MEM_WRITESTRINGARRAY
PARENOPEN
VAR
INT
ARRAYADDRESS
COMMA
VAR
INT
OFFSET
COMMA
VAR
STRING
VALUE
PARENCLOSE
BRACKETOPEN
MEM_WRITESTRING
PARENOPEN
ARRAYADDRESS
PLUS
SIZEOF_ZSTRING
MULTIPLY
OFFSET
COMMA
VALUE
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// ######################################################
// 
//   Basic zCParser related functions
// 
// ######################################################
// Deprecated, use MEM_Parser instead!
CONST
INT
CURRPARSERADDRESS
ASSIGN
INTEGER(0)
SEMICOLON
// const to keep it valid through loading
CONST
INT
CURRSYMBOLTABLEADDRESS
ASSIGN
INTEGER(0)
SEMICOLON
CONST
INT
CURRSYMBOLTABLELENGTH
ASSIGN
INTEGER(0)
SEMICOLON
CONST
INT
CURRSORTEDSYMBOLTABLEADDRESS
ASSIGN
INTEGER(0)
SEMICOLON
CONST
INT
CURRPARSERSTACKADDRESS
ASSIGN
INTEGER(0)
SEMICOLON
CONST
INT
CONTENTSYMBOLTABLEADDRESS
ASSIGN
INTEGER(0)
SEMICOLON
FUNC
VOID
MEM_REINITPARSER
PARENOPEN
PARENCLOSE
BRACKETOPEN
CURRPARSERADDRESS
ASSIGN
CONTENTPARSERADDRESS
SEMICOLON
// Die Symboltabelle im Parser:
CURRSYMBOLTABLEADDRESS
ASSIGN
MEM_READINT
PARENOPEN
CURRPARSERADDRESS
PLUS
ZCPARSER_SYMTAB_TABLE_ARRAY_OFFSET
PARENCLOSE
SEMICOLON
CURRSYMBOLTABLELENGTH
ASSIGN
MEM_READINT
PARENOPEN
CURRPARSERADDRESS
PLUS
ZCPARSER_SYMTAB_TABLE_ARRAY_OFFSET
PLUS
INTEGER(8)
PARENCLOSE
SEMICOLON
CURRSORTEDSYMBOLTABLEADDRESS
ASSIGN
MEM_READINT
PARENOPEN
CURRPARSERADDRESS
PLUS
ZCPARSER_SORTED_SYMTAB_TABLE_ARRAY_OFFSET
PARENCLOSE
SEMICOLON
CURRPARSERSTACKADDRESS
ASSIGN
MEM_READINT
PARENOPEN
CURRPARSERADDRESS
PLUS
ZCPARSER_STACK_OFFSET
PARENCLOSE
SEMICOLON
// Die Contentsymboltabelle braucht man immer mal wieder:
CONTENTSYMBOLTABLEADDRESS
ASSIGN
MEM_READINT
PARENOPEN
CONTENTPARSERADDRESS
PLUS
ZCPARSER_SYMTAB_TABLE_ARRAY_OFFSET
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// removed, but keep stub
FUNC
VOID
MEM_SETPARSER
PARENOPEN
VAR
INT
ID
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
NOT
ID
PARENCLOSE
BRACKETOPEN
MEM_WARN
PARENOPEN
"MEM_SetParser was removed in Ikarus Version 1.2 and should not be used any more."
PARENCLOSE
SEMICOLON
BRACKETCLOSE
ELSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"MEM_SetParser was removed in Ikarus Version 1.2 and cannot be used to change the current parser any more."
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// ************************************************
//  Get and set instance offsets
// ************************************************
// --------------------------------------
//  Instanz auf Pointer zeigen lassen
// --------------------------------------
VAR
INT
MEM_ASSIGNINSTSUPPRESSNULLWARNING
SEMICOLON
FUNC
VOID
MEM_ASSIGNINST
PARENOPEN
VAR
INT
INST
COMMA
VAR
INT
PTR
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
INST
LOWEREQUALS
INTEGER(0)
PARENCLOSE
BRACKETOPEN
//  Anmerkung: inst == 0 kann auch nicht sein,\n         * da es keine Instance vor einer Klassendeklaration\n         * geben kann. 
MEM_ERROR
PARENOPEN
CONCATSTRINGS
PARENOPEN
"MEM_AssignInst: Invalid instance: "
COMMA
INTTOSTRING
PARENOPEN
INST
PARENCLOSE
PARENCLOSE
PARENCLOSE
SEMICOLON
RETURN
SEMICOLON
BRACKETCLOSE
SEMICOLON
IF
PARENOPEN
PTR
EQUALS
INTEGER(0)
AND
NOT
MEM_ASSIGNINSTSUPPRESSNULLWARNING
PARENCLOSE
BRACKETOPEN
//  Instanzen die Null sind, will man eigentlich nicht, die machen nur Ärger. 
MEM_WARN
PARENOPEN
"MEM_AssignInst: ptr is NULL. Use MEM_AssignInstNull if that's what you want."
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
VAR
INT
SYM
SEMICOLON
SYM
ASSIGN
MEM_READINTARRAY
PARENOPEN
CURRSYMBOLTABLEADDRESS
COMMA
INST
PARENCLOSE
SEMICOLON
MEM_WRITEINT
PARENOPEN
SYM
PLUS
ZCPARSYMBOL_OFFSET_OFFSET
COMMA
PTR
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEM_ASSIGNINSTNULL
PARENOPEN
VAR
INT
INST
PARENCLOSE
BRACKETOPEN
//  Normalerweise will man Instanzen nicht zurück auf 0 setzen.\n     * Oft wird es ein Fehler sein. Daher wird oben eine Warnung ausgegeben.\n     * Um die nicht zu bekommen gibt es hier die explizite Funktion 
MEM_ASSIGNINSTSUPPRESSNULLWARNING
ASSIGN
TRUE
SEMICOLON
MEM_ASSIGNINST
PARENOPEN
INST
COMMA
INTEGER(0)
PARENCLOSE
SEMICOLON
MEM_ASSIGNINSTSUPPRESSNULLWARNING
ASSIGN
FALSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
MEMINT_HELPERCLASS
MEM_PTRTOINST
PARENOPEN
VAR
INT
PTR
PARENCLOSE
BRACKETOPEN
VAR
MEMINT_HELPERCLASS
HLP
SEMICOLON
CONST
INT
HLPOFFSETPTR
ASSIGN
INTEGER(0)
SEMICOLON
IF
PARENOPEN
NOT
HLPOFFSETPTR
PARENCLOSE
BRACKETOPEN
HLPOFFSETPTR
ASSIGN
MEM_READINTARRAY
PARENOPEN
CURRSYMBOLTABLEADDRESS
COMMA
HLP
PARENCLOSE
PLUS
ZCPARSYMBOL_OFFSET_OFFSET
SEMICOLON
BRACKETCLOSE
SEMICOLON
IF
PARENOPEN
PTR
EQUALS
INTEGER(0)
AND
NOT
MEM_ASSIGNINSTSUPPRESSNULLWARNING
PARENCLOSE
BRACKETOPEN
//  Instanzen die Null sind, will man eigentlich nicht, die machen nur Ärger. 
MEM_WARN
PARENOPEN
"MEM_PtrToInst: ptr is NULL. Use MEM_NullToInst if that's what you want."
PARENCLOSE
SEMICOLON
MEM_WRITEINT
PARENOPEN
HLPOFFSETPTR
COMMA
INTEGER(0)
PARENCLOSE
SEMICOLON
BRACKETCLOSE
ELSE
BRACKETOPEN
MEM_WRITEINT
PARENOPEN
HLPOFFSETPTR
COMMA
PTR
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
MEMINT_STACKPUSHINST
PARENOPEN
HLP
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
MEMINT_HELPERCLASS
_^
PARENOPEN
VAR
INT
PTR
PARENCLOSE
BRACKETOPEN
MEM_PTRTOINST
PARENOPEN
PTR
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
MEMINT_HELPERCLASS
MEM_NULLTOINST
PARENOPEN
PARENCLOSE
BRACKETOPEN
VAR
MEMINT_HELPERCLASS
HLP
SEMICOLON
MEMINT_STACKPUSHINST
PARENOPEN
HLP
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
MEMINT_HELPERCLASS
MEM_CPYINST
PARENOPEN
VAR
INT
INST
PARENCLOSE
BRACKETOPEN
MEMINT_STACKPUSHINST
PARENOPEN
INST
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// --------------------------------------
//  Deprecated relict from the time
//  when direct access to menu/pfx/vfx parsers
//  was possible
// --------------------------------------
FUNC
VOID
MEM_ASSIGNCONTENTINST
PARENOPEN
VAR
INT
INST
COMMA
VAR
INT
PTR
PARENCLOSE
BRACKETOPEN
CONST
INT
ONCE
ASSIGN
INTEGER(0)
SEMICOLON
IF
PARENOPEN
NOT
ONCE
PARENCLOSE
BRACKETOPEN
ONCE
ASSIGN
TRUE
SEMICOLON
MEM_WARN
PARENOPEN
"MEM_AssignContentInst: This function was deprecated in Ikarus Version 1.2. Use the equivalent MEM_AssignInst instead."
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
MEM_ASSIGNINST
PARENOPEN
INST
COMMA
PTR
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEM_ASSIGNCONTENTINSTNULL
PARENOPEN
VAR
INT
INST
PARENCLOSE
BRACKETOPEN
CONST
INT
ONCE
ASSIGN
INTEGER(0)
SEMICOLON
IF
PARENOPEN
NOT
ONCE
PARENCLOSE
BRACKETOPEN
ONCE
ASSIGN
TRUE
SEMICOLON
MEM_WARN
PARENOPEN
"MEM_AssignContentInstNull: This function was deprecated in Ikarus Version 1.2. Use the equivalent MEM_AssignInstNull instead."
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
MEM_ASSIGNINSTNULL
PARENOPEN
INST
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// --------------------------------------
//  Get offset of an instance
// --------------------------------------
FUNC
INT
MEM_INSTTOPTR
PARENOPEN
VAR
INT
INST
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
INST
LOWEREQUALS
INTEGER(0)
PARENCLOSE
BRACKETOPEN
//  Anmerkung: inst == 0 kann auch nicht sein,\n         * da es keine Instance vor eine Klassendeklaration\n         * geben kann. 
MEM_ERROR
PARENOPEN
CONCATSTRINGS
PARENOPEN
"MEM_InstGetOffset: Invalid inst: "
COMMA
INTTOSTRING
PARENOPEN
INST
PARENCLOSE
PARENCLOSE
PARENCLOSE
SEMICOLON
RETURN
INTEGER(0)
SEMICOLON
BRACKETCLOSE
SEMICOLON
VAR
INT
SYMB
SEMICOLON
SYMB
ASSIGN
MEM_READINTARRAY
PARENOPEN
CURRSYMBOLTABLEADDRESS
COMMA
INST
PARENCLOSE
SEMICOLON
RETURN
MEM_READINT
PARENOPEN
SYMB
PLUS
ZCPARSYMBOL_OFFSET_OFFSET
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// Abwärtskompatibilität
FUNC
INT
MEM_INSTGETOFFSET
PARENOPEN
VAR
INT
INST
PARENCLOSE
BRACKETOPEN
RETURN
MEM_INSTTOPTR
PARENOPEN
INST
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// --------------------------------------
//  Unsinnig. Nur zur Abwärtskompatibilität
//  überhaupt noch drin. Google sagt,
//  Lehona hat es mal irgendwo benutzt.
// --------------------------------------
// Lässt currParserSymb auf das Symbol mit Instanz inst zeigen.
INSTANCE
CURRPARSERSYMB
PARENOPEN
ZCPAR_SYMBOL
PARENCLOSE
SEMICOLON
FUNC
VOID
MEM_SETCURRPARSERSYMB
PARENOPEN
VAR
INT
INST
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
INST
LOWEREQUALS
INTEGER(0)
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
CONCATSTRINGS
PARENOPEN
"MEM_SetCurrParserSymb: Invalid inst: "
COMMA
INTTOSTRING
PARENOPEN
INST
PARENCLOSE
PARENCLOSE
PARENCLOSE
SEMICOLON
RETURN
SEMICOLON
BRACKETCLOSE
SEMICOLON
VAR
INT
SYMOFFSET
SEMICOLON
VAR
INT
CURRPARSERSYMOFFSET
SEMICOLON
SYMOFFSET
ASSIGN
MEM_READINTARRAY
PARENOPEN
CURRSYMBOLTABLEADDRESS
COMMA
INST
PARENCLOSE
SEMICOLON
CURRPARSERSYMOFFSET
ASSIGN
MEM_READINTARRAY
PARENOPEN
CONTENTSYMBOLTABLEADDRESS
COMMA
CURRPARSERSYMB
PARENCLOSE
SEMICOLON
MEM_WRITEINT
PARENOPEN
CURRPARSERSYMOFFSET
PLUS
ZCPARSYMBOL_OFFSET_OFFSET
COMMA
SYMOFFSET
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// ************************************************
//    Sprünge
// ************************************************
//  Es sieht einfach aus, gell? Aber das das funktioniert ist\n * gar nicht so offensichtlich wie man glaubt.\n * Das hier geht zum Beispiel:\n{\n    label = MEM_StackPos.position;\n\n    [...]\n\n    MEM_StackPos.position = label;\n};\n\n * Das hier geht grandios schief:\n\n{\n    label = MEM_StackPos.position + 0;\n\n    [...]\n\n    MEM_StackPos.position = label;\n};\n\n * Wer Experimente macht, wird wahrscheinlich auf die Nase fallen.\n * Es ist Zufall, dass es so einfach funktioniert! 
CLASS
MEMINT_STACKPOS
BRACKETOPEN
VAR
INT
POSITION
SEMICOLON
BRACKETCLOSE
SEMICOLON
VAR
MEMINT_STACKPOS
MEM_STACKPOS
SEMICOLON
FUNC
VOID
MEM_INITLABELS
PARENOPEN
PARENCLOSE
BRACKETOPEN
MEM_STACKPOS
ASSIGN
_^
PARENOPEN
CONTENTPARSERADDRESS
PLUS
ZCPARSER_STACK_STACKPTR_OFFSET
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEM_CALLBYPTR
PARENOPEN
VAR
INT
PTR
PARENCLOSE
BRACKETOPEN
MEM_STACKPOS
PERIOD
POSITION
ASSIGN
PTR
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEM_CALLBYOFFSET
PARENOPEN
VAR
INT
OFFSET
PARENCLOSE
BRACKETOPEN
MEM_CALLBYPTR
PARENOPEN
OFFSET
PLUS
CURRPARSERSTACKADDRESS
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// ************************************************
//    Idee von Gottfried: ID einer Funktion
// ************************************************
FUNC
INT
MEM_GETFUNCID
PARENOPEN
VAR
FUNC
FNC
PARENCLOSE
BRACKETOPEN
VAR
ZCPAR_SYMBOL
SYMB
SEMICOLON
//  dummy symbol with index indexOf(fnc)+1 
SYMB
ASSIGN
MEM_PTRTOINST
PARENOPEN
MEM_READINTARRAY
PARENOPEN
CONTENTSYMBOLTABLEADDRESS
COMMA
SYMB
MINUS
INTEGER(1)
PARENCLOSE
PARENCLOSE
SEMICOLON
VAR
INT
RES
SEMICOLON
VAR
INT
LOOP
SEMICOLON
LOOP
ASSIGN
MEM_STACKPOS
PERIOD
POSITION
SEMICOLON
IF
PARENOPEN
PARENOPEN
SYMB
PERIOD
BITFIELD
BITAND
ZCPAR_SYMBOL_BITFIELD_TYPE
PARENCLOSE
NOTEQUALS
ZPAR_TYPE_FUNC
PARENCLOSE
BRACKETOPEN
MEM_WARN
PARENOPEN
"MEM_GetFuncID: Unresolvable request (probably uninitialised function variable)."
PARENCLOSE
SEMICOLON
RETURN
MINUS
INTEGER(1)
SEMICOLON
BRACKETCLOSE
SEMICOLON
IF
PARENOPEN
SYMB
PERIOD
BITFIELD
BITAND
ZPAR_FLAG_CONST
PARENCLOSE
BRACKETOPEN
RETURN
PLUS
RES
SEMICOLON
BRACKETCLOSE
ELSE
BRACKETOPEN
RES
ASSIGN
SYMB
PERIOD
CONTENT
SEMICOLON
SYMB
ASSIGN
MEM_PTRTOINST
PARENOPEN
MEM_READINTARRAY
PARENOPEN
CONTENTSYMBOLTABLEADDRESS
COMMA
RES
PARENCLOSE
PARENCLOSE
SEMICOLON
MEM_STACKPOS
PERIOD
POSITION
ASSIGN
LOOP
SEMICOLON
BRACKETCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
MEM_GETFUNCOFFSET
PARENOPEN
VAR
FUNC
FNC
PARENCLOSE
BRACKETOPEN
VAR
INT
R
SEMICOLON
R
ASSIGN
MEM_GETFUNCID
PARENOPEN
FNC
PARENCLOSE
SEMICOLON
// ID(fnc)
R
ASSIGN
MEM_READINTARRAY
PARENOPEN
CONTENTSYMBOLTABLEADDRESS
COMMA
R
PARENCLOSE
SEMICOLON
// symbolTable[ID(fnc)]
R
ASSIGN
MEM_READINT
PARENOPEN
R
PLUS
ZCPARSYMBOL_CONTENT_OFFSET
PARENCLOSE
SEMICOLON
// symbolTable[ID(fnc)].content
RETURN
R
PLUS
INTEGER(0)
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
MEM_GETFUNCPTR
PARENOPEN
VAR
FUNC
FNC
PARENCLOSE
BRACKETOPEN
RETURN
MEM_GETFUNCOFFSET
PARENOPEN
FNC
PARENCLOSE
PLUS
CURRPARSERSTACKADDRESS
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEM_REPLACEFUNC
PARENOPEN
VAR
FUNC
F1
COMMA
VAR
FUNC
F2
PARENCLOSE
BRACKETOPEN
VAR
INT
PTR
SEMICOLON
PTR
ASSIGN
MEM_GETFUNCPTR
PARENOPEN
F1
PARENCLOSE
SEMICOLON
VAR
INT
TARGET
SEMICOLON
TARGET
ASSIGN
MEM_GETFUNCOFFSET
PARENOPEN
F2
PARENCLOSE
SEMICOLON
//  jetzt bitte in einem Rutsch, nicht, dass da einer was ersetzen will, was ich brauche. 
MEM_WRITEBYTE
PARENOPEN
PTR
COMMA
ZPAR_TOK_JUMP
PARENCLOSE
SEMICOLON
MEM_WRITEINT
PARENOPEN
PTR
PLUS
INTEGER(1)
COMMA
TARGET
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// ************************************************
//  Functions that help me write Byte Code
// ************************************************
VAR
INT
MEMINT_OVERRIDEFUNC_PTR
SEMICOLON
FUNC
VOID
MEMINT_INITOVERIDEFUNC
PARENOPEN
VAR
FUNC
F
PARENCLOSE
BRACKETOPEN
MEMINT_OVERRIDEFUNC_PTR
ASSIGN
MEM_GETFUNCPTR
PARENOPEN
F
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
//  override function, token 
FUNC
VOID
MEMINT_OFTOK
PARENOPEN
VAR
INT
TOK
PARENCLOSE
BRACKETOPEN
MEM_WRITEBYTE
PARENOPEN
MEMINT_OVERRIDEFUNC_PTR
COMMA
TOK
PARENCLOSE
SEMICOLON
MEMINT_OVERRIDEFUNC_PTR
PLUSASSIGN
INTEGER(1)
SEMICOLON
BRACKETCLOSE
SEMICOLON
//  override function, token + parameter 
FUNC
VOID
MEMINT_OFTOKPAR
PARENOPEN
VAR
INT
TOK
COMMA
VAR
INT
PARAM
PARENCLOSE
BRACKETOPEN
MEMINT_OFTOK
PARENOPEN
TOK
PARENCLOSE
SEMICOLON
MEM_WRITEINT
PARENOPEN
MEMINT_OVERRIDEFUNC_PTR
COMMA
PARAM
PARENCLOSE
SEMICOLON
MEMINT_OVERRIDEFUNC_PTR
PLUSASSIGN
INTEGER(4)
SEMICOLON
BRACKETCLOSE
SEMICOLON
// ************************************************
//  New Operators
// ************************************************
// --------------------------------------
//   Address Operator
// --------------------------------------
// Dummies that are filled later:
FUNC
INT
MEM_GETINTADDRESS
PARENOPEN
VAR
INT
I
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"MEM_GetIntAddress called before MEM_GetAddress_Init!"
PARENCLOSE
SEMICOLON
RETURN
INTEGER(0)
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
MEM_GETFLOATADDRESS
PARENOPEN
VAR
FLOAT
F
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"MEM_GetFloatAddress called before MEM_GetAddress_Init!"
PARENCLOSE
SEMICOLON
RETURN
INTEGER(0)
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
MEM_GETSTRINGADDRESS
PARENOPEN
VAR
STRING
S
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"MEM_GetStringAddress called before MEM_GetAddress_Init!"
PARENCLOSE
SEMICOLON
RETURN
INTEGER(0)
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
_@
PARENOPEN
VAR
INT
I
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"_@ called before MEM_GetAddress_Init!"
PARENCLOSE
SEMICOLON
I
ASSIGN
I
SEMICOLON
I
ASSIGN
I
SEMICOLON
I
ASSIGN
I
SEMICOLON
I
ASSIGN
I
SEMICOLON
I
ASSIGN
I
SEMICOLON
I
ASSIGN
I
SEMICOLON
//  some space 
RETURN
INTEGER(0)
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
_@S
PARENOPEN
VAR
STRING
S
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"_@s called before MEM_GetAddress_Init!"
PARENCLOSE
SEMICOLON
RETURN
INTEGER(0)
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
_@F
PARENOPEN
VAR
FLOAT
F
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"_@f called before MEM_GetAddress_Init!"
PARENCLOSE
SEMICOLON
RETURN
INTEGER(0)
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEMINT_GETADDRESS_INIT
PARENOPEN
VAR
FUNC
F
PARENCLOSE
BRACKETOPEN
VAR
MEMINT_HELPERCLASS
SYMB
SEMICOLON
MEMINT_INITOVERIDEFUNC
PARENOPEN
F
PARENCLOSE
SEMICOLON
MEMINT_OFTOKPAR
PARENOPEN
ZPAR_TOK_PUSHINST
COMMA
SYMB
PARENCLOSE
SEMICOLON
MEMINT_OFTOK
PARENOPEN
ZPAR_TOK_ASSIGNINST
PARENCLOSE
SEMICOLON
MEMINT_OFTOKPAR
PARENOPEN
ZPAR_TOK_PUSHINST
COMMA
ZPAR_TOK_PUSHINT
PARENCLOSE
SEMICOLON
MEMINT_OFTOK
PARENOPEN
ZPAR_TOK_RET
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEM_GETADDRESS_INIT
PARENOPEN
PARENCLOSE
BRACKETOPEN
CONST
INT
INIT_DONE
ASSIGN
INTEGER(0)
SEMICOLON
IF
PARENOPEN
NOT
INIT_DONE
PARENCLOSE
BRACKETOPEN
MEMINT_GETADDRESS_INIT
PARENOPEN
MEM_GETINTADDRESS
PARENCLOSE
SEMICOLON
MEMINT_GETADDRESS_INIT
PARENOPEN
MEM_GETFLOATADDRESS
PARENCLOSE
SEMICOLON
MEMINT_GETADDRESS_INIT
PARENOPEN
MEM_GETSTRINGADDRESS
PARENCLOSE
SEMICOLON
MEMINT_GETADDRESS_INIT
PARENOPEN
STR_GETADDRESS
PARENCLOSE
SEMICOLON
MEMINT_GETADDRESS_INIT
PARENOPEN
_@F
PARENCLOSE
SEMICOLON
MEMINT_GETADDRESS_INIT
PARENOPEN
_@S
PARENCLOSE
SEMICOLON
//  something else for _@ 
MEMINT_INITOVERIDEFUNC
PARENOPEN
_@
PARENCLOSE
SEMICOLON
//  push zPAR_TOK_PUSHINT     
MEMINT_OFTOKPAR
PARENOPEN
ZPAR_TOK_PUSHINST
COMMA
ZPAR_TOK_PUSHINT
PARENCLOSE
SEMICOLON
//  push int zPAR_TOK_PUSHINT 
MEMINT_OFTOKPAR
PARENOPEN
ZPAR_TOK_PUSHINT
COMMA
ZPAR_TOK_PUSHINT
PARENCLOSE
SEMICOLON
//  equal?                    
MEMINT_OFTOK
PARENOPEN
ZPAR_OP_EQUAL
PARENCLOSE
SEMICOLON
//  jumpF                     
MEMINT_OFTOKPAR
PARENOPEN
ZPAR_TOK_JUMPF
COMMA
MEMINT_OVERRIDEFUNC_PTR
PLUS
INTEGER(16)
MINUS
CURRPARSERSTACKADDRESS
PARENCLOSE
SEMICOLON
//  push zPAR_TOK_PUSHINT     
MEMINT_OFTOKPAR
PARENOPEN
ZPAR_TOK_PUSHINST
COMMA
ZPAR_TOK_PUSHINT
PARENCLOSE
SEMICOLON
//  call MEM_InstToPtr        
MEMINT_OFTOKPAR
PARENOPEN
ZPAR_TOK_CALL
COMMA
MEM_GETFUNCOFFSET
PARENOPEN
MEM_INSTTOPTR
PARENCLOSE
PARENCLOSE
SEMICOLON
//  ret                       
MEMINT_OFTOK
PARENOPEN
ZPAR_TOK_RET
PARENCLOSE
SEMICOLON
//  push zPAR_TOK_PUSHINT     
MEMINT_OFTOKPAR
PARENOPEN
ZPAR_TOK_PUSHINST
COMMA
ZPAR_TOK_PUSHINT
PARENCLOSE
SEMICOLON
//  ret                       
MEMINT_OFTOK
PARENOPEN
ZPAR_TOK_RET
PARENCLOSE
SEMICOLON
//  return var address as int 
INIT_DONE
ASSIGN
TRUE
SEMICOLON
BRACKETCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// ***   downward compatiblity: ***
// alias for downward compatibility
FUNC
VOID
STR_GETADDRESSINIT
PARENOPEN
PARENCLOSE
BRACKETOPEN
MEM_GETADDRESS_INIT
PARENOPEN
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
//  for downward compatiblity there is a guarantee, that\n * STR_GetAddress works ininitialised, but the first time\n * may only return an address of a copy of the string 
FUNC
INT
STR_GETADDRESS
PARENOPEN
VAR
STRING
STR
PARENCLOSE
BRACKETOPEN
STR
ASSIGN
STR
SEMICOLON
// waste 11 bytes
MEM_GETADDRESS_INIT
PARENOPEN
PARENCLOSE
SEMICOLON
// will override 12 bytes of THIS function
RETURN
STR_GETADDRESS
PARENOPEN
STR
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// ************************************************
// 	Access static Arrays
// ************************************************
// Workers
FUNC
INT
MEMINT_READSTATARR
PARENOPEN
VAR
INT
OFFSET
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
OFFSET
LOWER
INTEGER(0)
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"MEM_ReadStatArr: Offset < 0!"
PARENCLOSE
SEMICOLON
RETURN
INTEGER(0)
SEMICOLON
BRACKETCLOSE
SEMICOLON
MEMINT_STACKPOPINST
PARENOPEN
PARENCLOSE
SEMICOLON
MEMINT_STACKPUSHINST
PARENOPEN
ZPAR_TOK_PUSHINT
PARENCLOSE
SEMICOLON
VAR
INT
ADR
SEMICOLON
ADR
ASSIGN
MEMINT_STACKPOPINT
PARENOPEN
PARENCLOSE
SEMICOLON
RETURN
MEM_READINTARRAY
PARENOPEN
ADR
COMMA
OFFSET
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEMINT_WRITESTATARR
PARENOPEN
VAR
INT
OFFSET
COMMA
VAR
INT
VALUE
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
OFFSET
LOWER
INTEGER(0)
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"MEM_WriteStatArr: Offset < 0!"
PARENCLOSE
SEMICOLON
RETURN
SEMICOLON
BRACKETCLOSE
SEMICOLON
//  pop only the first two, the third differently: 
MEMINT_STACKPOPINST
PARENOPEN
PARENCLOSE
SEMICOLON
MEMINT_STACKPUSHINST
PARENOPEN
ZPAR_TOK_PUSHINT
PARENCLOSE
SEMICOLON
VAR
INT
ADR
SEMICOLON
ADR
ASSIGN
MEMINT_STACKPOPINT
PARENOPEN
PARENCLOSE
SEMICOLON
MEM_WRITEINTARRAY
PARENOPEN
ADR
COMMA
OFFSET
COMMA
VALUE
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEMINT_WRITESTATSTRINGARR
PARENOPEN
VAR
INT
OFFSET
COMMA
VAR
STRING
VALUE
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
OFFSET
LOWER
INTEGER(0)
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"MEM_WriteStatStringArr: Offset < 0!"
PARENCLOSE
SEMICOLON
RETURN
SEMICOLON
BRACKETCLOSE
SEMICOLON
MEMINT_STACKPOPINST
PARENOPEN
PARENCLOSE
SEMICOLON
MEMINT_STACKPUSHINST
PARENOPEN
ZPAR_TOK_PUSHINT
PARENCLOSE
SEMICOLON
VAR
INT
ADR
SEMICOLON
ADR
ASSIGN
MEMINT_STACKPOPINT
PARENOPEN
PARENCLOSE
SEMICOLON
ADR
PLUSASSIGN
SIZEOF_ZSTRING
MULTIPLY
OFFSET
SEMICOLON
MEM_WRITESTRING
PARENOPEN
ADR
COMMA
VALUE
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
STRING
MEMINT_READSTATSTRINGARR
PARENOPEN
VAR
INT
OFFSET
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
OFFSET
LOWER
INTEGER(0)
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"MEM_ReadStatStringArr: Offset < 0!"
PARENCLOSE
SEMICOLON
RETURN
""
SEMICOLON
BRACKETCLOSE
SEMICOLON
MEMINT_STACKPOPINST
PARENOPEN
PARENCLOSE
SEMICOLON
MEMINT_STACKPUSHINST
PARENOPEN
ZPAR_TOK_PUSHINT
PARENCLOSE
SEMICOLON
VAR
INT
ADR
SEMICOLON
ADR
ASSIGN
MEMINT_STACKPOPINT
PARENOPEN
PARENCLOSE
SEMICOLON
ADR
PLUSASSIGN
SIZEOF_ZSTRING
MULTIPLY
OFFSET
SEMICOLON
RETURN
MEM_READSTRING
PARENOPEN
ADR
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// Stubs
FUNC
VOID
MEM_WRITESTATARR
PARENOPEN
VAR
INT
ARRAY
COMMA
VAR
INT
OFFSET
COMMA
VAR
INT
VALUE
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"MEM_WriteStatArr was called before MEM_InitStatArrs!"
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
MEM_READSTATARR
PARENOPEN
VAR
INT
ARRAY
COMMA
VAR
INT
OFFSET
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"MEM_ReadStatArr was called before MEM_InitStatArrs!"
PARENCLOSE
SEMICOLON
RETURN
INTEGER(0)
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEM_WRITESTATSTRINGARR
PARENOPEN
VAR
STRING
ARRAY
COMMA
VAR
INT
OFFSET
COMMA
VAR
STRING
VALUE
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"MEM_WriteStatStringArr was called before MEM_InitStatArrs!"
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
STRING
MEM_READSTATSTRINGARR
PARENOPEN
VAR
STRING
ARRAY
COMMA
VAR
INT
OFFSET
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"MEM_ReadStatStringArr was called before MEM_InitStatArrs!"
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEM_INITSTATARRS
PARENOPEN
PARENCLOSE
BRACKETOPEN
CONST
INT
DONE
ASSIGN
INTEGER(0)
SEMICOLON
IF
PARENOPEN
NOT
DONE
PARENCLOSE
BRACKETOPEN
MEM_REPLACEFUNC
PARENOPEN
MEM_WRITESTATARR
COMMA
MEMINT_WRITESTATARR
PARENCLOSE
SEMICOLON
MEM_REPLACEFUNC
PARENOPEN
MEM_READSTATARR
COMMA
MEMINT_READSTATARR
PARENCLOSE
SEMICOLON
MEM_REPLACEFUNC
PARENOPEN
MEM_WRITESTATSTRINGARR
COMMA
MEMINT_WRITESTATSTRINGARR
PARENCLOSE
SEMICOLON
MEM_REPLACEFUNC
PARENOPEN
MEM_READSTATSTRINGARR
COMMA
MEMINT_READSTATSTRINGARR
PARENCLOSE
SEMICOLON
DONE
ASSIGN
TRUE
SEMICOLON
BRACKETCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// ######################################################
// 
//   Speicher allozieren
// 
// ######################################################
FUNC
INT
MEM_ALLOC
PARENOPEN
VAR
INT
AMOUNT
PARENCLOSE
BRACKETOPEN
//  string mit AAAA holen 
VAR
INT
STRPTR
SEMICOLON
VAR
STRING
STR
SEMICOLON
STR
ASSIGN
"AAAA"
SEMICOLON
STRPTR
ASSIGN
_@S
PARENOPEN
STR
PARENCLOSE
SEMICOLON
// Adresse des zStrings im Symbol str.
VAR
ZSTRING
ZSTR
SEMICOLON
ZSTR
ASSIGN
_^
PARENOPEN
STRPTR
PARENCLOSE
SEMICOLON
// zstr zeigt jetzt auf str
//  aus den As Nuller machen, weil ich genullten Speicher will 
MEM_WRITEINT
PARENOPEN
ZSTR
PERIOD
PTR
COMMA
INTEGER(0)
PARENCLOSE
SEMICOLON
//  string mit sich selbst konkatenieren bis groß genug 
VAR
INT
SIZE
SEMICOLON
SIZE
ASSIGN
INTEGER(4)
SEMICOLON
// VORSICHT! mindestens einmal muss die Schleife durchlaufen werden.
// sonst kommt (vermutlich, nicht genau überprüft) statisch die Adrese von der Parserkonstanten "AAAA" zurück!
// Und das ist ein richtig mieser Fehler.
VAR
INT
LOOPSTART
SEMICOLON
LOOPSTART
ASSIGN
MEM_STACKPOS
PERIOD
POSITION
SEMICOLON
//  do 
STR
ASSIGN
CONCATSTRINGS
PARENOPEN
STR
COMMA
STR
PARENCLOSE
SEMICOLON
SIZE
MULTIPLYASSIGN
INTEGER(2)
SEMICOLON
//  while 
IF
PARENOPEN
SIZE
LOWER
AMOUNT
PARENCLOSE
BRACKETOPEN
MEM_STACKPOS
PERIOD
POSITION
ASSIGN
LOOPSTART
SEMICOLON
BRACKETCLOSE
SEMICOLON
//  Speicher ist jetzt reserviert. Dem String die Referenz wieder wegnehmen. 
//  Vorsicht: ptr in Strings zeigt auf das Byte nach dem ersten Reservierten!\n     * Strings haben Referenzzähler! 
VAR
INT
RES
SEMICOLON
RES
ASSIGN
ZSTR
PERIOD
PTR
MINUS
INTEGER(1)
SEMICOLON
ZSTR
PERIOD
PTR
ASSIGN
INTEGER(0)
SEMICOLON
ZSTR
PERIOD
LEN
ASSIGN
INTEGER(0)
SEMICOLON
ZSTR
PERIOD
RES
ASSIGN
INTEGER(0)
SEMICOLON
//  Der globale ConcatStrings-String darf keine Referenz mehr auf unseren String haben! 
// *(byte*)res == 1
STR
ASSIGN
CONCATSTRINGS
PARENOPEN
""
COMMA
""
PARENCLOSE
SEMICOLON
// *(byte*)res == 0
RETURN
RES
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEM_FREE
PARENOPEN
VAR
INT
PTR
PARENCLOSE
BRACKETOPEN
//  keine Nuller freigeben 
IF
PARENOPEN
NOT
PTR
PARENCLOSE
BRACKETOPEN
MEM_WARN
PARENOPEN
"MEM_Free: ptr is 0. Ignoring request."
PARENCLOSE
SEMICOLON
RETURN
SEMICOLON
BRACKETCLOSE
SEMICOLON
//  Vorsicht: ptr in Strings zeigt auf das Byte nach dem ersten Reservierten!\n     * Strings haben Referenzzähler! Den Nullen! 
MEM_WRITEBYTE
PARENOPEN
PTR
COMMA
INTEGER(0)
PARENCLOSE
SEMICOLON
PTR
PLUSASSIGN
INTEGER(1)
SEMICOLON
//  Hilfsstring holen 
VAR
INT
STRPTR
SEMICOLON
VAR
STRING
STR
SEMICOLON
STR
ASSIGN
""
SEMICOLON
STRPTR
ASSIGN
_@S
PARENOPEN
STR
PARENCLOSE
SEMICOLON
VAR
ZSTRING
ZSTR
SEMICOLON
ZSTR
ASSIGN
_^
PARENOPEN
STRPTR
PARENCLOSE
SEMICOLON
//  dem String den Speicher geben und mit Zuweisung von "" an den String freigeben 
ZSTR
PERIOD
PTR
ASSIGN
PTR
SEMICOLON
ZSTR
PERIOD
LEN
ASSIGN
INTEGER(1)
SEMICOLON
ZSTR
PERIOD
RES
ASSIGN
INTEGER(1)
SEMICOLON
STR
ASSIGN
""
SEMICOLON
BRACKETCLOSE
SEMICOLON
// #################################################
// 
//     CALL Package
// 
// #################################################
//  1 Byte 
CONST
INT
ASMINT_OP_MOVIMTOECX
ASSIGN
INTEGER(185)
SEMICOLON
// 0xB9
CONST
INT
ASMINT_OP_MOVIMTOEDX
ASSIGN
INTEGER(186)
SEMICOLON
// 0xBA
CONST
INT
ASMINT_OP_PUSHIM
ASSIGN
INTEGER(104)
SEMICOLON
// 0x68
CONST
INT
ASMINT_OP_CALL
ASSIGN
INTEGER(232)
SEMICOLON
// 0xE8
CONST
INT
ASMINT_OP_RETN
ASSIGN
INTEGER(195)
SEMICOLON
// 0xC3
CONST
INT
ASMINT_OP_NOP
ASSIGN
INTEGER(144)
SEMICOLON
// 0x90
CONST
INT
ASMINT_OP_JMP
ASSIGN
INTEGER(233)
SEMICOLON
// 0xE9
CONST
INT
ASMINT_OP_PUSHEAX
ASSIGN
INTEGER(80)
SEMICOLON
// 0x50
CONST
INT
ASMINT_OP_PUSHA
ASSIGN
INTEGER(96)
SEMICOLON
// 0x60 //aus LeGo geklaut
CONST
INT
ASMINT_OP_POPA
ASSIGN
INTEGER(97)
SEMICOLON
// 0x61 //aus LeGo geklaut
CONST
INT
ASMINT_OP_MOVMEMTOEAX
ASSIGN
INTEGER(161)
SEMICOLON
// 0xA1 //aus LeGo geklaut
//  2 Bytes 
CONST
INT
ASMINT_OP_MOVEAXTOMEM
ASSIGN
INTEGER(1417)
SEMICOLON
// 0x0589
CONST
INT
ASMINT_OP_FLOATSTORETOMEM
ASSIGN
INTEGER(7641)
SEMICOLON
// 0x1DD9
CONST
INT
ASMINT_OP_ADDIMTOESP
ASSIGN
INTEGER(50307)
SEMICOLON
// 0xC483
CONST
INT
ASMINT_OP_MOVMEMTOECX
ASSIGN
INTEGER(3467)
SEMICOLON
// 0x0D8B
CONST
INT
ASMINT_OP_MOVMEMTOEDX
ASSIGN
INTEGER(5515)
SEMICOLON
// 0x158B
CONST
INT
ASMINT_OP_MOVECXTOEAX
ASSIGN
INTEGER(49547)
SEMICOLON
// 0xC18B  aus LeGo geklaut
CONST
INT
ASMINT_OP_MOVESPTOEAX
ASSIGN
INTEGER(50315)
SEMICOLON
// 0xC48B  aus LeGo geklaut
CONST
INT
ASMINT_OP_MOVEAXTOECX
ASSIGN
INTEGER(49545)
SEMICOLON
// 0xC189  aus LeGo geklaut
CONST
INT
ASMINT_OP_MOVEBXTOEAX
ASSIGN
INTEGER(55433)
SEMICOLON
// 0xD889  aus LeGo geklaut
CONST
INT
ASMINT_OP_MOVEBPTOEAX
ASSIGN
INTEGER(50571)
SEMICOLON
// 0xC58B  aus LeGo geklaut
CONST
INT
ASMINT_OP_MOVEDITOEAX
ASSIGN
INTEGER(51083)
SEMICOLON
// 0xC78B  aus LeGo geklaut
CONST
INT
ASMINT_OP_ADDIMTOEAX
ASSIGN
INTEGER(49283)
SEMICOLON
// 0xC083  aus LeGo geklaut
//  Tuning:\n   If not specified differently,\n   there will be this much space available\n   for an Assembler sequence. 
CONST
INT
ASM_STANDARDSTREAMLENGTH
ASSIGN
INTEGER(256)
SEMICOLON
// ************************************************
//    ASM
// ************************************************
//  -----------------\n/  INTERNAL STACK\n/  ----------------- 
//  ASM needs to save data at two points:\n * 1.) When calling an engine function it needs to store\n * the address of the current run because the Call\n * might use the ASM package again!\n * 2.) When nesting the use of the Call package there\n * needs to be a push and pop of the context.\n * 3.) Overflows are unlikely and cause a crash.\n 
CONST
INT
ASMINT_INTERNALSTACK
ASSIGN
INTEGER(0)
SEMICOLON
CONST
INT
ASMINT_INTERNALSTACKWALKER
ASSIGN
INTEGER(0)
SEMICOLON
CONST
INT
ASMINT_INTERNALSTACKSIZE
ASSIGN
INTEGER(1024)
SEMICOLON
FUNC
VOID
ASMINT_PUSH
PARENOPEN
VAR
INT
DATA
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
ASMINT_INTERNALSTACKWALKER
GREATEREQUALS
ASMINT_INTERNALSTACKSIZE
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"ASMINT_Push: You seem to nest Engine Calls very extensively (or there is an Error in the ASM / CALL Package of Ikarus. Please contact Sekti with this problem!"
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
MEM_WRITEINTARRAY
PARENOPEN
ASMINT_INTERNALSTACK
COMMA
ASMINT_INTERNALSTACKWALKER
COMMA
DATA
PARENCLOSE
SEMICOLON
ASMINT_INTERNALSTACKWALKER
PLUSASSIGN
INTEGER(1)
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
ASMINT_POP
PARENOPEN
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
ASMINT_INTERNALSTACKWALKER
LOWEREQUALS
INTEGER(0)
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"ASMINT_Pop: Underflow! This is probably connected to wrong use of the Call functions."
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
ASMINT_INTERNALSTACKWALKER
MINUSASSIGN
INTEGER(1)
SEMICOLON
RETURN
MEM_READINTARRAY
PARENOPEN
ASMINT_INTERNALSTACK
COMMA
ASMINT_INTERNALSTACKWALKER
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
//  -----------------\n/  ASM Core\n/  ----------------- 
CONST
INT
ASMINT_CALLTARGET
ASSIGN
INTEGER(0)
SEMICOLON
FUNC
VOID
ASMINT_MYEXTERNAL
PARENOPEN
PARENCLOSE
BRACKETOPEN
BRACKETCLOSE
SEMICOLON
//  the Symbol belonging to this function will become an external symbol 
FUNC
VOID
ASMINT_CALLMYEXTERNAL
PARENOPEN
PARENCLOSE
BRACKETOPEN
//  calls some external 
EXITGAME
PARENOPEN
PARENCLOSE
SEMICOLON
//  will be changed so that it calls MyExternal 
BRACKETCLOSE
SEMICOLON
FUNC
VOID
ASMINT_INIT
PARENOPEN
PARENCLOSE
BRACKETOPEN
//  used later to set the pointer to the call-target. 
IF
PARENOPEN
NOT
ASMINT_INTERNALSTACK
PARENCLOSE
BRACKETOPEN
//  create an array for later use 
ASMINT_INTERNALSTACK
ASSIGN
MEM_ALLOC
PARENOPEN
INTEGER(4)
MULTIPLY
ASMINT_INTERNALSTACKSIZE
PARENCLOSE
SEMICOLON
//  find ASMINT_MyExternal 
ASMINT_CALLTARGET
ASSIGN
MEM_READINTARRAY
PARENOPEN
CURRSYMBOLTABLEADDRESS
COMMA
MEM_GETFUNCID
PARENOPEN
ASMINT_MYEXTERNAL
PARENCLOSE
PARENCLOSE
SEMICOLON
VAR
ZCPAR_SYMBOL
SYMB
SEMICOLON
SYMB
ASSIGN
_^
PARENOPEN
ASMINT_CALLTARGET
PARENCLOSE
SEMICOLON
ASMINT_CALLTARGET
PLUSASSIGN
ZCPARSYMBOL_CONTENT_OFFSET
SEMICOLON
// this is where i will write what to call
//  turn ASMINT_MyExternal into an external 
SYMB
PERIOD
BITFIELD
ASSIGN
ZPAR_TYPE_FUNC
BITOR
ZPAR_FLAG_EXTERNAL
BITOR
ZPAR_FLAG_CONST
SEMICOLON
//  have ASM_CallMyExternal call MyExternal instead of ExitGame 
MEM_WRITEINT
PARENOPEN
MEM_GETFUNCPTR
PARENOPEN
ASMINT_CALLMYEXTERNAL
PARENCLOSE
PLUS
INTEGER(1)
COMMA
MEM_GETFUNCID
PARENOPEN
ASMINT_MYEXTERNAL
PARENCLOSE
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
CONST
INT
ASMINT_CURRRUN
ASSIGN
INTEGER(0)
SEMICOLON
CONST
INT
ASMINT_CURSOR
ASSIGN
INTEGER(0)
SEMICOLON
CONST
INT
ASMINT_LENGTH
ASSIGN
INTEGER(0)
SEMICOLON
FUNC
VOID
ASM_OPEN
PARENOPEN
VAR
INT
SPACE
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
ASMINT_CURRRUN
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"ASM_Open: Only one stream of assembler code can be constructed at any given time (ASM_Open was called again before closing operation)."
PARENCLOSE
SEMICOLON
RETURN
SEMICOLON
BRACKETCLOSE
SEMICOLON
IF
PARENOPEN
NOT
SPACE
PARENCLOSE
BRACKETOPEN
SPACE
ASSIGN
ASM_STANDARDSTREAMLENGTH
SEMICOLON
// default size
BRACKETCLOSE
SEMICOLON
ASMINT_CURRRUN
ASSIGN
MEM_ALLOC
PARENOPEN
SPACE
PLUS
INTEGER(3)
PARENCLOSE
SEMICOLON
//  no byte fiddling at the end of the buffer 
ASMINT_LENGTH
ASSIGN
SPACE
SEMICOLON
ASMINT_CURSOR
ASSIGN
ASMINT_CURRRUN
SEMICOLON
//  pointing to the start 
BRACKETCLOSE
SEMICOLON
FUNC
VOID
ASM
PARENOPEN
VAR
INT
DATA
COMMA
VAR
INT
LENGTH
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
NOT
ASMINT_CURRRUN
PARENCLOSE
BRACKETOPEN
ASM_OPEN
PARENOPEN
INTEGER(0)
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
IF
PARENOPEN
ASMINT_CURSOR
MINUS
ASMINT_CURRRUN
PLUS
LENGTH
GREATER
ASMINT_LENGTH
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"ASM: Reserved length is exceeded."
PARENCLOSE
SEMICOLON
RETURN
SEMICOLON
BRACKETCLOSE
SEMICOLON
MEM_WRITEINT
PARENOPEN
ASMINT_CURSOR
COMMA
DATA
PARENCLOSE
SEMICOLON
ASMINT_CURSOR
PLUSASSIGN
LENGTH
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
ASM_1
PARENOPEN
VAR
INT
DATA
PARENCLOSE
BRACKETOPEN
ASM
PARENOPEN
DATA
COMMA
INTEGER(1)
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
ASM_2
PARENOPEN
VAR
INT
DATA
PARENCLOSE
BRACKETOPEN
ASM
PARENOPEN
DATA
COMMA
INTEGER(2)
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
ASM_3
PARENOPEN
VAR
INT
DATA
PARENCLOSE
BRACKETOPEN
ASM
PARENOPEN
DATA
COMMA
INTEGER(3)
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
ASM_4
PARENOPEN
VAR
INT
DATA
PARENCLOSE
BRACKETOPEN
ASM
PARENOPEN
DATA
COMMA
INTEGER(4)
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
ASM_HERE
PARENOPEN
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
NOT
ASMINT_CURRRUN
PARENCLOSE
BRACKETOPEN
ASM_OPEN
PARENOPEN
INTEGER(0)
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
RETURN
ASMINT_CURSOR
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
ASM_CLOSE
PARENOPEN
PARENCLOSE
BRACKETOPEN
ASM
PARENOPEN
ASMINT_OP_RETN
COMMA
INTEGER(1)
PARENCLOSE
SEMICOLON
VAR
INT
RES
SEMICOLON
RES
ASSIGN
ASMINT_CURRRUN
SEMICOLON
ASMINT_CURRRUN
ASSIGN
INTEGER(0)
SEMICOLON
RETURN
RES
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
ASM_RUN
PARENOPEN
VAR
INT
PTR
PARENCLOSE
BRACKETOPEN
MEM_WRITEINT
PARENOPEN
ASMINT_CALLTARGET
COMMA
PTR
PARENCLOSE
SEMICOLON
ASMINT_CALLMYEXTERNAL
PARENOPEN
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
ASM_RUNONCE
PARENOPEN
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
NOT
ASMINT_CURRRUN
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"ASM: ASM_Open has to be called before calling ASM_RunOnce."
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
ASM
PARENOPEN
ASMINT_OP_RETN
COMMA
INTEGER(1)
PARENCLOSE
SEMICOLON
//  Save this code in an array of codes.\n     * Reason: On calling it another instance of this function may be\n     * executing his own code 
ASMINT_PUSH
PARENOPEN
ASMINT_CURRRUN
PARENCLOSE
SEMICOLON
MEM_WRITEINT
PARENOPEN
ASMINT_CALLTARGET
COMMA
ASMINT_CURRRUN
PARENCLOSE
SEMICOLON
ASMINT_CURRRUN
ASSIGN
INTEGER(0)
SEMICOLON
// more Code can be build while this one is running.
ASMINT_CALLMYEXTERNAL
PARENOPEN
PARENCLOSE
SEMICOLON
//  Discard the code again 
MEM_FREE
PARENOPEN
ASMINT_POP
PARENOPEN
PARENCLOSE
PARENCLOSE
SEMICOLON
// free the run
BRACKETCLOSE
SEMICOLON
// ************************************************
//    Faster Calls
// ************************************************
CONST
INT
CALLINT_CODEMODE
ASSIGN
INTEGER(0)
SEMICOLON
CONST
INT
CALLINT_CODEMODE_DISPOSABLE
ASSIGN
INTEGER(0)
SEMICOLON
CONST
INT
CALLINT_CODEMODE_RECYCLABLE
ASSIGN
INTEGER(1)
SEMICOLON
CONST
INT
CALLINT_NUMPARAMS
ASSIGN
INTEGER(0)
SEMICOLON
CONST
INT
CALLINT_RETVALSTRUCTSIZE
ASSIGN
INTEGER(0)
SEMICOLON
CONST
INT
CALLINT_RETVALISFLOAT
ASSIGN
INTEGER(0)
SEMICOLON
CONST
INT
CALLINT_PUTRETVALTO
ASSIGN
INTEGER(0)
SEMICOLON
//  --------------------\n/  Push and Pop Context\n/  ----------------- 
//  This will be used by the call package.\n * It became nessessary as many basic library functions\n * want to make use of CALL while the user might already need it. 
FUNC
VOID
ASMINT_PUSHCONTEXT
PARENOPEN
PARENCLOSE
BRACKETOPEN
ASMINT_PUSH
PARENOPEN
CALLINT_RETVALSTRUCTSIZE
PARENCLOSE
SEMICOLON
ASMINT_PUSH
PARENOPEN
CALLINT_RETVALISFLOAT
PARENCLOSE
SEMICOLON
ASMINT_PUSH
PARENOPEN
CALLINT_PUTRETVALTO
PARENCLOSE
SEMICOLON
ASMINT_PUSH
PARENOPEN
CALLINT_NUMPARAMS
PARENCLOSE
SEMICOLON
ASMINT_PUSH
PARENOPEN
CALLINT_CODEMODE
PARENCLOSE
SEMICOLON
ASMINT_PUSH
PARENOPEN
ASMINT_CURRRUN
PARENCLOSE
SEMICOLON
ASMINT_PUSH
PARENOPEN
ASMINT_CURSOR
PARENCLOSE
SEMICOLON
ASMINT_PUSH
PARENOPEN
ASMINT_LENGTH
PARENCLOSE
SEMICOLON
ASMINT_CURRRUN
ASSIGN
INTEGER(0)
SEMICOLON
CALLINT_CODEMODE
ASSIGN
CALLINT_CODEMODE_DISPOSABLE
SEMICOLON
CALLINT_NUMPARAMS
ASSIGN
INTEGER(0)
SEMICOLON
CALLINT_RETVALISFLOAT
ASSIGN
INTEGER(0)
SEMICOLON
CALLINT_PUTRETVALTO
ASSIGN
INTEGER(0)
SEMICOLON
CALLINT_RETVALSTRUCTSIZE
ASSIGN
INTEGER(0)
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
ASMINT_POPCONTEXT
PARENOPEN
PARENCLOSE
BRACKETOPEN
ASMINT_LENGTH
ASSIGN
ASMINT_POP
PARENOPEN
PARENCLOSE
SEMICOLON
ASMINT_CURSOR
ASSIGN
ASMINT_POP
PARENOPEN
PARENCLOSE
SEMICOLON
ASMINT_CURRRUN
ASSIGN
ASMINT_POP
PARENOPEN
PARENCLOSE
SEMICOLON
CALLINT_CODEMODE
ASSIGN
ASMINT_POP
PARENOPEN
PARENCLOSE
SEMICOLON
CALLINT_NUMPARAMS
ASSIGN
ASMINT_POP
PARENOPEN
PARENCLOSE
SEMICOLON
CALLINT_PUTRETVALTO
ASSIGN
ASMINT_POP
PARENOPEN
PARENCLOSE
SEMICOLON
CALLINT_RETVALISFLOAT
ASSIGN
ASMINT_POP
PARENOPEN
PARENCLOSE
SEMICOLON
CALLINT_RETVALSTRUCTSIZE
ASSIGN
ASMINT_POP
PARENOPEN
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
//  There are two modes: The simple mode that produces a\n * disposable call that is used only once. All parameters\n * are hardcoded.\n * The second version produces code that can be used\n * more than once. Instead of the parameters the\n * user specifies the address where the parameters are\n * to be taken from. In addition to executing the code,\n * the user will receive an address that he can use\n * to repeat the call. This is much faster than\n * rebuilding the call from scratch. 
//  Receives a pointer. In case the pointer is non-zero,\n * the code at this position is executed and 0 is returned.\n * In case pointer is zero, the current mode is changed\n * into recyclable mode, this means that the call functions\n * expect instructions to build a recyclable call. This\n * mode will continue until CALL_End(). This allows code like this:\n \nfunc int EngineFunc_Wrapper(var int this, var int param) {\n    const int call = 0;\n    if(CALL_Begin(call)) {\n        CALL_IntParam(MEM_GetIntAddress(param));\n        CALL_thiscall(MEM_GetIntAddress(this), EngineFunc_ptr);\n        call = CALL_End();\n    };\n    return CALL_RetValAsInt();\n}; 
FUNC
VOID
CALL_OPEN
PARENOPEN
PARENCLOSE
BRACKETOPEN
//  Push an empty context too, it is unclear how CALL_Close is\n     * supposed to decide whether to pop or not.\n     * Besides: This will only be executed the first time. 
ASMINT_PUSHCONTEXT
PARENOPEN
PARENCLOSE
SEMICOLON
CALLINT_CODEMODE
ASSIGN
CALLINT_CODEMODE_RECYCLABLE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
CALL_BEGIN
PARENOPEN
VAR
INT
PTR
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
PTR
PARENCLOSE
BRACKETOPEN
ASM_RUN
PARENOPEN
PTR
PARENCLOSE
SEMICOLON
RETURN
INTEGER(0)
SEMICOLON
BRACKETCLOSE
SEMICOLON
CALL_OPEN
PARENOPEN
PARENCLOSE
SEMICOLON
RETURN
INTEGER(1)
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
CALL_CLOSE
PARENOPEN
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
CALLINT_CODEMODE
NOTEQUALS
CALLINT_CODEMODE_RECYCLABLE
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"CALL_Close: CALL_End or CALL_Close without matching CALL_Begin / CALL_Open? There is some serious problem with your code."
PARENCLOSE
SEMICOLON
RETURN
INTEGER(0)
SEMICOLON
BRACKETCLOSE
SEMICOLON
VAR
INT
PTR
SEMICOLON
PTR
ASSIGN
ASM_CLOSE
PARENOPEN
PARENCLOSE
SEMICOLON
ASMINT_POPCONTEXT
PARENOPEN
PARENCLOSE
SEMICOLON
//  restore previous context 
RETURN
PTR
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
CALL_END
PARENOPEN
PARENCLOSE
BRACKETOPEN
VAR
INT
PTR
SEMICOLON
PTR
ASSIGN
CALL_CLOSE
PARENOPEN
PARENCLOSE
SEMICOLON
ASMINT_PUSH
PARENOPEN
PTR
PARENCLOSE
SEMICOLON
ASM_RUN
PARENOPEN
PTR
PARENCLOSE
SEMICOLON
//  may use CALL_End 
RETURN
ASMINT_POP
PARENOPEN
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// ************************************************
//    Build the code to lay parameters
//    onto the machine stack.
// ************************************************
//  int 
FUNC
VOID
CALL_INTPARAM
PARENOPEN
VAR
INT
PARAM
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
CALLINT_CODEMODE
EQUALS
CALLINT_CODEMODE_RECYCLABLE
PARENCLOSE
BRACKETOPEN
ASM_1
PARENOPEN
ASMINT_OP_MOVMEMTOEAX
PARENCLOSE
SEMICOLON
ASM_4
PARENOPEN
PARAM
PARENCLOSE
SEMICOLON
ASM_1
PARENOPEN
ASMINT_OP_PUSHEAX
PARENCLOSE
SEMICOLON
BRACKETCLOSE
ELSE
BRACKETOPEN
ASM_1
PARENOPEN
ASMINT_OP_PUSHIM
PARENCLOSE
SEMICOLON
ASM_4
PARENOPEN
PARAM
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
CALLINT_NUMPARAMS
PLUSASSIGN
INTEGER(1)
SEMICOLON
BRACKETCLOSE
SEMICOLON
//  void 
FUNC
VOID
CALL_PTRPARAM
PARENOPEN
VAR
INT
PARAM
PARENCLOSE
BRACKETOPEN
CALL_INTPARAM
PARENOPEN
PARAM
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
//  float 
FUNC
VOID
CALL_FLOATPARAM
PARENOPEN
VAR
INT
PARAM
PARENCLOSE
BRACKETOPEN
CALL_INTPARAM
PARENOPEN
PARAM
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// string: Problem: The strings have to exist somewhere.
// To avoid ridiculously complicated code that needs to
// free the strings afterwards, I take 10 different static
// strings here. It is impropable that anyone ever wants
// to push more than ten strings on the machine stack at once.
FUNC
STRING
CALLINT_PUSHSTRING
PARENOPEN
VAR
STRING
STR
PARENCLOSE
BRACKETOPEN
VAR
INT
N
SEMICOLON
N
PLUSASSIGN
INTEGER(1)
SEMICOLON
IF
PARENOPEN
N
EQUALS
INTEGER(10)
PARENCLOSE
BRACKETOPEN
N
ASSIGN
INTEGER(0)
SEMICOLON
BRACKETCLOSE
SEMICOLON
IF
PARENOPEN
N
EQUALS
INTEGER(0)
PARENCLOSE
BRACKETOPEN
VAR
STRING
S0
SEMICOLON
S0
ASSIGN
STR
SEMICOLON
RETURN
S0
SEMICOLON
BRACKETCLOSE
SEMICOLON
IF
PARENOPEN
N
EQUALS
INTEGER(1)
PARENCLOSE
BRACKETOPEN
VAR
STRING
S1
SEMICOLON
S1
ASSIGN
STR
SEMICOLON
RETURN
S1
SEMICOLON
BRACKETCLOSE
SEMICOLON
IF
PARENOPEN
N
EQUALS
INTEGER(2)
PARENCLOSE
BRACKETOPEN
VAR
STRING
S2
SEMICOLON
S2
ASSIGN
STR
SEMICOLON
RETURN
S2
SEMICOLON
BRACKETCLOSE
SEMICOLON
IF
PARENOPEN
N
EQUALS
INTEGER(3)
PARENCLOSE
BRACKETOPEN
VAR
STRING
S3
SEMICOLON
S3
ASSIGN
STR
SEMICOLON
RETURN
S3
SEMICOLON
BRACKETCLOSE
SEMICOLON
IF
PARENOPEN
N
EQUALS
INTEGER(4)
PARENCLOSE
BRACKETOPEN
VAR
STRING
S4
SEMICOLON
S4
ASSIGN
STR
SEMICOLON
RETURN
S4
SEMICOLON
BRACKETCLOSE
SEMICOLON
IF
PARENOPEN
N
EQUALS
INTEGER(5)
PARENCLOSE
BRACKETOPEN
VAR
STRING
S5
SEMICOLON
S5
ASSIGN
STR
SEMICOLON
RETURN
S5
SEMICOLON
BRACKETCLOSE
SEMICOLON
IF
PARENOPEN
N
EQUALS
INTEGER(6)
PARENCLOSE
BRACKETOPEN
VAR
STRING
S6
SEMICOLON
S6
ASSIGN
STR
SEMICOLON
RETURN
S6
SEMICOLON
BRACKETCLOSE
SEMICOLON
IF
PARENOPEN
N
EQUALS
INTEGER(7)
PARENCLOSE
BRACKETOPEN
VAR
STRING
S7
SEMICOLON
S7
ASSIGN
STR
SEMICOLON
RETURN
S7
SEMICOLON
BRACKETCLOSE
SEMICOLON
IF
PARENOPEN
N
EQUALS
INTEGER(8)
PARENCLOSE
BRACKETOPEN
VAR
STRING
S8
SEMICOLON
S8
ASSIGN
STR
SEMICOLON
RETURN
S8
SEMICOLON
BRACKETCLOSE
SEMICOLON
IF
PARENOPEN
N
EQUALS
INTEGER(9)
PARENCLOSE
BRACKETOPEN
VAR
STRING
S9
SEMICOLON
S9
ASSIGN
STR
SEMICOLON
RETURN
S9
SEMICOLON
BRACKETCLOSE
SEMICOLON
MEM_ASSERTFAIL
PARENOPEN
"Should be never here."
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
CALLINT_GETSTRINGADDRESS
PARENOPEN
VAR
STRING
STR
PARENCLOSE
BRACKETOPEN
RETURN
_@S
PARENOPEN
CALLINT_PUSHSTRING
PARENOPEN
STR
PARENCLOSE
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
//  zString*  
FUNC
VOID
CALL_ZSTRINGPTRPARAM
PARENOPEN
VAR
STRING
PARAM
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
CALLINT_CODEMODE
NOTEQUALS
CALLINT_CODEMODE_DISPOSABLE
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"CALL_zStringPtrParam: This function only works when writing a disposable call!"
PARENCLOSE
SEMICOLON
RETURN
SEMICOLON
BRACKETCLOSE
SEMICOLON
//  simply push the address onto the stack 
CALL_INTPARAM
PARENOPEN
CALLINT_GETSTRINGADDRESS
PARENOPEN
PARAM
PARENCLOSE
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
//  cString*  
FUNC
VOID
CALL_CSTRINGPTRPARAM
PARENOPEN
VAR
STRING
PARAM
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
CALLINT_CODEMODE
NOTEQUALS
CALLINT_CODEMODE_DISPOSABLE
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"CALL_cStringPtrParam: This function only works when writing a disposable call!"
PARENCLOSE
SEMICOLON
RETURN
SEMICOLON
BRACKETCLOSE
SEMICOLON
//  get the Pointer to the data and lay it on the stack 
VAR
ZSTRING
STR
SEMICOLON
STR
ASSIGN
_^
PARENOPEN
CALLINT_GETSTRINGADDRESS
PARENOPEN
PARAM
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL_INTPARAM
PARENOPEN
STR
PERIOD
PTR
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
//  struct (not a Pointer to a struct, but a struct as is) 
FUNC
VOID
CALL_STRUCTPARAM
PARENOPEN
VAR
INT
PTR
COMMA
VAR
INT
WORDS
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
CALLINT_CODEMODE
EQUALS
CALLINT_CODEMODE_RECYCLABLE
PARENCLOSE
BRACKETOPEN
CALL_INTPARAM
PARENOPEN
PTR
PLUS
INTEGER(4)
MULTIPLY
PARENOPEN
WORDS
MINUS
INTEGER(1)
PARENCLOSE
PARENCLOSE
SEMICOLON
//  this is where i expect the last word 
CALL_STRUCTPARAM
PARENOPEN
PTR
COMMA
WORDS
MINUS
INTEGER(1)
PARENCLOSE
SEMICOLON
RETURN
SEMICOLON
BRACKETCLOSE
SEMICOLON
//  the struct as a whole has to be pushed onto the stack\n     * it has to be pushed in reverse order to lie correctly 
IF
PARENOPEN
WORDS
GREATER
INTEGER(0)
PARENCLOSE
BRACKETOPEN
CALL_INTPARAM
PARENOPEN
MEM_READINTARRAY
PARENOPEN
PTR
COMMA
WORDS
MINUS
INTEGER(1)
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL_STRUCTPARAM
PARENOPEN
PTR
COMMA
WORDS
MINUS
INTEGER(1)
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
//  switch: If the return value is a structure with a size\n * larget than 32 bit, the space for the return value has\n * to be allocated by the caller (this is us).\n * The address to the allocated memory is expected on the stack\n * as an additional parameter (pushed last)\n *\n * Warning: It is in the your responsibility to free\n * the memory, when the return value is not needed anymore.\n 
FUNC
VOID
CALL_RETVALISSTRUCT
PARENOPEN
VAR
INT
SIZE
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
CALLINT_CODEMODE
EQUALS
CALLINT_CODEMODE_RECYCLABLE
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"CALL_RetValIsStruct: Only supported in disposable calls (not with CALL_Begin and CALL_End)."
PARENCLOSE
SEMICOLON
RETURN
SEMICOLON
BRACKETCLOSE
SEMICOLON
CALLINT_RETVALSTRUCTSIZE
ASSIGN
SIZE
SEMICOLON
BRACKETCLOSE
SEMICOLON
//  a special case of CALL_RetValIsStruct\n * a zString is a structure with the size of 20 bytes. 
FUNC
VOID
CALL_RETVALISZSTRING
PARENOPEN
PARENCLOSE
BRACKETOPEN
CALL_RETVALISSTRUCT
PARENOPEN
SIZEOF_ZSTRING
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
//  switch: If the return value is a float (and therefore\n * lies on the top of the FPU stack instead of lying in eax\n * I need to know that. 
FUNC
VOID
CALL_RETVALISFLOAT
PARENOPEN
PARENCLOSE
BRACKETOPEN
CALLINT_RETVALISFLOAT
ASSIGN
TRUE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
CALL_PUTRETVALTO
PARENOPEN
VAR
INT
ADR
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
ADR
EQUALS
INTEGER(0)
PARENCLOSE
BRACKETOPEN
CALLINT_PUTRETVALTO
ASSIGN
MINUS
INTEGER(1)
SEMICOLON
BRACKETCLOSE
ELSE
BRACKETOPEN
CALLINT_PUTRETVALTO
ASSIGN
ADR
SEMICOLON
BRACKETCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// ************************************************
//    Getting the result after a call
// ************************************************
//  returns a value that is written to by the call 
VAR
INT
CALLINT_RESULT
SEMICOLON
//  if the value some 32 bit constant, there is nothing to do 
FUNC
INT
CALL_RETVALASINT
PARENOPEN
PARENCLOSE
BRACKETOPEN
RETURN
PLUS
CALLINT_RESULT
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
CALL_RETVALASFLOAT
PARENOPEN
PARENCLOSE
BRACKETOPEN
RETURN
PLUS
CALLINT_RESULT
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
CALL_RETVALASPTR
PARENOPEN
PARENCLOSE
BRACKETOPEN
RETURN
PLUS
CALLINT_RESULT
SEMICOLON
BRACKETCLOSE
SEMICOLON
//  for those who are to lazy to use _^ themselves: 
FUNC
MEMINT_HELPERCLASS
CALL_RETVALASSTRUCTPTR
PARENOPEN
PARENCLOSE
BRACKETOPEN
_^
PARENOPEN
CALLINT_RESULT
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
//  parser data stack hacking does the trick for pointer to zStrings 
FUNC
STRING
CALL_RETVALASZSTRINGPTR
PARENOPEN
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
CALLINT_RESULT
PARENCLOSE
BRACKETOPEN
MEMINT_STACKPUSHVAR
PARENOPEN
CALLINT_RESULT
PARENCLOSE
SEMICOLON
BRACKETCLOSE
ELSE
BRACKETOPEN
RETURN
""
SEMICOLON
BRACKETCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
//  A zString is merely a special case of a structure, with the difference,\n * that it is used as a primitive datatype. Nobody will be willing\n * to use it as a pointer to some memory or an instance in Daedalus.\n * This function copies the contents of the zString into a\n * daedalus string and frees the zString afterwards. 
FUNC
STRING
CALL_RETVALASZSTRING
PARENOPEN
PARENCLOSE
BRACKETOPEN
VAR
STRING
RET
SEMICOLON
IF
PARENOPEN
CALLINT_RESULT
PARENCLOSE
BRACKETOPEN
RET
ASSIGN
CALL_RETVALASZSTRINGPTR
PARENOPEN
PARENCLOSE
SEMICOLON
MEMINT_STACKPUSHSTRING
PARENOPEN
""
PARENCLOSE
SEMICOLON
CALL_RETVALASZSTRINGPTR
PARENOPEN
PARENCLOSE
SEMICOLON
MEMINT_STRASSIGN
PARENOPEN
PARENCLOSE
SEMICOLON
MEM_FREE
PARENOPEN
CALLINT_RESULT
PARENCLOSE
SEMICOLON
CALLINT_RESULT
ASSIGN
INTEGER(0)
SEMICOLON
BRACKETCLOSE
SEMICOLON
RETURN
RET
SEMICOLON
BRACKETCLOSE
SEMICOLON
// ************************************************
//    The calls
// ************************************************
FUNC
VOID
CALLINT_MAKECALL
PARENOPEN
VAR
INT
ADR
COMMA
VAR
INT
CLEANSTACK
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
CALLINT_RETVALSTRUCTSIZE
PARENCLOSE
BRACKETOPEN
CALL_INTPARAM
PARENOPEN
MEM_ALLOC
PARENOPEN
CALLINT_RETVALSTRUCTSIZE
PARENCLOSE
PARENCLOSE
SEMICOLON
CALLINT_RETVALSTRUCTSIZE
ASSIGN
INTEGER(0)
SEMICOLON
BRACKETCLOSE
SEMICOLON
//  make the call: 
ASM_1
PARENOPEN
ASMINT_OP_CALL
PARENCLOSE
SEMICOLON
ASM_4
PARENOPEN
ADR
MINUS
ASM_HERE
PARENOPEN
PARENCLOSE
MINUS
INTEGER(4)
PARENCLOSE
SEMICOLON
//  -4, because the jump is relative to the _next_ instruction. 
//  copy the result into a daedalus variable 
IF
PARENOPEN
CALLINT_PUTRETVALTO
NOTEQUALS
MINUS
INTEGER(1)
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
NOT
CALLINT_RETVALISFLOAT
PARENCLOSE
BRACKETOPEN
ASM_2
PARENOPEN
ASMINT_OP_MOVEAXTOMEM
PARENCLOSE
SEMICOLON
//  mov CALLINT_Result eax 
BRACKETCLOSE
ELSE
BRACKETOPEN
ASM_2
PARENOPEN
ASMINT_OP_FLOATSTORETOMEM
PARENCLOSE
SEMICOLON
//  fstp CALLINT_Result 
BRACKETCLOSE
SEMICOLON
IF
PARENOPEN
CALLINT_PUTRETVALTO
PARENCLOSE
BRACKETOPEN
ASM_4
PARENOPEN
CALLINT_PUTRETVALTO
PARENCLOSE
SEMICOLON
BRACKETCLOSE
ELSE
BRACKETOPEN
ASM_4
PARENOPEN
MEM_GETINTADDRESS
PARENOPEN
CALLINT_RESULT
PARENCLOSE
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
//  default: return value is not a float\n     * and has default location 
CALLINT_RETVALISFLOAT
ASSIGN
FALSE
SEMICOLON
// fürs nächste mal muss neugeschaltet werden.
CALLINT_PUTRETVALTO
ASSIGN
INTEGER(0)
SEMICOLON
//  __cdecl has to clean the stack here: 
IF
PARENOPEN
CLEANSTACK
PARENCLOSE
BRACKETOPEN
ASM_2
PARENOPEN
ASMINT_OP_ADDIMTOESP
PARENCLOSE
SEMICOLON
ASM_1
PARENOPEN
CALLINT_NUMPARAMS
MULTIPLY
INTEGER(4)
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
//  reset Param Counter 
CALLINT_NUMPARAMS
ASSIGN
INTEGER(0)
SEMICOLON
//  run the code that was build and discard it afterwards 
IF
PARENOPEN
CALLINT_CODEMODE
NOTEQUALS
CALLINT_CODEMODE_RECYCLABLE
PARENCLOSE
BRACKETOPEN
ASM_RUNONCE
PARENOPEN
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
//  all Parameters are passed on the stack (right to left)\n   callee cleans the stack 
FUNC
VOID
CALL__STDCALL
PARENOPEN
VAR
INT
ADR
PARENCLOSE
BRACKETOPEN
CALLINT_MAKECALL
PARENOPEN
ADR
COMMA
FALSE
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
//  all Parameters are passed on the stack (right to left)\n   caller cleans the stack 
FUNC
VOID
CALL__CDECL
PARENOPEN
VAR
INT
ADR
PARENCLOSE
BRACKETOPEN
CALLINT_MAKECALL
PARENOPEN
ADR
COMMA
TRUE
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
//  __stdcall but with a this pointer in ecx. 
FUNC
VOID
CALL__THISCALL
PARENOPEN
VAR
INT
THIS
COMMA
VAR
INT
ADR
PARENCLOSE
BRACKETOPEN
//  this -> ecx 
IF
PARENOPEN
CALLINT_CODEMODE
EQUALS
CALLINT_CODEMODE_RECYCLABLE
PARENCLOSE
BRACKETOPEN
ASM_2
PARENOPEN
ASMINT_OP_MOVMEMTOECX
PARENCLOSE
SEMICOLON
BRACKETCLOSE
ELSE
BRACKETOPEN
ASM_1
PARENOPEN
ASMINT_OP_MOVIMTOECX
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
ASM_4
PARENOPEN
THIS
PARENCLOSE
SEMICOLON
CALL__STDCALL
PARENOPEN
ADR
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
//  __stdcall but with the first two parameters passed in ecx and edx. 
FUNC
VOID
CALL__FASTCALL
PARENOPEN
VAR
INT
ECX
COMMA
VAR
INT
EDX
COMMA
VAR
INT
ADR
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
CALLINT_CODEMODE
EQUALS
CALLINT_CODEMODE_RECYCLABLE
PARENCLOSE
BRACKETOPEN
ASM_2
PARENOPEN
ASMINT_OP_MOVMEMTOEDX
PARENCLOSE
SEMICOLON
BRACKETCLOSE
ELSE
BRACKETOPEN
ASM_1
PARENOPEN
ASMINT_OP_MOVIMTOEDX
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
ASM_4
PARENOPEN
EDX
PARENCLOSE
SEMICOLON
CALL__THISCALL
PARENOPEN
ECX
COMMA
ADR
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// #################################################
// 
//     UTILITY
// 
// #################################################
// --------------------------------------
//  Debuginformationen anschalten
// --------------------------------------
//  Empfehlung: Sofort in Startup_Global und Init_Global\n * die Debuginformationen anmachen.\n * Schadet bestimmt nicht.\n * Bei der Auslieferung der Mod wieder rausnehmen. 
FUNC
VOID
MEM_SETSHOWDEBUG
PARENOPEN
VAR
INT
ON
PARENCLOSE
BRACKETOPEN
MEM_WRITEINT
PARENOPEN
SHOWDEBUGADDRESS
COMMA
ON
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// ----------------------------------
//   Bereichskopieren
// ----------------------------------
FUNC
VOID
MEM_COPYBYTES
PARENOPEN
VAR
INT
SRC
COMMA
VAR
INT
DST
COMMA
VAR
INT
BYTECOUNT
PARENCLOSE
BRACKETOPEN
CONST
INT
MEMCPY_G1
ASSIGN
INTEGER(7846464)
SEMICOLON
// 0x77BA40
CONST
INT
MEMCPY_G2
ASSIGN
INTEGER(8213280)
SEMICOLON
// 0x7D5320
CONST
INT
CALL
ASSIGN
INTEGER(0)
SEMICOLON
IF
PARENOPEN
CALL_BEGIN
PARENOPEN
CALL
PARENCLOSE
PARENCLOSE
BRACKETOPEN
CALL_INTPARAM
PARENOPEN
_@
PARENOPEN
BYTECOUNT
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL_INTPARAM
PARENOPEN
_@
PARENOPEN
SRC
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL_INTPARAM
PARENOPEN
_@
PARENOPEN
DST
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL_PUTRETVALTO
PARENOPEN
INTEGER(0)
PARENCLOSE
SEMICOLON
CALL__CDECL
PARENOPEN
MEMINT_SWITCHG1G2
PARENOPEN
MEMCPY_G1
COMMA
MEMCPY_G2
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL
ASSIGN
CALL_END
PARENOPEN
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEM_COPYWORDS
PARENOPEN
VAR
INT
SRC
COMMA
VAR
INT
DST
COMMA
VAR
INT
WORDCOUNT
PARENCLOSE
BRACKETOPEN
MEM_COPYBYTES
PARENOPEN
SRC
COMMA
DST
COMMA
WORDCOUNT
MULTIPLY
INTEGER(4)
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// alias, Abwärtskompatibilität
FUNC
VOID
MEM_COPY
PARENOPEN
VAR
INT
SRC
COMMA
VAR
INT
DST
COMMA
VAR
INT
WORDCOUNT
PARENCLOSE
BRACKETOPEN
MEM_COPYBYTES
PARENOPEN
SRC
COMMA
DST
COMMA
WORDCOUNT
MULTIPLY
INTEGER(4)
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// ----------------------------------
//   Swappen (was auch immer ich mir dabei gedacht habe)
// ----------------------------------
FUNC
VOID
MEM_SWAPBYTES
PARENOPEN
VAR
INT
SRC
COMMA
VAR
INT
DST
COMMA
VAR
INT
BYTECOUNT
PARENCLOSE
BRACKETOPEN
CONST
INT
SWAP_G1
ASSIGN
INTEGER(7829281)
SEMICOLON
// 0x777721
CONST
INT
SWAP_G2
ASSIGN
INTEGER(8196369)
SEMICOLON
// 0x7D1111
CONST
INT
CALL
ASSIGN
INTEGER(0)
SEMICOLON
IF
PARENOPEN
CALL_BEGIN
PARENOPEN
CALL
PARENCLOSE
PARENCLOSE
BRACKETOPEN
CALL_INTPARAM
PARENOPEN
_@
PARENOPEN
BYTECOUNT
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL_PTRPARAM
PARENOPEN
_@
PARENOPEN
SRC
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL_PTRPARAM
PARENOPEN
_@
PARENOPEN
DST
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL_PUTRETVALTO
PARENOPEN
INTEGER(0)
PARENCLOSE
SEMICOLON
CALL__CDECL
PARENOPEN
MEMINT_SWITCHG1G2
PARENOPEN
SWAP_G1
COMMA
SWAP_G2
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL
ASSIGN
CALL_END
PARENOPEN
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEM_SWAP
PARENOPEN
VAR
INT
SRC
COMMA
VAR
INT
DST
COMMA
VAR
INT
WORDCOUNT
PARENCLOSE
BRACKETOPEN
MEM_SWAPBYTES
PARENOPEN
SRC
COMMA
DST
COMMA
WORDCOUNT
MULTIPLY
INTEGER(4)
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEM_SWAPWORDS
PARENOPEN
VAR
INT
SRC
COMMA
VAR
INT
DST
COMMA
VAR
INT
WORDCOUNT
PARENCLOSE
BRACKETOPEN
MEM_SWAPBYTES
PARENOPEN
SRC
COMMA
DST
COMMA
WORDCOUNT
MULTIPLY
INTEGER(4)
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// ----------------------------------
//   memset
// ----------------------------------
FUNC
VOID
MEM_CLEAR
PARENOPEN
VAR
INT
PTR
COMMA
VAR
INT
SIZE
PARENCLOSE
BRACKETOPEN
CONST
INT
MEMSET_G1
ASSIGN
INTEGER(7877040)
SEMICOLON
// 0x7831B0
CONST
INT
MEMSET_G2
ASSIGN
INTEGER(8243856)
SEMICOLON
// 0x7DCA90
VAR
INT
NULL
SEMICOLON
CONST
INT
CALL
ASSIGN
INTEGER(0)
SEMICOLON
IF
PARENOPEN
CALL_BEGIN
PARENOPEN
CALL
PARENCLOSE
PARENCLOSE
BRACKETOPEN
CALL_INTPARAM
PARENOPEN
_@
PARENOPEN
SIZE
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL_INTPARAM
PARENOPEN
_@
PARENOPEN
NULL
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL_PTRPARAM
PARENOPEN
_@
PARENOPEN
PTR
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL_PUTRETVALTO
PARENOPEN
INTEGER(0)
PARENCLOSE
SEMICOLON
CALL__CDECL
PARENOPEN
MEMINT_SWITCHG1G2
PARENOPEN
MEMSET_G1
COMMA
MEMSET_G2
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL
ASSIGN
CALL_END
PARENOPEN
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// ----------------------------------
//   Realloc
// ----------------------------------
//  Speicher in ein neues Array kopieren 
FUNC
INT
MEM_REALLOC
PARENOPEN
VAR
INT
PTR
COMMA
VAR
INT
OLDSIZE
COMMA
VAR
INT
NEWSIZE
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
NOT
PTR
PARENCLOSE
BRACKETOPEN
//  Meckern? 
IF
PARENOPEN
NOT
OLDSIZE
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"MEM_Realloc: ptr is 0 but oldsize is not 0."
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
RETURN
MEM_ALLOC
PARENOPEN
NEWSIZE
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
CONST
INT
REALLOC_G1
ASSIGN
INTEGER(7712186)
SEMICOLON
// 0x75ADBA
CONST
INT
REALLOC_G2
ASSIGN
INTEGER(8078522)
SEMICOLON
// 0x7B44BA
CONST
INT
CALL
ASSIGN
INTEGER(0)
SEMICOLON
IF
PARENOPEN
CALL_BEGIN
PARENOPEN
CALL
PARENCLOSE
PARENCLOSE
BRACKETOPEN
CALL_INTPARAM
PARENOPEN
_@
PARENOPEN
NEWSIZE
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL_PTRPARAM
PARENOPEN
_@
PARENOPEN
PTR
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL_PUTRETVALTO
PARENOPEN
_@
PARENOPEN
PTR
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL__CDECL
PARENOPEN
MEMINT_SWITCHG1G2
PARENOPEN
REALLOC_G1
COMMA
REALLOC_G2
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL
ASSIGN
CALL_END
PARENOPEN
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
//  ptr is now filled 
IF
PARENOPEN
OLDSIZE
LOWER
NEWSIZE
PARENCLOSE
BRACKETOPEN
MEM_CLEAR
PARENOPEN
PTR
PLUS
OLDSIZE
COMMA
NEWSIZE
MINUS
OLDSIZE
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
RETURN
PLUS
PTR
SEMICOLON
BRACKETCLOSE
SEMICOLON
// ************************************************
//    Compare Memory
// ************************************************
//  couldnt find memcmp at first glance...\n * left it as it is. 
FUNC
INT
MEM_COMPAREBYTES
PARENOPEN
VAR
INT
PTR1
COMMA
VAR
INT
PTR2
COMMA
VAR
INT
BYTECOUNT
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
BYTECOUNT
LOWER
INTEGER(0)
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"MEM_CompareBytes: Cannot compare less than 0 bytes!"
PARENCLOSE
SEMICOLON
RETURN
INTEGER(0)
SEMICOLON
BRACKETCLOSE
SEMICOLON
IF
PARENOPEN
BYTECOUNT
EQUALS
INTEGER(0)
PARENCLOSE
BRACKETOPEN
// in this case the addresses may be invalid.
RETURN
INTEGER(1)
SEMICOLON
BRACKETCLOSE
SEMICOLON
IF
PARENOPEN
PTR1
EQUALS
INTEGER(0)
PARENCLOSE
OR
PARENOPEN
PTR2
EQUALS
INTEGER(0)
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"MEM_CompareBytes: ptr1 or ptr2 is Null"
PARENCLOSE
SEMICOLON
RETURN
INTEGER(0)
SEMICOLON
BRACKETCLOSE
SEMICOLON
VAR
INT
LOOPPOS
SEMICOLON
LOOPPOS
ASSIGN
MEM_STACKPOS
PERIOD
POSITION
SEMICOLON
IF
PARENOPEN
BYTECOUNT
GREATEREQUALS
INTEGER(4)
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
MEM_READINT
PARENOPEN
PTR1
PARENCLOSE
NOTEQUALS
MEM_READINT
PARENOPEN
PTR2
PARENCLOSE
PARENCLOSE
BRACKETOPEN
RETURN
INTEGER(0)
SEMICOLON
BRACKETCLOSE
SEMICOLON
PTR1
PLUSASSIGN
INTEGER(4)
SEMICOLON
PTR2
PLUSASSIGN
INTEGER(4)
SEMICOLON
BYTECOUNT
MINUSASSIGN
INTEGER(4)
SEMICOLON
MEM_STACKPOS
PERIOD
POSITION
ASSIGN
LOOPPOS
SEMICOLON
BRACKETCLOSE
SEMICOLON
VAR
INT
MASK
SEMICOLON
MASK
ASSIGN
PARENOPEN
INTEGER(1)
SHIFTLEFT
BYTECOUNT
MULTIPLY
INTEGER(8)
PARENCLOSE
MINUS
INTEGER(1)
SEMICOLON
RETURN
PARENOPEN
MEM_READINT
PARENOPEN
PTR1
PARENCLOSE
BITAND
MASK
PARENCLOSE
EQUALS
PARENOPEN
MEM_READINT
PARENOPEN
PTR2
PARENCLOSE
BITAND
MASK
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
MEM_COMPAREWORDS
PARENOPEN
VAR
INT
PTR0
COMMA
VAR
INT
PTR1
COMMA
VAR
INT
WORDCOUNT
PARENCLOSE
BRACKETOPEN
RETURN
MEM_COMPAREBYTES
PARENOPEN
PTR0
COMMA
PTR1
COMMA
WORDCOUNT
MULTIPLY
INTEGER(4)
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
MEM_COMPARE
PARENOPEN
VAR
INT
PTR0
COMMA
VAR
INT
PTR1
COMMA
VAR
INT
WORDCOUNT
PARENCLOSE
BRACKETOPEN
RETURN
MEM_COMPAREBYTES
PARENOPEN
PTR0
COMMA
PTR1
COMMA
WORDCOUNT
MULTIPLY
INTEGER(4)
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// #################################################
// 
//     Windows Utilities
// 
// #################################################
// --------------------------------------
//    Funktionen aus anderen DLLs laden
// --------------------------------------
//   http://msdn.microsoft.com/en-us/library/ms684175%28v=vs.85%29.aspx 
FUNC
INT
LOADLIBRARY
PARENOPEN
VAR
STRING
LPFILENAME
PARENCLOSE
BRACKETOPEN
CONST
INT
CALL
ASSIGN
INTEGER(0)
SEMICOLON
IF
PARENOPEN
CALL_BEGIN
PARENOPEN
CALL
PARENCLOSE
PARENCLOSE
BRACKETOPEN
VAR
INT
WINAPI__LOADLIBRARY
SEMICOLON
IF
PARENOPEN
GOTHIC_BASE_VERSION
EQUALS
INTEGER(2)
PARENCLOSE
BRACKETOPEN
WINAPI__LOADLIBRARY
ASSIGN
MEM_READINT
PARENOPEN
INTEGER(8577604)
PARENCLOSE
SEMICOLON
// 0x82E244
BRACKETCLOSE
ELSE
BRACKETOPEN
WINAPI__LOADLIBRARY
ASSIGN
MEM_READINT
PARENOPEN
INTEGER(8192588)
PARENCLOSE
SEMICOLON
// 0x7D024C
BRACKETCLOSE
SEMICOLON
CALL_PTRPARAM
PARENOPEN
_@S
PARENOPEN
LPFILENAME
PARENCLOSE
PLUS
INTEGER(8)
//  offset of ptr 
PARENCLOSE
SEMICOLON
CALL_PUTRETVALTO
PARENOPEN
_@
PARENOPEN
RET
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL__STDCALL
PARENOPEN
WINAPI__LOADLIBRARY
PARENCLOSE
SEMICOLON
CALL
ASSIGN
CALL_END
PARENOPEN
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
VAR
INT
RET
SEMICOLON
RETURN
PLUS
RET
SEMICOLON
BRACKETCLOSE
SEMICOLON
//  http://msdn.microsoft.com/en-us/library/ms683212%28v=vs.85%29.aspx 
FUNC
INT
GETPROCADDRESS
PARENOPEN
VAR
INT
HMODULE
COMMA
VAR
STRING
LPPROCNAME
PARENCLOSE
BRACKETOPEN
CONST
INT
CALL
ASSIGN
INTEGER(0)
SEMICOLON
IF
PARENOPEN
CALL_BEGIN
PARENOPEN
CALL
PARENCLOSE
PARENCLOSE
BRACKETOPEN
VAR
INT
WINAPI__GETPROCADDRESS
SEMICOLON
IF
PARENOPEN
GOTHIC_BASE_VERSION
EQUALS
INTEGER(2)
PARENCLOSE
BRACKETOPEN
WINAPI__GETPROCADDRESS
ASSIGN
MEM_READINT
PARENOPEN
INTEGER(8577688)
PARENCLOSE
SEMICOLON
// 0x82E298
BRACKETCLOSE
ELSE
BRACKETOPEN
WINAPI__GETPROCADDRESS
ASSIGN
MEM_READINT
PARENOPEN
INTEGER(8192260)
PARENCLOSE
SEMICOLON
// 0x7D0104
BRACKETCLOSE
SEMICOLON
CALL_PTRPARAM
PARENOPEN
_@S
PARENOPEN
LPPROCNAME
PARENCLOSE
PLUS
INTEGER(8)
//  offset of ptr 
PARENCLOSE
SEMICOLON
CALL_PTRPARAM
PARENOPEN
_@
PARENOPEN
HMODULE
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL_PUTRETVALTO
PARENOPEN
_@
PARENOPEN
RET
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL__STDCALL
PARENOPEN
WINAPI__GETPROCADDRESS
PARENCLOSE
SEMICOLON
CALL
ASSIGN
CALL_END
PARENOPEN
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
VAR
INT
RET
SEMICOLON
RETURN
PLUS
RET
SEMICOLON
BRACKETCLOSE
SEMICOLON
// einfache Anwendung der obigen beiden Funktionen.
FUNC
INT
FINDKERNELDLLFUNCTION
PARENOPEN
VAR
STRING
NAME
PARENCLOSE
BRACKETOPEN
CONST
INT
KERNEL32DLL
ASSIGN
INTEGER(0)
SEMICOLON
IF
PARENOPEN
NOT
KERNEL32DLL
PARENCLOSE
BRACKETOPEN
KERNEL32DLL
ASSIGN
LOADLIBRARY
PARENOPEN
"KERNEL32.DLL"
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
RETURN
GETPROCADDRESS
PARENOPEN
KERNEL32DLL
COMMA
NAME
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// --------------------------------------
//    Schreibschutz umgehen
// --------------------------------------
CONST
INT
PAGE_EXECUTE
ASSIGN
INTEGER(16)
SEMICOLON
// 0x10
CONST
INT
PAGE_EXECUTE_READ
ASSIGN
INTEGER(32)
SEMICOLON
// 0x20
CONST
INT
PAGE_EXECUTE_READWRITE
ASSIGN
INTEGER(64)
SEMICOLON
// 0x40
CONST
INT
PAGE_EXECUTE_WRITECOPY
ASSIGN
INTEGER(128)
SEMICOLON
// 0x80
CONST
INT
PAGE_NOACCESS
ASSIGN
INTEGER(1)
SEMICOLON
// 0x01
CONST
INT
PAGE_READONLY
ASSIGN
INTEGER(2)
SEMICOLON
// 0x02
CONST
INT
PAGE_READWRITE
ASSIGN
INTEGER(4)
SEMICOLON
// 0x04
CONST
INT
PAGE_WRITECOPY
ASSIGN
INTEGER(8)
SEMICOLON
// 0x08
//  http://msdn.microsoft.com/en-us/library/aa366898%28VS.85%29.aspx 
//  Note: I made lpflOldProtectPtr the return value and ignored\n * the return Value of VirtualProtect 
FUNC
INT
VIRTUALPROTECT
PARENOPEN
VAR
INT
LPADDRESS
COMMA
VAR
INT
DWSIZE
COMMA
VAR
INT
FLNEWPROTECT
PARENCLOSE
BRACKETOPEN
CONST
INT
ADR
ASSIGN
INTEGER(0)
SEMICOLON
IF
PARENOPEN
NOT
ADR
PARENCLOSE
BRACKETOPEN
ADR
ASSIGN
FINDKERNELDLLFUNCTION
PARENOPEN
"VirtualProtect"
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
VAR
INT
LPFLOLDPROTECT
SEMICOLON
VAR
INT
LPFLOLDPROTECTPTR
SEMICOLON
LPFLOLDPROTECTPTR
ASSIGN
_@
PARENOPEN
LPFLOLDPROTECT
PARENCLOSE
SEMICOLON
CONST
INT
CALL
ASSIGN
INTEGER(0)
SEMICOLON
IF
PARENOPEN
CALL_BEGIN
PARENOPEN
CALL
PARENCLOSE
PARENCLOSE
BRACKETOPEN
CALL_PTRPARAM
PARENOPEN
_@
PARENOPEN
LPFLOLDPROTECTPTR
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL_INTPARAM
PARENOPEN
_@
PARENOPEN
FLNEWPROTECT
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL_INTPARAM
PARENOPEN
_@
PARENOPEN
DWSIZE
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL_PTRPARAM
PARENOPEN
_@
PARENOPEN
LPADDRESS
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL_PUTRETVALTO
PARENOPEN
INTEGER(0)
PARENCLOSE
SEMICOLON
CALL__STDCALL
PARENOPEN
ADR
PARENCLOSE
SEMICOLON
CALL
ASSIGN
CALL_END
PARENOPEN
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
RETURN
LPFLOLDPROTECT
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEMORYPROTECTIONOVERRIDE
PARENOPEN
VAR
INT
ADDRESS
COMMA
VAR
INT
SIZE
PARENCLOSE
BRACKETOPEN
VAR
INT
RESDUMP
SEMICOLON
RESDUMP
ASSIGN
VIRTUALPROTECT
PARENOPEN
ADDRESS
COMMA
SIZE
COMMA
PAGE_EXECUTE_READWRITE
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// --------------------------------------
//     Message Boxen
// --------------------------------------
CONST
INT
MB_OK
ASSIGN
INTEGER(0)
SEMICOLON
CONST
INT
MB_OKCANCEL
ASSIGN
INTEGER(1)
SEMICOLON
CONST
INT
MB_ABORTRETRYIGNORE
ASSIGN
INTEGER(2)
SEMICOLON
CONST
INT
MB_YESNOCANCEL
ASSIGN
INTEGER(3)
SEMICOLON
CONST
INT
MB_YESNO
ASSIGN
INTEGER(4)
SEMICOLON
CONST
INT
MB_RETRYCANCEL
ASSIGN
INTEGER(5)
SEMICOLON
CONST
INT
MB_CANCELTRYCONTINUE
ASSIGN
INTEGER(6)
SEMICOLON
CONST
INT
MB_ICONERROR
ASSIGN
INTEGER(16)
SEMICOLON
// 0x10
CONST
INT
MB_ICONQUESTION
ASSIGN
INTEGER(32)
SEMICOLON
// 0x20
CONST
INT
MB_ICONWARNING
ASSIGN
INTEGER(48)
SEMICOLON
// 0x30
CONST
INT
MB_ICONINFORMATION
ASSIGN
INTEGER(64)
SEMICOLON
// 0x40
// alias:
CONST
INT
MB_ICONEXCLAMATION
ASSIGN
MB_ICONWARNING
SEMICOLON
CONST
INT
MB_ICONASTERISK
ASSIGN
MB_ICONINFORMATION
SEMICOLON
CONST
INT
MB_ICONSTOP
ASSIGN
MB_ICONERROR
SEMICOLON
CONST
INT
MB_ICONHAND
ASSIGN
MB_ICONERROR
SEMICOLON
CONST
INT
MB_DEFBUTTON1
ASSIGN
INTEGER(0)
SEMICOLON
// 0x000
CONST
INT
MB_DEFBUTTON2
ASSIGN
INTEGER(256)
SEMICOLON
// 0x100
CONST
INT
MB_DEFBUTTON3
ASSIGN
INTEGER(512)
SEMICOLON
// 0x200
CONST
INT
MB_DEFBUTTON4
ASSIGN
INTEGER(768)
SEMICOLON
// 0x300
CONST
INT
IDOK
ASSIGN
INTEGER(1)
SEMICOLON
CONST
INT
IDCANCEL
ASSIGN
INTEGER(2)
SEMICOLON
CONST
INT
IDABORT
ASSIGN
INTEGER(3)
SEMICOLON
CONST
INT
IDRETRY
ASSIGN
INTEGER(4)
SEMICOLON
CONST
INT
IDIGNORE
ASSIGN
INTEGER(5)
SEMICOLON
CONST
INT
IDYES
ASSIGN
INTEGER(6)
SEMICOLON
CONST
INT
IDNO
ASSIGN
INTEGER(7)
SEMICOLON
CONST
INT
IDTRYAGAIN
ASSIGN
INTEGER(10)
SEMICOLON
CONST
INT
IDCONTINUE
ASSIGN
INTEGER(11)
SEMICOLON
FUNC
INT
MEM_MESSAGEBOX
PARENOPEN
VAR
STRING
TXT
COMMA
VAR
STRING
CAPTION
COMMA
VAR
INT
TYPE
PARENCLOSE
BRACKETOPEN
//  Hier liegt die Funktion 
CONST
INT
WINAPI__MESSAGEBOX_G2
ASSIGN
INTEGER(8079592)
SEMICOLON
// 0x7B48E8
CONST
INT
WINAPI__MESSAGEBOX_G1
ASSIGN
INTEGER(7713298)
SEMICOLON
// 0x75B212
CONST
INT
MB_TASKMODAL
ASSIGN
INTEGER(8192)
SEMICOLON
// 0x2000
//  Parameter in umgekehrter Reihenfolge 
CALL_INTPARAM
PARENOPEN
TYPE
BITOR
MB_TASKMODAL
PARENCLOSE
SEMICOLON
// soll in den Vordergrund
CALL_CSTRINGPTRPARAM
PARENOPEN
CAPTION
PARENCLOSE
SEMICOLON
CALL_CSTRINGPTRPARAM
PARENOPEN
TXT
PARENCLOSE
SEMICOLON
CALL_INTPARAM
PARENOPEN
INTEGER(0)
PARENCLOSE
SEMICOLON
CALL__STDCALL
PARENOPEN
MEMINT_SWITCHG1G2
PARENOPEN
WINAPI__MESSAGEBOX_G1
COMMA
WINAPI__MESSAGEBOX_G2
PARENCLOSE
PARENCLOSE
SEMICOLON
RETURN
CALL_RETVALASINT
PARENOPEN
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEM_INFOBOX
PARENOPEN
VAR
STRING
TXT
PARENCLOSE
BRACKETOPEN
VAR
INT
RES
SEMICOLON
RES
ASSIGN
MEM_MESSAGEBOX
PARENOPEN
TXT
COMMA
"Information:"
COMMA
MB_OK
BITOR
MB_ICONINFORMATION
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// #################################################################
// 
//   Arrays
// 
// #################################################################
// ************************************************
//  Alloc / Clear / Free / Size / Read / Write
// ************************************************
FUNC
INT
MEM_ARRAYCREATE
PARENOPEN
PARENCLOSE
BRACKETOPEN
RETURN
MEM_ALLOC
PARENOPEN
SIZEOF_ZCARRAY
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEM_ARRAYFREE
PARENOPEN
VAR
INT
ZCARRAY_PTR
PARENCLOSE
BRACKETOPEN
VAR
INT
ARRAY
SEMICOLON
ARRAY
ASSIGN
MEM_READINT
PARENOPEN
ZCARRAY_PTR
PARENCLOSE
SEMICOLON
IF
PARENOPEN
ARRAY
PARENCLOSE
BRACKETOPEN
MEM_FREE
PARENOPEN
ARRAY
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
MEM_FREE
PARENOPEN
ZCARRAY_PTR
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEM_ARRAYCLEAR
PARENOPEN
VAR
INT
ZCARRAY_PTR
PARENCLOSE
BRACKETOPEN
VAR
ZCARRAY
ARRAY
SEMICOLON
ARRAY
ASSIGN
_^
PARENOPEN
ZCARRAY_PTR
PARENCLOSE
SEMICOLON
IF
PARENOPEN
ARRAY
PERIOD
ARRAY
PARENCLOSE
BRACKETOPEN
MEM_FREE
PARENOPEN
ARRAY
PERIOD
ARRAY
PARENCLOSE
SEMICOLON
ARRAY
PERIOD
ARRAY
ASSIGN
INTEGER(0)
SEMICOLON
BRACKETCLOSE
SEMICOLON
ARRAY
PERIOD
NUMALLOC
ASSIGN
INTEGER(0)
SEMICOLON
ARRAY
PERIOD
NUMINARRAY
ASSIGN
INTEGER(0)
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
MEM_ARRAYSIZE
PARENOPEN
VAR
INT
ZCARRAY_PTR
PARENCLOSE
BRACKETOPEN
RETURN
MEM_READINT
PARENOPEN
ZCARRAY_PTR
PLUS
INTEGER(8)
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEM_ARRAYWRITE
PARENOPEN
VAR
INT
ZCARRAY_PTR
COMMA
VAR
INT
POS
COMMA
VAR
INT
VALUE
PARENCLOSE
BRACKETOPEN
VAR
ZCARRAY
ARRAY
SEMICOLON
ARRAY
ASSIGN
_^
PARENOPEN
ZCARRAY_PTR
PARENCLOSE
SEMICOLON
IF
PARENOPEN
POS
LOWER
INTEGER(0)
OR
ARRAY
PERIOD
NUMINARRAY
LOWEREQUALS
POS
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
CONCATSTRINGS
PARENOPEN
"MEM_ArrayWrite: pos out of bounds: "
COMMA
INTTOSTRING
PARENOPEN
POS
PARENCLOSE
PARENCLOSE
PARENCLOSE
SEMICOLON
RETURN
SEMICOLON
BRACKETCLOSE
SEMICOLON
MEM_WRITEINTARRAY
PARENOPEN
ARRAY
PERIOD
ARRAY
COMMA
POS
COMMA
VALUE
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
MEM_ARRAYREAD
PARENOPEN
VAR
INT
ZCARRAY_PTR
COMMA
VAR
INT
POS
PARENCLOSE
BRACKETOPEN
VAR
ZCARRAY
ARRAY
SEMICOLON
ARRAY
ASSIGN
_^
PARENOPEN
ZCARRAY_PTR
PARENCLOSE
SEMICOLON
IF
PARENOPEN
POS
LOWER
INTEGER(0)
OR
ARRAY
PERIOD
NUMINARRAY
LOWEREQUALS
POS
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
CONCATSTRINGS
PARENOPEN
"MEM_ArrayRead: pos out of bounds: "
COMMA
INTTOSTRING
PARENOPEN
POS
PARENCLOSE
PARENCLOSE
PARENCLOSE
SEMICOLON
RETURN
INTEGER(0)
SEMICOLON
BRACKETCLOSE
SEMICOLON
RETURN
MEM_READINTARRAY
PARENOPEN
ARRAY
PERIOD
ARRAY
COMMA
POS
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// ************************************************
//  Insert / Push / Pop / Top
// ************************************************
FUNC
VOID
MEM_ARRAYINSERT
PARENOPEN
VAR
INT
ZCARRAY_PTR
COMMA
VAR
INT
VALUE
PARENCLOSE
BRACKETOPEN
VAR
ZCARRAY
ARRAY
SEMICOLON
ARRAY
ASSIGN
_^
PARENOPEN
ZCARRAY_PTR
PARENCLOSE
SEMICOLON
IF
PARENOPEN
NOT
ARRAY
PERIOD
ARRAY
PARENCLOSE
BRACKETOPEN
// Noch gar kein Array angelegt. Erstmals anlegen
ARRAY
PERIOD
NUMALLOC
ASSIGN
INTEGER(16)
SEMICOLON
// Startwert
ARRAY
PERIOD
ARRAY
ASSIGN
MEM_ALLOC
PARENOPEN
ARRAY
PERIOD
NUMALLOC
MULTIPLY
INTEGER(4)
PARENCLOSE
SEMICOLON
BRACKETCLOSE
ELSE
IF
PARENOPEN
ARRAY
PERIOD
NUMINARRAY
GREATEREQUALS
ARRAY
PERIOD
NUMALLOC
PARENCLOSE
BRACKETOPEN
// kein Platz mehr
// nehmen wir mal das doppelte (oder ist das zu gierig? sollte passen):
ARRAY
PERIOD
NUMALLOC
ASSIGN
INTEGER(2)
MULTIPLY
ARRAY
PERIOD
NUMALLOC
SEMICOLON
ARRAY
PERIOD
ARRAY
ASSIGN
MEM_REALLOC
PARENOPEN
ARRAY
PERIOD
ARRAY
COMMA
ARRAY
PERIOD
NUMINARRAY
MULTIPLY
INTEGER(4)
COMMA
ARRAY
PERIOD
NUMALLOC
MULTIPLY
INTEGER(4)
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// Jetzt muss Platz sein:
MEM_WRITEINTARRAY
PARENOPEN
ARRAY
PERIOD
ARRAY
COMMA
ARRAY
PERIOD
NUMINARRAY
COMMA
VALUE
PARENCLOSE
SEMICOLON
ARRAY
PERIOD
NUMINARRAY
PLUSASSIGN
INTEGER(1)
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEM_ARRAYPUSH
PARENOPEN
VAR
INT
ZCARRAY_PTR
COMMA
VAR
INT
VALUE
PARENCLOSE
BRACKETOPEN
MEM_ARRAYINSERT
PARENOPEN
ZCARRAY_PTR
COMMA
VALUE
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
MEM_ARRAYPOP
PARENOPEN
VAR
INT
ZCARRAY_PTR
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
NOT
ZCARRAY_PTR
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"MEM_ArrayPop: Invalid address: zCArray_ptr may not be null!"
PARENCLOSE
SEMICOLON
RETURN
INTEGER(0)
SEMICOLON
BRACKETCLOSE
SEMICOLON
VAR
ZCARRAY
ARRAY
SEMICOLON
ARRAY
ASSIGN
_^
PARENOPEN
ZCARRAY_PTR
PARENCLOSE
SEMICOLON
IF
PARENOPEN
NOT
ARRAY
PERIOD
NUMINARRAY
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"MEM_ArrayPop: Underflow! Cannot pop from empty array."
PARENCLOSE
SEMICOLON
RETURN
INTEGER(0)
SEMICOLON
BRACKETCLOSE
SEMICOLON
ARRAY
PERIOD
NUMINARRAY
MINUSASSIGN
INTEGER(1)
SEMICOLON
RETURN
MEM_READINTARRAY
PARENOPEN
ARRAY
PERIOD
ARRAY
COMMA
ARRAY
PERIOD
NUMINARRAY
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
MEM_ARRAYTOP
PARENOPEN
VAR
INT
ZCARRAY_PTR
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
NOT
ZCARRAY_PTR
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"MEM_ArrayTop: Invalid address: zCArray_ptr may not be null!"
PARENCLOSE
SEMICOLON
RETURN
INTEGER(0)
SEMICOLON
BRACKETCLOSE
SEMICOLON
VAR
ZCARRAY
ARRAY
SEMICOLON
ARRAY
ASSIGN
_^
PARENOPEN
ZCARRAY_PTR
PARENCLOSE
SEMICOLON
IF
PARENOPEN
NOT
ARRAY
PERIOD
NUMINARRAY
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"MEM_ArrayTop: Underflow! Cannot pop from empty array."
PARENCLOSE
SEMICOLON
RETURN
INTEGER(0)
SEMICOLON
BRACKETCLOSE
SEMICOLON
RETURN
MEM_READINTARRAY
PARENOPEN
ARRAY
PERIOD
ARRAY
COMMA
ARRAY
PERIOD
NUMINARRAY
MINUS
INTEGER(1)
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// ************************************************
//    IndexOf / RemoveIndex / RemoveValue[Once]
// ************************************************
FUNC
INT
MEM_ARRAYINDEXOF
PARENOPEN
VAR
INT
ZCARRAY_PTR
COMMA
VAR
INT
VALUE
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
NOT
ZCARRAY_PTR
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"MEM_ArrayIndexOf: Invalid address: zCArray_ptr may not be null!"
PARENCLOSE
SEMICOLON
RETURN
MINUS
INTEGER(1)
SEMICOLON
BRACKETCLOSE
SEMICOLON
VAR
ZCARRAY
ARRAY
SEMICOLON
ARRAY
ASSIGN
_^
PARENOPEN
ZCARRAY_PTR
PARENCLOSE
SEMICOLON
VAR
INT
I
SEMICOLON
I
ASSIGN
INTEGER(0)
SEMICOLON
VAR
INT
LOOP
SEMICOLON
LOOP
ASSIGN
MEM_STACKPOS
PERIOD
POSITION
SEMICOLON
IF
PARENOPEN
I
LOWER
ARRAY
PERIOD
NUMINARRAY
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
MEM_READINTARRAY
PARENOPEN
ARRAY
PERIOD
ARRAY
COMMA
I
PARENCLOSE
EQUALS
VALUE
PARENCLOSE
BRACKETOPEN
RETURN
I
SEMICOLON
BRACKETCLOSE
SEMICOLON
I
PLUSASSIGN
INTEGER(1)
SEMICOLON
MEM_STACKPOS
PERIOD
POSITION
ASSIGN
LOOP
SEMICOLON
BRACKETCLOSE
SEMICOLON
RETURN
MINUS
INTEGER(1)
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEM_ARRAYREMOVEINDEX
PARENOPEN
VAR
INT
ZCARRAY_PTR
COMMA
VAR
INT
INDEX
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
NOT
ZCARRAY_PTR
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"MEM_ArrayRemoveIndex: Invalid address: zCArray_ptr may not be null!"
PARENCLOSE
SEMICOLON
RETURN
SEMICOLON
BRACKETCLOSE
SEMICOLON
VAR
ZCARRAY
ARRAY
SEMICOLON
ARRAY
ASSIGN
_^
PARENOPEN
ZCARRAY_PTR
PARENCLOSE
SEMICOLON
IF
PARENOPEN
ARRAY
PERIOD
NUMINARRAY
LOWEREQUALS
INDEX
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"MEM_ArrayRemoveIndex: index lies beyond the end of the array!"
PARENCLOSE
SEMICOLON
RETURN
SEMICOLON
BRACKETCLOSE
SEMICOLON
// letzten Wert in die Lücke schieben
ARRAY
PERIOD
NUMINARRAY
MINUSASSIGN
INTEGER(1)
SEMICOLON
MEM_WRITEINTARRAY
PARENOPEN
ARRAY
PERIOD
ARRAY
COMMA
INDEX
COMMA
MEM_READINTARRAY
PARENOPEN
ARRAY
PERIOD
ARRAY
COMMA
ARRAY
PERIOD
NUMINARRAY
PARENCLOSE
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
VAR
INT
MEMINT_ARRAYREMOVEVALUE_ONLYONCE
SEMICOLON
FUNC
VOID
MEM_ARRAYREMOVEVALUE
PARENOPEN
VAR
INT
ZCARRAY_PTR
COMMA
VAR
INT
VALUE
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
NOT
ZCARRAY_PTR
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"MEM_ArrayRemoveValue: Invalid address: zCArray_ptr may not be null!"
PARENCLOSE
SEMICOLON
RETURN
SEMICOLON
BRACKETCLOSE
SEMICOLON
VAR
ZCARRAY
ARRAY
SEMICOLON
ARRAY
ASSIGN
_^
PARENOPEN
ZCARRAY_PTR
PARENCLOSE
SEMICOLON
VAR
INT
I
SEMICOLON
I
ASSIGN
INTEGER(0)
SEMICOLON
VAR
INT
LOOP
SEMICOLON
LOOP
ASSIGN
MEM_STACKPOS
PERIOD
POSITION
SEMICOLON
// schon durchgelaufen?
//  while 
IF
PARENOPEN
I
LOWER
ARRAY
PERIOD
NUMINARRAY
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
MEM_READINTARRAY
PARENOPEN
ARRAY
PERIOD
ARRAY
COMMA
I
PARENCLOSE
EQUALS
VALUE
PARENCLOSE
BRACKETOPEN
// dann element entfernen
ARRAY
PERIOD
NUMINARRAY
MINUSASSIGN
INTEGER(1)
SEMICOLON
MEM_WRITEINTARRAY
PARENOPEN
ARRAY
PERIOD
ARRAY
COMMA
I
COMMA
MEM_READINTARRAY
PARENOPEN
ARRAY
PERIOD
ARRAY
COMMA
ARRAY
PERIOD
NUMINARRAY
PARENCLOSE
PARENCLOSE
SEMICOLON
// weitersuchen?
IF
PARENOPEN
MEMINT_ARRAYREMOVEVALUE_ONLYONCE
PARENCLOSE
BRACKETOPEN
MEMINT_ARRAYREMOVEVALUE_ONLYONCE
ASSIGN
INTEGER(2)
SEMICOLON
// geschafft
RETURN
SEMICOLON
BRACKETCLOSE
SEMICOLON
BRACKETCLOSE
ELSE
BRACKETOPEN
I
PLUSASSIGN
INTEGER(1)
SEMICOLON
BRACKETCLOSE
SEMICOLON
MEM_STACKPOS
PERIOD
POSITION
ASSIGN
LOOP
SEMICOLON
BRACKETCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEM_ARRAYREMOVEVALUEONCE
PARENOPEN
VAR
INT
ZCARRAY_PTR
COMMA
VAR
INT
VALUE
PARENCLOSE
BRACKETOPEN
MEMINT_ARRAYREMOVEVALUE_ONLYONCE
ASSIGN
TRUE
SEMICOLON
MEM_ARRAYREMOVEVALUE
PARENOPEN
ZCARRAY_PTR
COMMA
VALUE
PARENCLOSE
SEMICOLON
IF
PARENOPEN
MEMINT_ARRAYREMOVEVALUE_ONLYONCE
NOTEQUALS
INTEGER(2)
PARENCLOSE
BRACKETOPEN
MEM_WARN
PARENOPEN
CONCATSTRINGS
PARENOPEN
"MEM_ArrayRemoveValueOnce: Could not find value: "
COMMA
INTTOSTRING
PARENOPEN
VALUE
PARENCLOSE
PARENCLOSE
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
MEMINT_ARRAYREMOVEVALUE_ONLYONCE
ASSIGN
FALSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// ************************************************
//     Sort / Unique
// ************************************************
FUNC
VOID
MEMINT_QSORT
PARENOPEN
VAR
INT
BASE
COMMA
VAR
INT
NUM
COMMA
VAR
INT
SIZE
COMMA
VAR
INT
COMPARATOR
PARENCLOSE
BRACKETOPEN
CONST
INT
QSORT_G1
ASSIGN
INTEGER(7828863)
SEMICOLON
// 0x77757F
CONST
INT
QSORT_G2
ASSIGN
INTEGER(8195951)
SEMICOLON
// 0x7D0F6F
CONST
INT
COMPARE_G1
ASSIGN
INTEGER(5502288)
SEMICOLON
// 0x53F550
CONST
INT
COMPARE_G2
ASSIGN
INTEGER(5586080)
SEMICOLON
// 0x553CA0
IF
PARENOPEN
COMPARATOR
EQUALS
INTEGER(0)
PARENCLOSE
BRACKETOPEN
COMPARATOR
ASSIGN
MEMINT_SWITCHG1G2
PARENOPEN
COMPARE_G1
COMMA
COMPARE_G2
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
VAR
INT
QSORT
SEMICOLON
QSORT
ASSIGN
MEMINT_SWITCHG1G2
PARENOPEN
QSORT_G1
COMMA
QSORT_G2
PARENCLOSE
SEMICOLON
CONST
INT
CALL
ASSIGN
INTEGER(0)
SEMICOLON
IF
PARENOPEN
CALL_BEGIN
PARENOPEN
CALL
PARENCLOSE
PARENCLOSE
BRACKETOPEN
CALL_PTRPARAM
PARENOPEN
_@
PARENOPEN
COMPARATOR
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL_INTPARAM
PARENOPEN
_@
PARENOPEN
SIZE
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL_INTPARAM
PARENOPEN
_@
PARENOPEN
NUM
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL_PTRPARAM
PARENOPEN
_@
PARENOPEN
BASE
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL_PUTRETVALTO
PARENOPEN
INTEGER(0)
PARENCLOSE
SEMICOLON
CALL__CDECL
PARENOPEN
QSORT
PARENCLOSE
SEMICOLON
CALL
ASSIGN
CALL_END
PARENOPEN
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEM_ARRAYSORT
PARENOPEN
VAR
INT
ZCARRAY_PTR
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
NOT
ZCARRAY_PTR
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"MEM_ArraySort: Invalid address: zCArray_ptr may not be null!"
PARENCLOSE
SEMICOLON
RETURN
SEMICOLON
BRACKETCLOSE
SEMICOLON
VAR
ZCARRAY
ARRAY
SEMICOLON
ARRAY
ASSIGN
_^
PARENOPEN
ZCARRAY_PTR
PARENCLOSE
SEMICOLON
MEMINT_QSORT
PARENOPEN
ARRAY
PERIOD
ARRAY
COMMA
ARRAY
PERIOD
NUMINARRAY
COMMA
INTEGER(4)
COMMA
INTEGER(0)
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEM_ARRAYUNIQUE
PARENOPEN
VAR
INT
ZCARRAY_PTR
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
NOT
ZCARRAY_PTR
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"MEM_ArrayUnique: Invalid address: zCArray_ptr may not be null!"
PARENCLOSE
SEMICOLON
RETURN
SEMICOLON
BRACKETCLOSE
SEMICOLON
VAR
ZCARRAY
ARRAY
SEMICOLON
ARRAY
ASSIGN
_^
PARENOPEN
ZCARRAY_PTR
PARENCLOSE
SEMICOLON
VAR
INT
READER
SEMICOLON
VAR
INT
WRITER
SEMICOLON
VAR
INT
OLDVAL
SEMICOLON
VAR
INT
NEWVAL
SEMICOLON
READER
ASSIGN
INTEGER(0)
SEMICOLON
WRITER
ASSIGN
INTEGER(0)
SEMICOLON
VAR
INT
LOOP
SEMICOLON
LOOP
ASSIGN
MEM_STACKPOS
PERIOD
POSITION
SEMICOLON
IF
PARENOPEN
READER
LOWER
ARRAY
PERIOD
NUMINARRAY
PARENCLOSE
BRACKETOPEN
NEWVAL
ASSIGN
MEM_READINTARRAY
PARENOPEN
ARRAY
PERIOD
ARRAY
COMMA
READER
PARENCLOSE
SEMICOLON
IF
PARENOPEN
NOT
READER
OR
NEWVAL
NOTEQUALS
OLDVAL
PARENCLOSE
BRACKETOPEN
MEM_WRITEINTARRAY
PARENOPEN
ARRAY
PERIOD
ARRAY
COMMA
WRITER
COMMA
NEWVAL
PARENCLOSE
SEMICOLON
WRITER
PLUSASSIGN
INTEGER(1)
SEMICOLON
OLDVAL
ASSIGN
NEWVAL
SEMICOLON
BRACKETCLOSE
SEMICOLON
READER
PLUSASSIGN
INTEGER(1)
SEMICOLON
MEM_STACKPOS
PERIOD
POSITION
ASSIGN
LOOP
SEMICOLON
BRACKETCLOSE
SEMICOLON
ARRAY
PERIOD
NUMINARRAY
ASSIGN
WRITER
SEMICOLON
BRACKETCLOSE
SEMICOLON
// ************************************************
//     ToString
// ************************************************
FUNC
STRING
MEM_ARRAYTOSTRING
PARENOPEN
VAR
INT
ZCARRAY_PTR
PARENCLOSE
BRACKETOPEN
VAR
STRING
RES
SEMICOLON
RES
ASSIGN
""
SEMICOLON
IF
PARENOPEN
NOT
ZCARRAY_PTR
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"MEM_ArrayRemoveValue: Invalid address: zCArray_ptr may not be null!"
PARENCLOSE
SEMICOLON
RETURN
""
SEMICOLON
BRACKETCLOSE
SEMICOLON
VAR
ZCARRAY
ARRAY
SEMICOLON
ARRAY
ASSIGN
_^
PARENOPEN
ZCARRAY_PTR
PARENCLOSE
SEMICOLON
VAR
INT
I
SEMICOLON
I
ASSIGN
INTEGER(0)
SEMICOLON
VAR
INT
LOOP
SEMICOLON
LOOP
ASSIGN
MEM_STACKPOS
PERIOD
POSITION
SEMICOLON
//  while 
IF
PARENOPEN
I
LOWER
ARRAY
PERIOD
NUMINARRAY
PARENCLOSE
BRACKETOPEN
RES
ASSIGN
CONCATSTRINGS
PARENOPEN
RES
COMMA
INTTOSTRING
PARENOPEN
MEM_READINTARRAY
PARENOPEN
ARRAY
PERIOD
ARRAY
COMMA
I
PARENCLOSE
PARENCLOSE
PARENCLOSE
SEMICOLON
IF
PARENOPEN
I
LOWER
ARRAY
PERIOD
NUMINARRAY
MINUS
INTEGER(1)
PARENCLOSE
BRACKETOPEN
RES
ASSIGN
CONCATSTRINGS
PARENOPEN
RES
COMMA
","
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
I
PLUSASSIGN
INTEGER(1)
SEMICOLON
MEM_STACKPOS
PERIOD
POSITION
ASSIGN
LOOP
SEMICOLON
BRACKETCLOSE
SEMICOLON
RETURN
RES
SEMICOLON
BRACKETCLOSE
SEMICOLON
// ######################################################
// 
//   String Tools
// 
// ######################################################
// --------------------------------------
//  Zugriff auf einzelnes Zeichen
// --------------------------------------
FUNC
INT
STR_GETCHARAT
PARENOPEN
VAR
STRING
STR
COMMA
VAR
INT
POS
PARENCLOSE
BRACKETOPEN
VAR
ZSTRING
ZSTR
SEMICOLON
ZSTR
ASSIGN
_^
PARENOPEN
_@S
PARENOPEN
STR
PARENCLOSE
PARENCLOSE
SEMICOLON
IF
PARENOPEN
POS
LOWER
INTEGER(0)
PARENCLOSE
OR
PARENOPEN
POS
GREATEREQUALS
ZSTR
PERIOD
LEN
PARENCLOSE
BRACKETOPEN
MEM_WARN
PARENOPEN
"STR_GetCharAt: Reading out of bounds! returning 0."
PARENCLOSE
SEMICOLON
RETURN
INTEGER(0)
SEMICOLON
BRACKETCLOSE
SEMICOLON
RETURN
MEM_READBYTE
PARENOPEN
ZSTR
PERIOD
PTR
PLUS
POS
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// --------------------------------------
//  Länge eines Strings
// --------------------------------------
FUNC
INT
STR_LEN
PARENOPEN
VAR
STRING
STR
PARENCLOSE
BRACKETOPEN
VAR
ZSTRING
ZSTR
SEMICOLON
ZSTR
ASSIGN
_^
PARENOPEN
_@S
PARENOPEN
STR
PARENCLOSE
PARENCLOSE
SEMICOLON
RETURN
PLUS
ZSTR
PERIOD
LEN
SEMICOLON
BRACKETCLOSE
SEMICOLON
// --------------------------------------
//  To and from char*
// --------------------------------------
//   Be aware that strings may share their buffers!\n    var string s1; var string s2;\n    s1 = "Hello"; s2 = s1;\n    \n    Now only one copy of "Hello" exists in memory!\n    This is implemented by reference counting\n    in ptr-1.\n 
FUNC
INT
STR_TOCHAR
PARENOPEN
VAR
STRING
STR
PARENCLOSE
BRACKETOPEN
VAR
ZSTRING
ZSTR
SEMICOLON
ZSTR
ASSIGN
_^
PARENOPEN
_@S
PARENOPEN
STR
PARENCLOSE
PARENCLOSE
SEMICOLON
RETURN
PLUS
ZSTR
PERIOD
PTR
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
STRINT_TOCHAR
PARENOPEN
VAR
STRING
STR
PARENCLOSE
BRACKETOPEN
RETURN
STR_TOCHAR
PARENOPEN
STR
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
STRING
STR_FROMCHAR
PARENOPEN
VAR
INT
CHAR
PARENCLOSE
BRACKETOPEN
VAR
STRING
STR
SEMICOLON
STR
ASSIGN
""
SEMICOLON
VAR
INT
PTR
SEMICOLON
PTR
ASSIGN
_@S
PARENOPEN
STR
PARENCLOSE
SEMICOLON
CONST
INT
CALL
ASSIGN
INTEGER(0)
SEMICOLON
IF
PARENOPEN
CALL_BEGIN
PARENOPEN
CALL
PARENCLOSE
PARENCLOSE
BRACKETOPEN
CALL_PTRPARAM
PARENOPEN
_@
PARENOPEN
CHAR
PARENCLOSE
PARENCLOSE
SEMICOLON
//  zString::zString(const char*) 
CALL__THISCALL
PARENOPEN
_@
PARENOPEN
PTR
PARENCLOSE
COMMA
MEMINT_SWITCHG1G2
PARENOPEN
INTEGER(4199328)
//  0x4013A0 
COMMA
INTEGER(4198592)
//  0x4010C0 
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL
ASSIGN
CALL_END
PARENOPEN
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
RETURN
STR
SEMICOLON
BRACKETCLOSE
SEMICOLON
// ************************************************
//  Substring / Prefix
// ************************************************
FUNC
STRING
STR_SUBSTR
PARENOPEN
VAR
STRING
STR
COMMA
VAR
INT
START
COMMA
VAR
INT
COUNT
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
START
LOWER
INTEGER(0)
PARENCLOSE
OR
PARENOPEN
COUNT
LOWER
INTEGER(0)
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"STR_SubStr: start and count may not be negative."
PARENCLOSE
SEMICOLON
RETURN
""
SEMICOLON
BRACKETCLOSE
SEMICOLON
//  Hole Adressen von zwei Strings, Source und Destination (für Kopieroperation) 
VAR
ZSTRING
ZSTRSRC
SEMICOLON
VAR
ZSTRING
ZSTRDST
SEMICOLON
VAR
STRING
DSTSTR
SEMICOLON
DSTSTR
ASSIGN
""
SEMICOLON
ZSTRSRC
ASSIGN
_^
PARENOPEN
_@S
PARENOPEN
STR
PARENCLOSE
PARENCLOSE
SEMICOLON
ZSTRDST
ASSIGN
_^
PARENOPEN
_@S
PARENOPEN
DSTSTR
PARENCLOSE
PARENCLOSE
SEMICOLON
IF
PARENOPEN
ZSTRSRC
PERIOD
LEN
LOWER
START
PLUS
COUNT
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
ZSTRSRC
PERIOD
LEN
LOWER
START
PARENCLOSE
BRACKETOPEN
MEM_WARN
PARENOPEN
"STR_SubStr: The desired start of the substring lies beyond the end of the string."
PARENCLOSE
SEMICOLON
RETURN
""
SEMICOLON
BRACKETCLOSE
ELSE
BRACKETOPEN
//  The start is in valid bounds. The End is shitty. 
//  Careful! MEM_Warn will use STR_SubStr (but will never use it in a way that would produce a warning) 
VAR
STRING
SAVESTR
SEMICOLON
VAR
INT
SAVESTART
SEMICOLON
VAR
INT
SAVECOUNT
SEMICOLON
SAVESTR
ASSIGN
STR
SEMICOLON
SAVESTART
ASSIGN
START
SEMICOLON
SAVECOUNT
ASSIGN
COUNT
SEMICOLON
MEM_WARN
PARENOPEN
"STR_SubStr: The end of the desired substring exceeds the end of the string."
PARENCLOSE
SEMICOLON
STR
ASSIGN
SAVESTR
SEMICOLON
START
ASSIGN
SAVESTART
SEMICOLON
COUNT
ASSIGN
SAVECOUNT
SEMICOLON
COUNT
ASSIGN
ZSTRSRC
PERIOD
LEN
MINUS
START
SEMICOLON
BRACKETCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
ZSTRDST
PERIOD
PTR
ASSIGN
MEM_ALLOC
PARENOPEN
COUNT
PLUS
INTEGER(2)
PARENCLOSE
PLUS
INTEGER(1)
SEMICOLON
//  +1 for reference counter byte, +1 for null byte 
ZSTRDST
PERIOD
RES
ASSIGN
COUNT
SEMICOLON
MEM_COPYBYTES
PARENOPEN
ZSTRSRC
PERIOD
PTR
PLUS
START
COMMA
ZSTRDST
PERIOD
PTR
COMMA
COUNT
PARENCLOSE
SEMICOLON
ZSTRDST
PERIOD
LEN
ASSIGN
COUNT
SEMICOLON
RETURN
DSTSTR
SEMICOLON
BRACKETCLOSE
SEMICOLON
// Von früher:
FUNC
STRING
STR_PREFIX
PARENOPEN
VAR
STRING
STR
COMMA
VAR
INT
LEN
PARENCLOSE
BRACKETOPEN
RETURN
STR_SUBSTR
PARENOPEN
STR
COMMA
INTEGER(0)
COMMA
LEN
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// ************************************************
//  Compare Strings
// ************************************************
CONST
INT
STR_GREATER
ASSIGN
INTEGER(1)
SEMICOLON
CONST
INT
STR_EQUAL
ASSIGN
INTEGER(0)
SEMICOLON
CONST
INT
STR_SMALLER
ASSIGN
MINUS
INTEGER(1)
SEMICOLON
FUNC
INT
STR_COMPARE
PARENOPEN
VAR
STRING
STR1
COMMA
VAR
STRING
STR2
PARENCLOSE
BRACKETOPEN
CONST
INT
STRNCMP_G1
ASSIGN
INTEGER(7887344)
SEMICOLON
// 0x7859F0
CONST
INT
STRNCMP_G2
ASSIGN
INTEGER(8254144)
SEMICOLON
// 0x7DF2C0
VAR
INT
PTR1
SEMICOLON
PTR1
ASSIGN
_@S
PARENOPEN
STR1
PARENCLOSE
SEMICOLON
VAR
INT
PTR2
SEMICOLON
PTR2
ASSIGN
_@S
PARENOPEN
STR2
PARENCLOSE
SEMICOLON
VAR
INT
LEN1
SEMICOLON
LEN1
ASSIGN
MEM_READINT
PARENOPEN
PTR1
PLUS
INTEGER(12)
PARENCLOSE
SEMICOLON
VAR
INT
LEN2
SEMICOLON
LEN2
ASSIGN
MEM_READINT
PARENOPEN
PTR2
PLUS
INTEGER(12)
PARENCLOSE
SEMICOLON
VAR
INT
N
SEMICOLON
IF
PARENOPEN
LEN1
GREATER
LEN2
PARENCLOSE
BRACKETOPEN
N
ASSIGN
LEN2
SEMICOLON
BRACKETCLOSE
ELSE
BRACKETOPEN
N
ASSIGN
LEN1
SEMICOLON
BRACKETCLOSE
SEMICOLON
//  access zString.ptr 
PTR1
ASSIGN
MEM_READINT
PARENOPEN
PTR1
PLUS
INTEGER(8)
PARENCLOSE
SEMICOLON
PTR2
ASSIGN
MEM_READINT
PARENOPEN
PTR2
PLUS
INTEGER(8)
PARENCLOSE
SEMICOLON
IF
PARENOPEN
NOT
PTR1
AND
NOT
PTR2
PARENCLOSE
BRACKETOPEN
RETURN
STR_EQUAL
SEMICOLON
BRACKETCLOSE
ELSE
IF
PARENOPEN
NOT
PTR1
PARENCLOSE
BRACKETOPEN
RETURN
STR_SMALLER
SEMICOLON
BRACKETCLOSE
ELSE
IF
PARENOPEN
NOT
PTR2
PARENCLOSE
BRACKETOPEN
RETURN
STR_GREATER
SEMICOLON
BRACKETCLOSE
SEMICOLON
CONST
INT
CALL
ASSIGN
INTEGER(0)
SEMICOLON
IF
PARENOPEN
CALL_BEGIN
PARENOPEN
CALL
PARENCLOSE
PARENCLOSE
BRACKETOPEN
CALL_INTPARAM
PARENOPEN
_@
PARENOPEN
N
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL_PTRPARAM
PARENOPEN
_@
PARENOPEN
PTR2
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL_PTRPARAM
PARENOPEN
_@
PARENOPEN
PTR1
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL_PUTRETVALTO
PARENOPEN
_@
PARENOPEN
RET
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL__CDECL
PARENOPEN
MEMINT_SWITCHG1G2
PARENOPEN
STRNCMP_G1
COMMA
STRNCMP_G2
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL
ASSIGN
CALL_END
PARENOPEN
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
//  Gothic's implementation returns -1, 0 or 1 
VAR
INT
RET
SEMICOLON
IF
PARENOPEN
RET
EQUALS
INTEGER(0)
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
LEN1
GREATER
LEN2
PARENCLOSE
BRACKETOPEN
RETURN
STR_GREATER
SEMICOLON
BRACKETCLOSE
ELSE
IF
PARENOPEN
LEN1
LOWER
LEN2
PARENCLOSE
BRACKETOPEN
RETURN
STR_SMALLER
SEMICOLON
BRACKETCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
RETURN
PLUS
RET
SEMICOLON
BRACKETCLOSE
SEMICOLON
// ************************************************
//  STR_ToInt
// ************************************************
//  somewhat different from atol, therefore I will leave it as it is 
FUNC
INT
STR_TOINT
PARENOPEN
VAR
STRING
STR
PARENCLOSE
BRACKETOPEN
VAR
INT
LEN
SEMICOLON
LEN
ASSIGN
STR_LEN
PARENOPEN
STR
PARENCLOSE
SEMICOLON
VAR
INT
BUF
SEMICOLON
VAR
INT
INDEX
SEMICOLON
BUF
ASSIGN
STR_TOCHAR
PARENOPEN
STR
PARENCLOSE
SEMICOLON
INDEX
ASSIGN
INTEGER(0)
SEMICOLON
VAR
INT
RES
SEMICOLON
RES
ASSIGN
INTEGER(0)
SEMICOLON
VAR
INT
MINUS
SEMICOLON
MINUS
ASSIGN
FALSE
SEMICOLON
VAR
INT
LOOPSTART
SEMICOLON
LOOPSTART
ASSIGN
MEM_STACKPOS
PERIOD
POSITION
SEMICOLON
//  while 
IF
PARENOPEN
INDEX
LOWER
LEN
PARENCLOSE
BRACKETOPEN
VAR
INT
CHR
SEMICOLON
CHR
ASSIGN
MEM_READINT
PARENOPEN
BUF
PLUS
INDEX
PARENCLOSE
BITAND
INTEGER(255)
SEMICOLON
IF
PARENOPEN
CHR
GREATEREQUALS
INTEGER(48)
//  0 
PARENCLOSE
AND
PARENOPEN
CHR
LOWEREQUALS
INTEGER(57)
//  9 
PARENCLOSE
BRACKETOPEN
RES
ASSIGN
RES
MULTIPLY
INTEGER(10)
PLUS
PARENOPEN
CHR
MINUS
INTEGER(48)
PARENCLOSE
SEMICOLON
BRACKETCLOSE
ELSE
IF
PARENOPEN
INDEX
EQUALS
INTEGER(0)
PARENCLOSE
BRACKETOPEN
// am Anfang sind Vorzeichen erlaubt
IF
PARENOPEN
CHR
EQUALS
INTEGER(43)
// +
PARENCLOSE
BRACKETOPEN
//  ignore 
BRACKETCLOSE
ELSE
IF
PARENOPEN
CHR
EQUALS
INTEGER(45)
// -
PARENCLOSE
BRACKETOPEN
MINUS
ASSIGN
TRUE
SEMICOLON
BRACKETCLOSE
ELSE
BRACKETOPEN
MEM_WARN
PARENOPEN
CONCATSTRINGS
PARENOPEN
"STR_ToInt: cannot convert string: "
COMMA
STR
PARENCLOSE
PARENCLOSE
SEMICOLON
RETURN
INTEGER(0)
SEMICOLON
BRACKETCLOSE
SEMICOLON
BRACKETCLOSE
ELSE
BRACKETOPEN
MEM_WARN
PARENOPEN
CONCATSTRINGS
PARENOPEN
"STR_ToInt: cannot convert string: "
COMMA
STR
PARENCLOSE
PARENCLOSE
SEMICOLON
RETURN
INTEGER(0)
SEMICOLON
BRACKETCLOSE
SEMICOLON
INDEX
PLUSASSIGN
INTEGER(1)
SEMICOLON
MEM_STACKPOS
PERIOD
POSITION
ASSIGN
LOOPSTART
SEMICOLON
BRACKETCLOSE
SEMICOLON
IF
PARENOPEN
MINUS
PARENCLOSE
BRACKETOPEN
RETURN
MINUS
RES
SEMICOLON
BRACKETCLOSE
ELSE
BRACKETOPEN
RETURN
PLUS
RES
SEMICOLON
BRACKETCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// ************************************************
//  STR_IndexOf
// ************************************************
FUNC
INT
STR_INDEXOF
PARENOPEN
VAR
STRING
STR
COMMA
VAR
STRING
TOK
PARENCLOSE
BRACKETOPEN
VAR
ZSTRING
ZSTR
SEMICOLON
ZSTR
ASSIGN
_^
PARENOPEN
_@S
PARENOPEN
STR
PARENCLOSE
PARENCLOSE
SEMICOLON
VAR
ZSTRING
ZTOK
SEMICOLON
ZTOK
ASSIGN
_^
PARENOPEN
_@S
PARENOPEN
TOK
PARENCLOSE
PARENCLOSE
SEMICOLON
IF
PARENOPEN
ZTOK
PERIOD
LEN
EQUALS
INTEGER(0)
PARENCLOSE
BRACKETOPEN
RETURN
INTEGER(0)
SEMICOLON
BRACKETCLOSE
SEMICOLON
IF
PARENOPEN
ZSTR
PERIOD
LEN
EQUALS
INTEGER(0)
PARENCLOSE
BRACKETOPEN
RETURN
MINUS
INTEGER(1)
SEMICOLON
BRACKETCLOSE
SEMICOLON
VAR
INT
STARTPOS
SEMICOLON
STARTPOS
ASSIGN
ZSTR
PERIOD
PTR
SEMICOLON
VAR
INT
STARTMAX
SEMICOLON
STARTMAX
ASSIGN
ZSTR
PERIOD
PTR
PLUS
ZSTR
PERIOD
LEN
MINUS
ZTOK
PERIOD
LEN
SEMICOLON
VAR
INT
LOOPPOS
SEMICOLON
LOOPPOS
ASSIGN
MEM_STACKPOS
PERIOD
POSITION
SEMICOLON
IF
PARENOPEN
STARTPOS
LOWEREQUALS
STARTMAX
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
MEM_COMPAREBYTES
PARENOPEN
STARTPOS
COMMA
ZTOK
PERIOD
PTR
COMMA
ZTOK
PERIOD
LEN
PARENCLOSE
PARENCLOSE
BRACKETOPEN
RETURN
STARTPOS
MINUS
ZSTR
PERIOD
PTR
SEMICOLON
BRACKETCLOSE
SEMICOLON
STARTPOS
PLUSASSIGN
INTEGER(1)
SEMICOLON
MEM_STACKPOS
PERIOD
POSITION
ASSIGN
LOOPPOS
SEMICOLON
BRACKETCLOSE
SEMICOLON
RETURN
MINUS
INTEGER(1)
SEMICOLON
BRACKETCLOSE
SEMICOLON
// ************************************************
//  STR_Split
// ************************************************
//  ursprünglicher Code von Gottfried 
//  STRINT_SplitArray enthält folgendes:\n *\n *    struct TStringInfo {\n *        int length;\n *        char* data;\n *    };\n 
CONST
INT
STRINT_SPLITARRAY
ASSIGN
INTEGER(0)
SEMICOLON
FUNC
VOID
STRINT_SPLITRESET
PARENOPEN
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
NOT
STRINT_SPLITARRAY
PARENCLOSE
BRACKETOPEN
STRINT_SPLITARRAY
ASSIGN
MEM_ARRAYCREATE
PARENOPEN
PARENCLOSE
SEMICOLON
RETURN
SEMICOLON
BRACKETCLOSE
SEMICOLON
VAR
ZCARRAY
ARR
SEMICOLON
ARR
ASSIGN
_^
PARENOPEN
STRINT_SPLITARRAY
PARENCLOSE
SEMICOLON
VAR
INT
I
SEMICOLON
I
ASSIGN
INTEGER(0)
SEMICOLON
VAR
INT
LOOPPOS
SEMICOLON
LOOPPOS
ASSIGN
MEM_STACKPOS
PERIOD
POSITION
SEMICOLON
IF
// while
PARENOPEN
I
LOWER
ARR
PERIOD
NUMINARRAY
PARENCLOSE
BRACKETOPEN
MEM_FREE
PARENOPEN
MEM_READINTARRAY
PARENOPEN
ARR
PERIOD
ARRAY
COMMA
I
PLUS
INTEGER(1)
PARENCLOSE
PARENCLOSE
SEMICOLON
I
PLUSASSIGN
INTEGER(2)
SEMICOLON
MEM_STACKPOS
PERIOD
POSITION
ASSIGN
LOOPPOS
SEMICOLON
BRACKETCLOSE
SEMICOLON
MEM_ARRAYCLEAR
PARENOPEN
STRINT_SPLITARRAY
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
STRINT_SPLIT
PARENOPEN
VAR
STRING
STR
COMMA
VAR
STRING
SEPERATOR
PARENCLOSE
BRACKETOPEN
STRINT_SPLITRESET
PARENOPEN
PARENCLOSE
SEMICOLON
VAR
ZSTRING
ZSTR
SEMICOLON
ZSTR
ASSIGN
_^
PARENOPEN
_@S
PARENOPEN
STR
PARENCLOSE
PARENCLOSE
SEMICOLON
IF
PARENOPEN
STR_LEN
PARENOPEN
SEPERATOR
PARENCLOSE
NOTEQUALS
INTEGER(1)
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"STR_Split: Seperator must be a string of length 1!"
PARENCLOSE
SEMICOLON
RETURN
SEMICOLON
BRACKETCLOSE
SEMICOLON
IF
PARENOPEN
ZSTR
PERIOD
LEN
EQUALS
INTEGER(0)
PARENCLOSE
BRACKETOPEN
// careful: cannot read from zStr.ptr if zStr.len == 0!
// handling without lazy evaluation would be sucky.
MEM_ARRAYINSERT
PARENOPEN
STRINT_SPLITARRAY
COMMA
INTEGER(0)
PARENCLOSE
SEMICOLON
MEM_ARRAYINSERT
PARENOPEN
STRINT_SPLITARRAY
COMMA
MEM_ALLOC
PARENOPEN
INTEGER(0)
PARENCLOSE
PARENCLOSE
SEMICOLON
RETURN
SEMICOLON
BRACKETCLOSE
SEMICOLON
VAR
INT
CSEP
SEMICOLON
CSEP
ASSIGN
STR_GETCHARAT
PARENOPEN
SEPERATOR
COMMA
INTEGER(0)
PARENCLOSE
SEMICOLON
VAR
INT
CURRTOKSTART
SEMICOLON
CURRTOKSTART
ASSIGN
ZSTR
PERIOD
PTR
SEMICOLON
VAR
INT
STREND
SEMICOLON
STREND
ASSIGN
ZSTR
PERIOD
PTR
PLUS
ZSTR
PERIOD
LEN
SEMICOLON
VAR
INT
WALKER
SEMICOLON
WALKER
ASSIGN
CURRTOKSTART
SEMICOLON
VAR
INT
LOOPPOS
SEMICOLON
LOOPPOS
ASSIGN
MEM_STACKPOS
PERIOD
POSITION
SEMICOLON
IF
//  while
PARENOPEN
WALKER
LOWEREQUALS
STREND
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
WALKER
EQUALS
STREND
OR
MEM_READBYTE
PARENOPEN
WALKER
PARENCLOSE
EQUALS
CSEP
PARENCLOSE
BRACKETOPEN
VAR
INT
LEN
SEMICOLON
LEN
ASSIGN
WALKER
MINUS
CURRTOKSTART
SEMICOLON
VAR
INT
SUBSTR
SEMICOLON
SUBSTR
ASSIGN
MEM_ALLOC
PARENOPEN
LEN
PARENCLOSE
SEMICOLON
MEM_COPYBYTES
PARENOPEN
CURRTOKSTART
COMMA
SUBSTR
COMMA
LEN
PARENCLOSE
SEMICOLON
MEM_ARRAYINSERT
PARENOPEN
STRINT_SPLITARRAY
COMMA
LEN
PARENCLOSE
SEMICOLON
MEM_ARRAYINSERT
PARENOPEN
STRINT_SPLITARRAY
COMMA
SUBSTR
PARENCLOSE
SEMICOLON
CURRTOKSTART
ASSIGN
WALKER
PLUS
INTEGER(1)
SEMICOLON
BRACKETCLOSE
SEMICOLON
WALKER
PLUSASSIGN
INTEGER(1)
SEMICOLON
MEM_STACKPOS
PERIOD
POSITION
ASSIGN
LOOPPOS
SEMICOLON
BRACKETCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
STRING
STRINT_SPLITGET
PARENOPEN
VAR
INT
OFFSET
PARENCLOSE
BRACKETOPEN
VAR
ZCARRAY
ARR
SEMICOLON
ARR
ASSIGN
_^
PARENOPEN
STRINT_SPLITARRAY
PARENCLOSE
SEMICOLON
IF
PARENOPEN
ARR
PERIOD
NUMINARRAY
DIVIDE
INTEGER(2)
LOWEREQUALS
OFFSET
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"STR_Split: The string does not decompose into that many substrings!"
PARENCLOSE
SEMICOLON
RETURN
""
SEMICOLON
BRACKETCLOSE
SEMICOLON
VAR
STRING
STR
SEMICOLON
STR
ASSIGN
""
SEMICOLON
VAR
ZSTRING
ZSTR
SEMICOLON
ZSTR
ASSIGN
_^
PARENOPEN
_@S
PARENOPEN
STR
PARENCLOSE
PARENCLOSE
SEMICOLON
VAR
INT
LEN
SEMICOLON
LEN
ASSIGN
MEM_READINTARRAY
PARENOPEN
ARR
PERIOD
ARRAY
COMMA
INTEGER(2)
MULTIPLY
OFFSET
PARENCLOSE
SEMICOLON
ZSTR
PERIOD
PTR
ASSIGN
MEM_ALLOC
PARENOPEN
LEN
PLUS
INTEGER(2)
PARENCLOSE
PLUS
INTEGER(1)
SEMICOLON
ZSTR
PERIOD
LEN
ASSIGN
LEN
SEMICOLON
ZSTR
PERIOD
RES
ASSIGN
LEN
SEMICOLON
MEM_COPYBYTES
PARENOPEN
MEM_READINTARRAY
PARENOPEN
ARR
PERIOD
ARRAY
COMMA
INTEGER(2)
MULTIPLY
OFFSET
PLUS
INTEGER(1)
PARENCLOSE
COMMA
ZSTR
PERIOD
PTR
COMMA
LEN
PARENCLOSE
SEMICOLON
RETURN
STR
SEMICOLON
BRACKETCLOSE
SEMICOLON
VAR
STRING
STRINT_SPLITCACHE
SEMICOLON
VAR
STRING
STRINT_SPLITSEPERATORCACHE
SEMICOLON
FUNC
STRING
STR_SPLIT
PARENOPEN
VAR
STRING
STR
COMMA
VAR
STRING
SEPARATOR
COMMA
VAR
INT
OFFSET
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
HLP_STRCMP
PARENOPEN
STRINT_SPLITCACHE
COMMA
STR
PARENCLOSE
AND
NOT
HLP_STRCMP
PARENOPEN
STRINT_SPLITCACHE
COMMA
""
PARENCLOSE
AND
HLP_STRCMP
PARENOPEN
STRINT_SPLITSEPERATORCACHE
COMMA
SEPARATOR
PARENCLOSE
PARENCLOSE
BRACKETOPEN
RETURN
STRINT_SPLITGET
PARENOPEN
OFFSET
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
STRINT_SPLIT
PARENOPEN
STR
COMMA
SEPARATOR
PARENCLOSE
SEMICOLON
STRINT_SPLITCACHE
ASSIGN
STR
SEMICOLON
STRINT_SPLITSEPERATORCACHE
ASSIGN
SEPARATOR
SEMICOLON
RETURN
STRINT_SPLITGET
PARENOPEN
OFFSET
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
STR_SPLITCOUNT
PARENOPEN
VAR
STRING
STR
COMMA
VAR
STRING
SEPERATOR
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
NOT
HLP_STRCMP
PARENOPEN
STRINT_SPLITCACHE
COMMA
STR
PARENCLOSE
OR
NOT
HLP_STRCMP
PARENOPEN
STRINT_SPLITSEPERATORCACHE
COMMA
SEPERATOR
PARENCLOSE
OR
HLP_STRCMP
PARENOPEN
STRINT_SPLITCACHE
COMMA
""
PARENCLOSE
PARENCLOSE
BRACKETOPEN
STRINT_SPLIT
PARENOPEN
STR
COMMA
SEPERATOR
PARENCLOSE
SEMICOLON
STRINT_SPLITCACHE
ASSIGN
STR
SEMICOLON
STRINT_SPLITSEPERATORCACHE
ASSIGN
SEPERATOR
SEMICOLON
BRACKETCLOSE
SEMICOLON
VAR
ZCARRAY
ARR
SEMICOLON
ARR
ASSIGN
_^
PARENOPEN
STRINT_SPLITARRAY
PARENCLOSE
SEMICOLON
RETURN
ARR
PERIOD
NUMINARRAY
DIVIDE
INTEGER(2)
SEMICOLON
BRACKETCLOSE
SEMICOLON
// ************************************************
//     Upper Case (Gottfried)
// ************************************************
FUNC
STRING
STR_UPPER
PARENOPEN
VAR
STRING
STR
PARENCLOSE
BRACKETOPEN
CONST
INT
ZSTRING__UPPER_G1
ASSIGN
INTEGER(4608912)
SEMICOLON
// 0x465390
CONST
INT
ZSTRING__UPPER_G2
ASSIGN
INTEGER(4631296)
SEMICOLON
// 0x46AB00
VAR
INT
PTR
SEMICOLON
PTR
ASSIGN
_@S
PARENOPEN
STR
PARENCLOSE
SEMICOLON
CONST
INT
CALL
ASSIGN
INTEGER(0)
SEMICOLON
IF
PARENOPEN
CALL_BEGIN
PARENOPEN
CALL
PARENCLOSE
PARENCLOSE
BRACKETOPEN
CALL_PUTRETVALTO
PARENOPEN
INTEGER(0)
PARENCLOSE
SEMICOLON
CALL__THISCALL
PARENOPEN
_@
PARENOPEN
PTR
PARENCLOSE
COMMA
MEMINT_SWITCHG1G2
PARENOPEN
ZSTRING__UPPER_G1
COMMA
ZSTRING__UPPER_G2
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL
ASSIGN
CALL_END
PARENOPEN
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
RETURN
STR
SEMICOLON
BRACKETCLOSE
SEMICOLON
// ######################################################
// 
//   More elaborate zCParser related functions
// 
// ######################################################
// --------------------------------------
//    Zeiger auf 8KB holen. Jeder darf drauf
//    schreiben, niemand darf sich drauf
//    verlassen, dass irgendjemand ihn
//    unangetastet lässt.
// 
//    Zur Vermeidung temporärer kleiner
//    MEM_Alloc anfragen.
// --------------------------------------
//  Weiß nicht ob ich das mit hätte reinnehmen sollen...\n * Aber warum nicht? 
FUNC
INT
MEMINT_GETBUF_8K_SUB
PARENOPEN
PARENCLOSE
BRACKETOPEN
VAR
INT
BUF
SQUAREOPEN
INTEGER(2048)
SQUARECLOSE
SEMICOLON
RETURN
BUF
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
MEMINT_GETBUF_8K
PARENOPEN
PARENCLOSE
BRACKETOPEN
MEMINT_GETBUF_8K_SUB
PARENOPEN
PARENCLOSE
SEMICOLON
MEMINT_STACKPOPINST
PARENOPEN
PARENCLOSE
SEMICOLON
MEMINT_STACKPUSHINST
PARENOPEN
ZPAR_TOK_PUSHINT
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// ************************************************
//  Search Symbols
// ************************************************
FUNC
INT
MEM_FINDPARSERSYMBOL
PARENOPEN
VAR
STRING
INST
PARENCLOSE
BRACKETOPEN
CONST
INT
ZCPARSER__GETINDEX_G1
ASSIGN
INTEGER(7250112)
SEMICOLON
// 0x6EA0C0
CONST
INT
ZCPARSER__GETINDEX_G2
ASSIGN
INTEGER(7943280)
SEMICOLON
// 0x793470
VAR
INT
PTR
SEMICOLON
PTR
ASSIGN
_@S
PARENOPEN
INST
PARENCLOSE
SEMICOLON
CONST
INT
CALL
ASSIGN
INTEGER(0)
SEMICOLON
IF
PARENOPEN
CALL_BEGIN
PARENOPEN
CALL
PARENCLOSE
PARENCLOSE
BRACKETOPEN
CALL_PTRPARAM
PARENOPEN
_@
PARENOPEN
PTR
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL_PUTRETVALTO
PARENOPEN
_@
PARENOPEN
RET
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL__THISCALL
PARENOPEN
_@
PARENOPEN
CURRPARSERADDRESS
PARENCLOSE
COMMA
MEMINT_SWITCHG1G2
PARENOPEN
ZCPARSER__GETINDEX_G1
COMMA
ZCPARSER__GETINDEX_G2
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL
ASSIGN
CALL_END
PARENOPEN
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
VAR
INT
RET
SEMICOLON
RETURN
PLUS
RET
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
MEM_GETSYMBOLINDEX
PARENOPEN
VAR
STRING
INST
PARENCLOSE
BRACKETOPEN
RETURN
MEM_FINDPARSERSYMBOL
PARENOPEN
INST
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
MEM_GETPARSERSYMBOL
PARENOPEN
VAR
STRING
INST
PARENCLOSE
BRACKETOPEN
VAR
INT
SYMID
SEMICOLON
SYMID
ASSIGN
MEM_FINDPARSERSYMBOL
PARENOPEN
INST
PARENCLOSE
SEMICOLON
// does ReinitParser
IF
PARENOPEN
SYMID
EQUALS
MINUS
INTEGER(1)
PARENCLOSE
BRACKETOPEN
RETURN
INTEGER(0)
SEMICOLON
BRACKETCLOSE
ELSE
BRACKETOPEN
RETURN
MEM_READINTARRAY
PARENOPEN
CURRSYMBOLTABLEADDRESS
COMMA
SYMID
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
MEM_GETSYMBOL
PARENOPEN
VAR
STRING
INST
PARENCLOSE
BRACKETOPEN
RETURN
MEM_GETPARSERSYMBOL
PARENOPEN
INST
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
MEM_GETSYMBOLBYINDEX
PARENOPEN
VAR
INT
ID
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
ID
LOWER
INTEGER(0)
OR
ID
GREATEREQUALS
CURRSYMBOLTABLELENGTH
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
CONCATSTRINGS
PARENOPEN
"MEM_GetSymbolByIndex: Index is not in valid bounds: "
COMMA
INTTOSTRING
PARENOPEN
ID
PARENCLOSE
PARENCLOSE
PARENCLOSE
SEMICOLON
RETURN
INTEGER(0)
SEMICOLON
BRACKETCLOSE
SEMICOLON
RETURN
MEM_READINTARRAY
PARENOPEN
CURRSYMBOLTABLEADDRESS
COMMA
ID
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// ************************************************
//    MEM_CallBy*
// ************************************************
// --------------------------------------
//   Parameter übergeben,
//   Rückgabewerte verwenden.
//   Nochmal explizit
// --------------------------------------
//  Kurze Hilfsfunktion, damit die Schnittstelle\n * von PushParam nicht verwirrt. 
FUNC
INT
MEMINT_PUSHINTPARAM
PARENOPEN
VAR
INT
PARAM
PARENCLOSE
BRACKETOPEN
RETURN
PLUS
PARAM
SEMICOLON
// kein Var pushen sondern Konstante!
BRACKETCLOSE
SEMICOLON
//  Werte auf den Stack schieben 
FUNC
VOID
MEM_PUSHINTPARAM
PARENOPEN
VAR
INT
PARAM
PARENCLOSE
BRACKETOPEN
MEMINT_PUSHINTPARAM
PARENOPEN
PARAM
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEM_PUSHINSTPARAM
PARENOPEN
VAR
INT
INST
PARENCLOSE
BRACKETOPEN
MEMINT_STACKPUSHINST
PARENOPEN
INST
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
//  wie MEMINT_PushString, aber eigene statische Strings\n * ging nämlich schief, weil STR_Compare oft string auf den Stack\n * schieben will! 
FUNC
STRING
MEMINT_PUSHSTRINGPARAMSUB
PARENOPEN
VAR
STRING
STR
PARENCLOSE
BRACKETOPEN
VAR
INT
N
SEMICOLON
N
PLUSASSIGN
INTEGER(1)
SEMICOLON
IF
PARENOPEN
N
EQUALS
INTEGER(10)
PARENCLOSE
BRACKETOPEN
N
ASSIGN
INTEGER(0)
SEMICOLON
BRACKETCLOSE
SEMICOLON
IF
PARENOPEN
N
EQUALS
INTEGER(0)
PARENCLOSE
BRACKETOPEN
VAR
STRING
S0
SEMICOLON
S0
ASSIGN
STR
SEMICOLON
RETURN
S0
SEMICOLON
BRACKETCLOSE
SEMICOLON
IF
PARENOPEN
N
EQUALS
INTEGER(1)
PARENCLOSE
BRACKETOPEN
VAR
STRING
S1
SEMICOLON
S1
ASSIGN
STR
SEMICOLON
RETURN
S1
SEMICOLON
BRACKETCLOSE
SEMICOLON
IF
PARENOPEN
N
EQUALS
INTEGER(2)
PARENCLOSE
BRACKETOPEN
VAR
STRING
S2
SEMICOLON
S2
ASSIGN
STR
SEMICOLON
RETURN
S2
SEMICOLON
BRACKETCLOSE
SEMICOLON
IF
PARENOPEN
N
EQUALS
INTEGER(3)
PARENCLOSE
BRACKETOPEN
VAR
STRING
S3
SEMICOLON
S3
ASSIGN
STR
SEMICOLON
RETURN
S3
SEMICOLON
BRACKETCLOSE
SEMICOLON
IF
PARENOPEN
N
EQUALS
INTEGER(4)
PARENCLOSE
BRACKETOPEN
VAR
STRING
S4
SEMICOLON
S4
ASSIGN
STR
SEMICOLON
RETURN
S4
SEMICOLON
BRACKETCLOSE
SEMICOLON
IF
PARENOPEN
N
EQUALS
INTEGER(5)
PARENCLOSE
BRACKETOPEN
VAR
STRING
S5
SEMICOLON
S5
ASSIGN
STR
SEMICOLON
RETURN
S5
SEMICOLON
BRACKETCLOSE
SEMICOLON
IF
PARENOPEN
N
EQUALS
INTEGER(6)
PARENCLOSE
BRACKETOPEN
VAR
STRING
S6
SEMICOLON
S6
ASSIGN
STR
SEMICOLON
RETURN
S6
SEMICOLON
BRACKETCLOSE
SEMICOLON
IF
PARENOPEN
N
EQUALS
INTEGER(7)
PARENCLOSE
BRACKETOPEN
VAR
STRING
S7
SEMICOLON
S7
ASSIGN
STR
SEMICOLON
RETURN
S7
SEMICOLON
BRACKETCLOSE
SEMICOLON
IF
PARENOPEN
N
EQUALS
INTEGER(8)
PARENCLOSE
BRACKETOPEN
VAR
STRING
S8
SEMICOLON
S8
ASSIGN
STR
SEMICOLON
RETURN
S8
SEMICOLON
BRACKETCLOSE
SEMICOLON
IF
PARENOPEN
N
EQUALS
INTEGER(9)
PARENCLOSE
BRACKETOPEN
VAR
STRING
S9
SEMICOLON
S9
ASSIGN
STR
SEMICOLON
RETURN
S9
SEMICOLON
BRACKETCLOSE
SEMICOLON
MEM_ASSERTFAIL
PARENOPEN
"Should be never here."
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEM_PUSHSTRINGPARAM
PARENOPEN
VAR
STRING
STR
PARENCLOSE
BRACKETOPEN
MEMINT_PUSHSTRINGPARAMSUB
PARENOPEN
STR
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
//  Werte vom Stack herunterholen. 
FUNC
INT
MEM_POPINTRESULT
PARENOPEN
PARENCLOSE
BRACKETOPEN
BRACKETCLOSE
SEMICOLON
FUNC
STRING
MEM_POPSTRINGRESULT
PARENOPEN
PARENCLOSE
BRACKETOPEN
BRACKETCLOSE
SEMICOLON
FUNC
MEMINT_HELPERCLASS
MEM_POPINSTRESULT
PARENOPEN
PARENCLOSE
BRACKETOPEN
BRACKETCLOSE
SEMICOLON
// --------------------------------------
//  MEM_CallBy ID/String/
// --------------------------------------
FUNC
VOID
MEM_CALLBYID
PARENOPEN
VAR
INT
SYMBID
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
SYMBID
LOWER
INTEGER(0)
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
CONCATSTRINGS
PARENOPEN
"MEM_CallByID: symbID may not be negative but is "
COMMA
INTTOSTRING
PARENOPEN
SYMBID
PARENCLOSE
PARENCLOSE
PARENCLOSE
SEMICOLON
RETURN
SEMICOLON
BRACKETCLOSE
SEMICOLON
VAR
ZCPAR_SYMBOL
SYM
SEMICOLON
SYM
ASSIGN
_^
PARENOPEN
MEM_READINTARRAY
PARENOPEN
CONTENTSYMBOLTABLEADDRESS
COMMA
SYMBID
PARENCLOSE
PARENCLOSE
SEMICOLON
VAR
INT
TYPE
SEMICOLON
TYPE
ASSIGN
PARENOPEN
SYM
PERIOD
BITFIELD
BITAND
ZCPAR_SYMBOL_BITFIELD_TYPE
PARENCLOSE
SEMICOLON
IF
PARENOPEN
TYPE
NOTEQUALS
ZPAR_TYPE_FUNC
PARENCLOSE
AND
PARENOPEN
TYPE
NOTEQUALS
ZPAR_TYPE_PROTOTYPE
PARENCLOSE
AND
PARENOPEN
TYPE
NOTEQUALS
ZPAR_TYPE_INSTANCE
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
CONCATSTRINGS
PARENOPEN
"MEM_CallByID: Provided symbol is not callable (not function, prototype or instance): "
COMMA
SYM
PERIOD
NAME
PARENCLOSE
PARENCLOSE
SEMICOLON
RETURN
SEMICOLON
BRACKETCLOSE
SEMICOLON
IF
PARENOPEN
SYM
PERIOD
BITFIELD
BITAND
ZPAR_FLAG_EXTERNAL
PARENCLOSE
BRACKETOPEN
CALL__STDCALL
PARENOPEN
SYM
PERIOD
CONTENT
PARENCLOSE
SEMICOLON
BRACKETCLOSE
ELSE
BRACKETOPEN
MEM_CALLBYPTR
PARENOPEN
SYM
PERIOD
CONTENT
PLUS
CURRPARSERSTACKADDRESS
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEM_CALLBYSTRING
PARENOPEN
VAR
STRING
FNC
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
HLP_STRCMP
PARENOPEN
FNC
COMMA
""
PARENCLOSE
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"MEM_CallByString: fnc may not be an empty string!"
PARENCLOSE
SEMICOLON
RETURN
SEMICOLON
BRACKETCLOSE
SEMICOLON
//  Mikrooptimierung: Wird zweimal hintereinander die selbe Funktion\n     * mit CallByString aufgerufen, nicht nochmal neu suchen. 
VAR
INT
SYMBID
SEMICOLON
VAR
STRING
CACHEFUNC
SEMICOLON
VAR
INT
CACHESYMBID
SEMICOLON
IF
PARENOPEN
HLP_STRCMP
PARENOPEN
CACHEFUNC
COMMA
FNC
PARENCLOSE
PARENCLOSE
BRACKETOPEN
SYMBID
ASSIGN
CACHESYMBID
SEMICOLON
BRACKETCLOSE
ELSE
BRACKETOPEN
SYMBID
ASSIGN
MEM_FINDPARSERSYMBOL
PARENOPEN
FNC
PARENCLOSE
SEMICOLON
IF
PARENOPEN
SYMBID
EQUALS
MINUS
INTEGER(1)
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
CONCATSTRINGS
PARENOPEN
"MEM_CallByString: Undefined symbol: "
COMMA
FNC
PARENCLOSE
PARENCLOSE
SEMICOLON
RETURN
SEMICOLON
BRACKETCLOSE
SEMICOLON
CACHEFUNC
ASSIGN
FNC
SEMICOLON
CACHESYMBID
ASSIGN
SYMBID
SEMICOLON
BRACKETCLOSE
SEMICOLON
MEM_CALLBYID
PARENOPEN
SYMBID
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEM_CALL
PARENOPEN
VAR
FUNC
FNC
PARENCLOSE
BRACKETOPEN
MEM_CALLBYID
PARENOPEN
MEM_GETFUNCID
PARENOPEN
FNC
PARENCLOSE
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// ************************************************
// 	Find function by Stack Offset
// ************************************************
FUNC
INT
MEMINT_BUILDFUNCSTARTSARRAY
PARENOPEN
PARENCLOSE
BRACKETOPEN
VAR
INT
ARRAY
SEMICOLON
ARRAY
ASSIGN
MEM_ARRAYCREATE
PARENOPEN
PARENCLOSE
SEMICOLON
VAR
INT
LASTOFFSET
SEMICOLON
LASTOFFSET
ASSIGN
INTEGER(0)
SEMICOLON
VAR
INT
WASSORTED
SEMICOLON
WASSORTED
ASSIGN
INTEGER(1)
SEMICOLON
VAR
INT
I
SEMICOLON
I
ASSIGN
INTEGER(0)
SEMICOLON
VAR
INT
LOOP
SEMICOLON
LOOP
ASSIGN
MEM_STACKPOS
PERIOD
POSITION
SEMICOLON
IF
PARENOPEN
I
LOWER
MEM_PARSER
PERIOD
SYMTAB_TABLE_NUMINARRAY
PARENCLOSE
BRACKETOPEN
VAR
ZCPAR_SYMBOL
SYMB
SEMICOLON
SYMB
ASSIGN
_^
PARENOPEN
MEM_READINTARRAY
PARENOPEN
MEM_PARSER
PERIOD
SYMTAB_TABLE_ARRAY
COMMA
I
PARENCLOSE
PARENCLOSE
SEMICOLON
IF
PARENOPEN
SYMB
PERIOD
BITFIELD
BITAND
ZPAR_FLAG_CONST
PARENCLOSE
AND
NOT
PARENOPEN
SYMB
PERIOD
BITFIELD
BITAND
ZPAR_FLAG_EXTERNAL
PARENCLOSE
AND
PARENOPEN
PARENOPEN
SYMB
PERIOD
BITFIELD
BITAND
ZCPAR_SYMBOL_BITFIELD_TYPE
PARENCLOSE
EQUALS
ZPAR_TYPE_FUNC
PARENCLOSE
BRACKETOPEN
//  check integrity 
IF
PARENOPEN
WASSORTED
AND
LASTOFFSET
GREATER
SYMB
PERIOD
CONTENT
PARENCLOSE
BRACKETOPEN
WASSORTED
ASSIGN
INTEGER(0)
SEMICOLON
MEM_INFO
PARENOPEN
"The functions in the symbol table do not seem to be sorted by stack-offset."
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
LASTOFFSET
ASSIGN
SYMB
PERIOD
CONTENT
SEMICOLON
MEM_ARRAYINSERT
PARENOPEN
ARRAY
COMMA
SYMB
PERIOD
CONTENT
PARENCLOSE
SEMICOLON
// offset
MEM_ARRAYINSERT
PARENOPEN
ARRAY
COMMA
I
PARENCLOSE
SEMICOLON
// id
BRACKETCLOSE
SEMICOLON
I
PLUSASSIGN
INTEGER(1)
SEMICOLON
MEM_STACKPOS
PERIOD
POSITION
ASSIGN
LOOP
SEMICOLON
BRACKETCLOSE
SEMICOLON
IF
PARENOPEN
NOT
WASSORTED
PARENCLOSE
BRACKETOPEN
VAR
ZCARRAY
ZCARR
SEMICOLON
ZCARR
ASSIGN
_^
PARENOPEN
ARRAY
PARENCLOSE
SEMICOLON
MEMINT_QSORT
PARENOPEN
ZCARR
PERIOD
ARRAY
COMMA
ZCARR
PERIOD
NUMINARRAY
DIVIDE
INTEGER(2)
COMMA
INTEGER(8)
COMMA
INTEGER(0)
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
RETURN
ARRAY
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
MEM_GETFUNCIDBYOFFSET
PARENOPEN
VAR
INT
OFFSET
PARENCLOSE
BRACKETOPEN
CONST
INT
FUNCSTARTSARRAY
ASSIGN
INTEGER(0)
SEMICOLON
IF
PARENOPEN
NOT
FUNCSTARTSARRAY
PARENCLOSE
BRACKETOPEN
FUNCSTARTSARRAY
ASSIGN
MEMINT_BUILDFUNCSTARTSARRAY
PARENOPEN
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
IF
PARENOPEN
OFFSET
LOWER
INTEGER(0)
OR
OFFSET
GREATEREQUALS
MEM_PARSER
PERIOD
STACK_STACKSIZE
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"MEM_GetFuncIDByOffset: Offset is not in valid bounds (0 <= offset < ParserStackSize)."
PARENCLOSE
SEMICOLON
RETURN
MINUS
INTEGER(1)
SEMICOLON
BRACKETCLOSE
SEMICOLON
VAR
ZCARRAY
ARRAY
SEMICOLON
ARRAY
ASSIGN
_^
PARENOPEN
FUNCSTARTSARRAY
PARENCLOSE
SEMICOLON
//  binary search 
VAR
INT
RES
SEMICOLON
RES
ASSIGN
MINUS
INTEGER(1)
SEMICOLON
VAR
INT
LOW
SEMICOLON
LOW
ASSIGN
INTEGER(0)
SEMICOLON
VAR
INT
HIGH
SEMICOLON
HIGH
ASSIGN
ARRAY
PERIOD
NUMINARRAY
DIVIDE
INTEGER(2)
MINUS
INTEGER(1)
SEMICOLON
VAR
INT
LOOP
SEMICOLON
LOOP
ASSIGN
MEM_STACKPOS
PERIOD
POSITION
SEMICOLON
//  while (1) { 
//  invariant: array[low] <= offset <= array[high]\n                      low < high                          
VAR
INT
MED
SEMICOLON
MED
ASSIGN
PARENOPEN
LOW
PLUS
HIGH
PARENCLOSE
DIVIDE
INTEGER(2)
SEMICOLON
//  low <= med < high 
VAR
INT
MEDOFFSET
SEMICOLON
MEDOFFSET
ASSIGN
MEM_READINTARRAY
PARENOPEN
ARRAY
PERIOD
ARRAY
COMMA
INTEGER(2)
MULTIPLY
MED
PARENCLOSE
SEMICOLON
IF
PARENOPEN
MEDOFFSET
GREATEREQUALS
OFFSET
PARENCLOSE
BRACKETOPEN
HIGH
ASSIGN
MED
SEMICOLON
//  progess because med < high 
BRACKETCLOSE
ELSE
BRACKETOPEN
IF
PARENOPEN
LOW
EQUALS
MED
PARENCLOSE
BRACKETOPEN
//  can only occur if low == high - 1 
IF
PARENOPEN
MEM_READINTARRAY
PARENOPEN
ARRAY
PERIOD
ARRAY
COMMA
INTEGER(2)
MULTIPLY
HIGH
PARENCLOSE
LOWEREQUALS
OFFSET
PARENCLOSE
BRACKETOPEN
RES
ASSIGN
HIGH
SEMICOLON
BRACKETCLOSE
ELSE
BRACKETOPEN
RES
ASSIGN
LOW
SEMICOLON
BRACKETCLOSE
SEMICOLON
BRACKETCLOSE
ELSE
BRACKETOPEN
LOW
ASSIGN
MED
SEMICOLON
//  progress because low < med 
BRACKETCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
IF
PARENOPEN
LOW
EQUALS
HIGH
PARENCLOSE
BRACKETOPEN
RES
ASSIGN
LOW
SEMICOLON
BRACKETCLOSE
SEMICOLON
IF
PARENOPEN
RES
NOTEQUALS
MINUS
INTEGER(1)
PARENCLOSE
BRACKETOPEN
RETURN
MEM_READINTARRAY
PARENOPEN
ARRAY
PERIOD
ARRAY
COMMA
INTEGER(2)
MULTIPLY
RES
PLUS
INTEGER(1)
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
MEM_STACKPOS
PERIOD
POSITION
ASSIGN
LOOP
SEMICOLON
//  } end while 
BRACKETCLOSE
SEMICOLON
// ************************************************
//    Den eigenene Stackframe finden
// ************************************************
// Get ESP that points (not too far) above the current DoStack Frame:
FUNC
INT
MEMINT_GETESP
PARENOPEN
PARENCLOSE
BRACKETOPEN
VAR
INT
ESP
SEMICOLON
CONST
INT
CALL
ASSIGN
INTEGER(0)
SEMICOLON
IF
PARENOPEN
CALL_BEGIN
PARENOPEN
CALL
PARENCLOSE
PARENCLOSE
BRACKETOPEN
ASM_2
PARENOPEN
ASMINT_OP_MOVESPTOEAX
PARENCLOSE
SEMICOLON
ASM_2
PARENOPEN
ASMINT_OP_MOVEAXTOMEM
PARENCLOSE
SEMICOLON
ASM_4
PARENOPEN
_@
PARENOPEN
ESP
PARENCLOSE
PARENCLOSE
SEMICOLON
ASM_1
PARENOPEN
ASMINT_OP_RETN
PARENCLOSE
SEMICOLON
CALL
ASSIGN
CALL_END
PARENOPEN
PARENCLOSE
SEMICOLON
IF
PARENOPEN
CALL_BEGIN
PARENOPEN
CALL
PARENCLOSE
PARENCLOSE
BRACKETOPEN
BRACKETCLOSE
SEMICOLON
// result may be different on first time!
BRACKETCLOSE
SEMICOLON
RETURN
ESP
SEMICOLON
BRACKETCLOSE
SEMICOLON
// Check for and find zCParser::DoStack lying on itself on the Stack.
// returns the position one word above the return address (usually points to -1, part of the SEH)
FUNC
INT
MEMINT_ISFRAMEBOUNDARY
PARENOPEN
VAR
INT
ESP
PARENCLOSE
BRACKETOPEN
CONST
INT
RETADR
ASSIGN
INTEGER(0)
SEMICOLON
IF
PARENOPEN
NOT
RETADR
PARENCLOSE
BRACKETOPEN
//  Wenn DoStack sich selbst aufruft, steht diese Rücksprungaddresse auf dem Stack: 
RETADR
ASSIGN
MEMINT_SWITCHG1G2
PARENOPEN
INTEGER(7246244)
//  0x6E91A4 
COMMA
INTEGER(7939332)
// 0x792504 
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
RETURN
PARENOPEN
MEM_READINT
PARENOPEN
ESP
PARENCLOSE
EQUALS
MINUS
INTEGER(1)
PARENCLOSE
AND
PARENOPEN
MEM_READINT
PARENOPEN
ESP
PLUS
INTEGER(4)
PARENCLOSE
EQUALS
RETADR
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
MEMINT_FINDFRAMEBOUNDARY
PARENOPEN
VAR
INT
ESP
COMMA
VAR
INT
SEARCHWORDSMAX
PARENCLOSE
BRACKETOPEN
VAR
INT
LOOP
SEMICOLON
LOOP
ASSIGN
MEM_STACKPOS
PERIOD
POSITION
SEMICOLON
//  didnt find anything 
IF
PARENOPEN
SEARCHWORDSMAX
EQUALS
INTEGER(0)
PARENCLOSE
BRACKETOPEN
RETURN
INTEGER(0)
SEMICOLON
BRACKETCLOSE
SEMICOLON
//  while 
IF
PARENOPEN
NOT
MEMINT_ISFRAMEBOUNDARY
PARENOPEN
ESP
PARENCLOSE
PARENCLOSE
BRACKETOPEN
//  I am only interested in frame starts 
ESP
PLUSASSIGN
INTEGER(4)
SEMICOLON
SEARCHWORDSMAX
MINUSASSIGN
INTEGER(1)
SEMICOLON
MEM_STACKPOS
PERIOD
POSITION
ASSIGN
LOOP
SEMICOLON
BRACKETCLOSE
SEMICOLON
//  end while 
RETURN
ESP
SEMICOLON
BRACKETCLOSE
SEMICOLON
// Now get not only some Stack Frame, but my own!
//  offset of two frames when calling it self 
CONST
INT
MEMINT_DOSTACKFRAMESIZE
ASSIGN
INTEGER(88)
SEMICOLON
//  location of oldPopPos after having called itself 
CONST
INT
MEMINT_DOSTACKPOPPOSOFFSET
ASSIGN
MEMINT_DOSTACKFRAMESIZE
PLUS
MEMINT_DOSTACKFRAMESIZE
MINUS
INTEGER(6)
MULTIPLY
INTEGER(4)
SEMICOLON
FUNC
INT
MEM_GETFRAMEBOUNDARY
PARENOPEN
PARENCLOSE
BRACKETOPEN
CONST
INT
OFFSET
ASSIGN
INTEGER(0)
SEMICOLON
VAR
INT
ESP
SEMICOLON
ESP
ASSIGN
MEMINT_GETESP
PARENOPEN
PARENCLOSE
SEMICOLON
IF
PARENOPEN
NOT
OFFSET
PARENCLOSE
BRACKETOPEN
//  Offset depends on implementation of CALL but is, apart from that, constant.\n         * Better calculate it from scratch at every start of gothic 
VAR
INT
REALESP
SEMICOLON
REALESP
ASSIGN
ESP
SEMICOLON
//  get into a safe area. When reading the ESP the following was in the way:\n            * MEMINT_GetESP\n            * CALL_Begin\n            * ASM_Run\n            * ASMINT_CallMyExternal 
REALESP
PLUSASSIGN
INTEGER(4)
MULTIPLY
MEMINT_DOSTACKFRAMESIZE
SEMICOLON
//  MEMINT_FindFrameBoundary goes deep enough so that it reads on valid stack parts 
REALESP
ASSIGN
MEMINT_FINDFRAMEBOUNDARY
PARENOPEN
REALESP
COMMA
MEMINT_DOSTACKFRAMESIZE
PARENCLOSE
SEMICOLON
IF
PARENOPEN
NOT
REALESP
PARENCLOSE
BRACKETOPEN
MEM_ASSERTFAIL
PARENOPEN
"MEM_GetFrameBoundary: Could not locate start of stackframe."
PARENCLOSE
SEMICOLON
RETURN
INTEGER(0)
SEMICOLON
BRACKETCLOSE
SEMICOLON
VAR
INT
MYID
SEMICOLON
MYID
ASSIGN
MEM_GETFUNCID
PARENOPEN
MEM_GETFRAMEBOUNDARY
PARENCLOSE
SEMICOLON
VAR
INT
LOOP
SEMICOLON
LOOP
ASSIGN
MEM_STACKPOS
PERIOD
POSITION
SEMICOLON
VAR
INT
POPPOS
SEMICOLON
POPPOS
ASSIGN
MEM_READINTARRAY
PARENOPEN
REALESP
MINUS
MEMINT_DOSTACKPOPPOSOFFSET
COMMA
INTEGER(0)
PARENCLOSE
SEMICOLON
//  for safety, use a function that builds another stacklayer 
REALESP
PLUSASSIGN
MEMINT_DOSTACKFRAMESIZE
SEMICOLON
IF
PARENOPEN
MEM_GETFUNCIDBYOFFSET
PARENOPEN
POPPOS
PARENCLOSE
NOTEQUALS
MYID
PARENCLOSE
BRACKETOPEN
MEM_STACKPOS
PERIOD
POSITION
ASSIGN
LOOP
SEMICOLON
BRACKETCLOSE
SEMICOLON
OFFSET
ASSIGN
REALESP
MINUS
ESP
SEMICOLON
BRACKETCLOSE
SEMICOLON
RETURN
ESP
PLUS
OFFSET
SEMICOLON
BRACKETCLOSE
SEMICOLON
// --------------------------------------
//    What this is all about:
// --------------------------------------
FUNC
INT
MEM_GETCALLERSTACKPOS
PARENOPEN
PARENCLOSE
BRACKETOPEN
//  get my Frame Boundary, add 1 Frame (because this isnt about me)\n     * and add another frame (because its not about my caller)\n     * to get the PopPos of my caller's caller 
RETURN
MEM_READINT
PARENOPEN
MEM_GETFRAMEBOUNDARY
PARENOPEN
PARENCLOSE
PLUS
INTEGER(2)
MULTIPLY
MEMINT_DOSTACKFRAMESIZE
MINUS
MEMINT_DOSTACKPOPPOSOFFSET
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEM_SETCALLERSTACKPOS
PARENOPEN
VAR
INT
POPPOS
PARENCLOSE
BRACKETOPEN
MEM_WRITEINT
PARENOPEN
MEM_GETFRAMEBOUNDARY
PARENOPEN
PARENCLOSE
PLUS
INTEGER(2)
MULTIPLY
MEMINT_DOSTACKFRAMESIZE
MINUS
MEMINT_DOSTACKPOPPOSOFFSET
COMMA
POPPOS
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// ************************************************
//    JUMP / GOTO / WHILE
// ************************************************
// --------------------------------------
//     Split function into tokens
// --------------------------------------
//  will append -1, -1, endOfFunc after the last token 
FUNC
VOID
MEMINT_TOKENIZEFUNCTION
PARENOPEN
VAR
INT
FUNCID
COMMA
VAR
INT
TOKENARRAY
COMMA
VAR
INT
PARAMARRAY
COMMA
VAR
INT
POSARR
PARENCLOSE
BRACKETOPEN
VAR
INT
POS
SEMICOLON
VAR
ZCPAR_SYMBOL
SYMB
SEMICOLON
SYMB
ASSIGN
_^
PARENOPEN
MEM_READINTARRAY
PARENOPEN
CONTENTSYMBOLTABLEADDRESS
COMMA
FUNCID
PARENCLOSE
PARENCLOSE
SEMICOLON
POS
ASSIGN
SYMB
PERIOD
CONTENT
SEMICOLON
POS
PLUSASSIGN
CURRPARSERSTACKADDRESS
SEMICOLON
VAR
INT
LOOP
SEMICOLON
LOOP
ASSIGN
MEM_STACKPOS
PERIOD
POSITION
SEMICOLON
MEM_ARRAYINSERT
PARENOPEN
POSARR
COMMA
POS
PARENCLOSE
SEMICOLON
VAR
INT
TOK
SEMICOLON
TOK
ASSIGN
MEM_READBYTE
PARENOPEN
POS
PARENCLOSE
SEMICOLON
POS
PLUSASSIGN
INTEGER(1)
SEMICOLON
VAR
INT
PARAM
SEMICOLON
IF
PARENOPEN
TOK
EQUALS
ZPAR_TOK_CALL
OR
TOK
EQUALS
ZPAR_TOK_CALLEXTERN
PARENCLOSE
OR
PARENOPEN
TOK
EQUALS
ZPAR_TOK_PUSHINT
OR
TOK
EQUALS
ZPAR_TOK_PUSHVAR
PARENCLOSE
OR
PARENOPEN
TOK
EQUALS
ZPAR_TOK_PUSHINST
OR
TOK
EQUALS
ZPAR_TOK_SETINSTANCE
PARENCLOSE
OR
PARENOPEN
TOK
EQUALS
ZPAR_TOK_JUMP
OR
TOK
EQUALS
ZPAR_TOK_JUMPF
PARENCLOSE
BRACKETOPEN
//  take one parameter 
PARAM
ASSIGN
MEM_READINT
PARENOPEN
POS
PARENCLOSE
SEMICOLON
POS
PLUSASSIGN
INTEGER(4)
SEMICOLON
BRACKETCLOSE
ELSE
IF
PARENOPEN
TOK
EQUALS
ZPAR_TOK_PUSH_ARRAYVAR
PARENCLOSE
BRACKETOPEN
PARAM
ASSIGN
MEM_READINT
PARENOPEN
POS
PARENCLOSE
SEMICOLON
POS
PLUSASSIGN
INTEGER(4)
SEMICOLON
POS
PLUSASSIGN
INTEGER(1)
SEMICOLON
// array index.
BRACKETCLOSE
ELSE
IF
PARENOPEN
TOK
GREATER
ZPAR_TOK_SETINSTANCE
PARENCLOSE
BRACKETOPEN
VAR
STRING
ERR
SEMICOLON
ERR
ASSIGN
CONCATSTRINGS
PARENOPEN
"MEMINT_TokenizeFunction: Invalid Token in function "
COMMA
SYMB
PERIOD
NAME
PARENCLOSE
SEMICOLON
ERR
ASSIGN
CONCATSTRINGS
PARENOPEN
ERR
COMMA
". Did you break it? This will probably cause more errors."
PARENCLOSE
SEMICOLON
MEM_ERROR
PARENOPEN
ERR
PARENCLOSE
SEMICOLON
RETURN
SEMICOLON
BRACKETCLOSE
ELSE
BRACKETOPEN
//  probably valid token without parameters 
PARAM
ASSIGN
INTEGER(0)
SEMICOLON
BRACKETCLOSE
SEMICOLON
MEM_ARRAYINSERT
PARENOPEN
TOKENARRAY
COMMA
TOK
PARENCLOSE
SEMICOLON
MEM_ARRAYINSERT
PARENOPEN
PARAMARRAY
COMMA
PARAM
PARENCLOSE
SEMICOLON
IF
PARENOPEN
TOK
EQUALS
ZPAR_TOK_RET
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
MEM_GETFUNCIDBYOFFSET
PARENOPEN
POS
MINUS
CURRPARSERSTACKADDRESS
PARENCLOSE
NOTEQUALS
FUNCID
PARENCLOSE
BRACKETOPEN
//  mark end of function 
MEM_ARRAYINSERT
PARENOPEN
POSARR
COMMA
POS
PARENCLOSE
SEMICOLON
MEM_ARRAYINSERT
PARENOPEN
TOKENARRAY
COMMA
MINUS
INTEGER(1)
PARENCLOSE
SEMICOLON
MEM_ARRAYINSERT
PARENOPEN
PARAMARRAY
COMMA
MINUS
INTEGER(1)
PARENCLOSE
SEMICOLON
RETURN
SEMICOLON
BRACKETCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
MEM_STACKPOS
PERIOD
POSITION
ASSIGN
LOOP
SEMICOLON
BRACKETCLOSE
SEMICOLON
// --------------------------------------
//    Trace calculation of an argument
//    back to its beginning
// --------------------------------------
// Helperfunction: Trace the origin of one param:
FUNC
INT
MEMINT_TRACEPARAMETER
PARENOPEN
VAR
INT
POS
COMMA
VAR
INT
TOKENARR
COMMA
VAR
INT
PARAMARR
PARENCLOSE
BRACKETOPEN
//  assert: tokenArr is an array of parser tokens.\n     * pos is an index into this array, pointing to the token\n     * where a parameter is expected.\n     * I will return the index of the token where the calculation\n     * for this parameter starts. 
VAR
INT
PARAMSNEEDED
SEMICOLON
PARAMSNEEDED
ASSIGN
INTEGER(1)
SEMICOLON
VAR
INT
LOOP
SEMICOLON
LOOP
ASSIGN
MEM_STACKPOS
PERIOD
POSITION
SEMICOLON
IF
PARENOPEN
POS
EQUALS
INTEGER(0)
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"MEMINT_TraceParameter: The parameter was pushed outside the function."
PARENCLOSE
SEMICOLON
RETURN
MINUS
INTEGER(1)
SEMICOLON
BRACKETCLOSE
SEMICOLON
POS
MINUSASSIGN
INTEGER(1)
SEMICOLON
VAR
INT
TOK
SEMICOLON
TOK
ASSIGN
MEM_ARRAYREAD
PARENOPEN
TOKENARR
COMMA
POS
PARENCLOSE
SEMICOLON
IF
PARENOPEN
TOK
EQUALS
ZPAR_TOK_PUSHINT
OR
TOK
EQUALS
ZPAR_TOK_PUSHVAR
OR
TOK
EQUALS
ZPAR_TOK_PUSH_ARRAYVAR
OR
TOK
EQUALS
ZPAR_TOK_PUSHINST
PARENCLOSE
BRACKETOPEN
PARAMSNEEDED
MINUSASSIGN
INTEGER(1)
SEMICOLON
BRACKETCLOSE
ELSE
IF
PARENOPEN
TOK
GREATEREQUALS
ZPAR_TOK_ASSIGNSTR
AND
TOK
LOWEREQUALS
ZPAR_TOK_ASSIGNINST
PARENCLOSE
OR
PARENOPEN
TOK
EQUALS
ZPAR_OP_IS
PARENCLOSE
OR
PARENOPEN
TOK
LOWEREQUALS
ZPAR_OP_ISDIV
AND
TOK
GREATEREQUALS
ZPAR_OP_ISPLUS
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"MEMINT_TraceParameter: Assignment within expression that is expected to produce non-void result. This does not make sense."
PARENCLOSE
SEMICOLON
PARAMSNEEDED
PLUSASSIGN
INTEGER(2)
SEMICOLON
BRACKETCLOSE
ELSE
IF
PARENOPEN
TOK
EQUALS
ZPAR_TOK_CALL
OR
TOK
EQUALS
ZPAR_TOK_CALLEXTERN
PARENCLOSE
BRACKETOPEN
VAR
ZCPAR_SYMBOL
SYMB
SEMICOLON
VAR
INT
SYMBID
SEMICOLON
IF
PARENOPEN
TOK
EQUALS
ZPAR_TOK_CALL
PARENCLOSE
BRACKETOPEN
SYMBID
ASSIGN
MEM_GETFUNCIDBYOFFSET
PARENOPEN
MEM_ARRAYREAD
PARENOPEN
PARAMARR
COMMA
POS
PARENCLOSE
PARENCLOSE
SEMICOLON
BRACKETCLOSE
ELSE
BRACKETOPEN
SYMBID
ASSIGN
MEM_ARRAYREAD
PARENOPEN
PARAMARR
COMMA
POS
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
SYMB
ASSIGN
_^
PARENOPEN
MEM_GETSYMBOLBYINDEX
PARENOPEN
SYMBID
PARENCLOSE
PARENCLOSE
SEMICOLON
PARAMSNEEDED
PLUSASSIGN
SYMB
PERIOD
BITFIELD
BITAND
ZCPAR_SYMBOL_BITFIELD_ELE
SEMICOLON
//  need to calculate the parameters 
PARAMSNEEDED
MINUSASSIGN
SYMB
PERIOD
OFFSET
NOTEQUALS
INTEGER(0)
SEMICOLON
// != 0 ==> return value!
BRACKETCLOSE
ELSE
IF
PARENOPEN
TOK
GREATEREQUALS
ZPAR_OP_UNARY
AND
TOK
LOWEREQUALS
ZPAR_OP_MAX
PARENCLOSE
OR
PARENOPEN
TOK
EQUALS
ZPAR_TOK_SETINSTANCE
PARENCLOSE
BRACKETOPEN
//  nothing, unary operators have no effective parameter consumption\n         * zPAR_TOK_SETINSTANCE does not either 
BRACKETCLOSE
ELSE
IF
PARENOPEN
TOK
LOWEREQUALS
ZPAR_OP_HIGHER_EQ
PARENCLOSE
BRACKETOPEN
PARAMSNEEDED
PLUSASSIGN
INTEGER(1)
SEMICOLON
// binary operations, two in, one out.
BRACKETCLOSE
ELSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"MEMINT_TraceParameter: Invalid token!"
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
IF
PARENOPEN
PARAMSNEEDED
EQUALS
INTEGER(0)
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
POS
GREATER
INTEGER(0)
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
MEM_ARRAYREAD
PARENOPEN
TOKENARR
COMMA
POS
MINUS
INTEGER(1)
PARENCLOSE
EQUALS
ZPAR_TOK_SETINSTANCE
PARENCLOSE
BRACKETOPEN
POS
MINUSASSIGN
INTEGER(1)
SEMICOLON
// dont forget this token, it is important
BRACKETCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
//  good, this is the point 
RETURN
POS
SEMICOLON
BRACKETCLOSE
SEMICOLON
MEM_STACKPOS
PERIOD
POSITION
ASSIGN
LOOP
SEMICOLON
BRACKETCLOSE
SEMICOLON
// --------------------------------------
//   Patch function:
//     Scan function and replace calls to
//     label, goto and while with
//     appropriate tokens that handle
//     the situation correctly
// --------------------------------------
// For printing only
FUNC
STRING
MEMINT_GETLABELNAME
PARENOPEN
VAR
INT
LABELVALUE
PARENCLOSE
BRACKETOPEN
//  alchemy: is the constant a symbol index or a plain constant? 
IF
PARENOPEN
INTEGER(1000)
LOWER
LABELVALUE
AND
LABELVALUE
LOWER
MEM_PARSER
PERIOD
SYMTAB_TABLE_NUMINARRAY
PARENCLOSE
BRACKETOPEN
VAR
ZCPAR_SYMBOL
SYMB
SEMICOLON
SYMB
ASSIGN
_^
PARENOPEN
MEM_READINTARRAY
PARENOPEN
CONTENTSYMBOLTABLEADDRESS
COMMA
LABELVALUE
PARENCLOSE
PARENCLOSE
SEMICOLON
RETURN
SYMB
PERIOD
NAME
SEMICOLON
BRACKETCLOSE
ELSE
BRACKETOPEN
RETURN
INTTOSTRING
PARENOPEN
LABELVALUE
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEMINT_PREPARELOOPSANDJUMPS
PARENOPEN
VAR
INT
STACKPOS
PARENCLOSE
BRACKETOPEN
VAR
INT
TOKENARR
SEMICOLON
TOKENARR
ASSIGN
MEM_ARRAYCREATE
PARENOPEN
PARENCLOSE
SEMICOLON
VAR
INT
PARAMARR
SEMICOLON
PARAMARR
ASSIGN
MEM_ARRAYCREATE
PARENOPEN
PARENCLOSE
SEMICOLON
VAR
INT
POSARR
SEMICOLON
POSARR
ASSIGN
MEM_ARRAYCREATE
PARENOPEN
PARENCLOSE
SEMICOLON
VAR
INT
SIZE
SEMICOLON
MEMINT_TOKENIZEFUNCTION
PARENOPEN
MEM_GETFUNCIDBYOFFSET
PARENOPEN
STACKPOS
PARENCLOSE
COMMA
TOKENARR
COMMA
PARAMARR
COMMA
POSARR
PARENCLOSE
SEMICOLON
SIZE
ASSIGN
MEM_ARRAYSIZE
PARENOPEN
POSARR
PARENCLOSE
SEMICOLON
//  all have the same size 
//  find all Labels and gotos 
VAR
INT
LABELFUNC
SEMICOLON
LABELFUNC
ASSIGN
MEM_GETFUNCOFFSET
PARENOPEN
MEM_LABEL
PARENCLOSE
SEMICOLON
VAR
INT
LABELSARR
SEMICOLON
LABELSARR
ASSIGN
MEM_ARRAYCREATE
PARENOPEN
PARENCLOSE
SEMICOLON
VAR
INT
LABELPOSARR
SEMICOLON
LABELPOSARR
ASSIGN
MEM_ARRAYCREATE
PARENOPEN
PARENCLOSE
SEMICOLON
//  position after the label 
VAR
INT
GOTOFUNC
SEMICOLON
GOTOFUNC
ASSIGN
MEM_GETFUNCOFFSET
PARENOPEN
MEM_GOTO
PARENCLOSE
SEMICOLON
VAR
INT
GOTOARR
SEMICOLON
GOTOARR
ASSIGN
MEM_ARRAYCREATE
PARENOPEN
PARENCLOSE
SEMICOLON
VAR
INT
GOTOPOSARR
SEMICOLON
GOTOPOSARR
ASSIGN
MEM_ARRAYCREATE
PARENOPEN
PARENCLOSE
SEMICOLON
//  position before the parameter push 
VAR
INT
USEDLABELS
SEMICOLON
USEDLABELS
ASSIGN
MEM_ARRAYCREATE
PARENOPEN
PARENCLOSE
SEMICOLON
VAR
INT
I
SEMICOLON
I
ASSIGN
INTEGER(0)
SEMICOLON
VAR
INT
LOOP
SEMICOLON
LOOP
ASSIGN
MEM_STACKPOS
PERIOD
POSITION
SEMICOLON
IF
PARENOPEN
I
LOWER
SIZE
PARENCLOSE
BRACKETOPEN
VAR
INT
TYPE
SEMICOLON
CONST
INT
GOTO
ASSIGN
INTEGER(1)
SEMICOLON
CONST
INT
LABEL
ASSIGN
INTEGER(2)
SEMICOLON
IF
PARENOPEN
MEM_ARRAYREAD
PARENOPEN
TOKENARR
COMMA
I
PARENCLOSE
NOTEQUALS
ZPAR_TOK_CALL
PARENCLOSE
BRACKETOPEN
TYPE
ASSIGN
INTEGER(0)
SEMICOLON
BRACKETCLOSE
ELSE
IF
PARENOPEN
MEM_ARRAYREAD
PARENOPEN
PARAMARR
COMMA
I
PARENCLOSE
EQUALS
GOTOFUNC
PARENCLOSE
BRACKETOPEN
TYPE
ASSIGN
GOTO
SEMICOLON
BRACKETCLOSE
ELSE
IF
PARENOPEN
MEM_ARRAYREAD
PARENOPEN
PARAMARR
COMMA
I
PARENCLOSE
EQUALS
LABELFUNC
PARENCLOSE
BRACKETOPEN
TYPE
ASSIGN
LABEL
SEMICOLON
BRACKETCLOSE
ELSE
BRACKETOPEN
TYPE
ASSIGN
INTEGER(0)
SEMICOLON
BRACKETCLOSE
SEMICOLON
IF
PARENOPEN
TYPE
PARENCLOSE
BRACKETOPEN
//  assert: i > 0 
VAR
INT
LABELVALUE
SEMICOLON
VAR
INT
PUSHINGTOK
SEMICOLON
PUSHINGTOK
ASSIGN
MEM_ARRAYREAD
PARENOPEN
TOKENARR
COMMA
I
MINUS
INTEGER(1)
PARENCLOSE
SEMICOLON
IF
PARENOPEN
PUSHINGTOK
EQUALS
ZPAR_TOK_PUSHINT
PARENCLOSE
BRACKETOPEN
LABELVALUE
ASSIGN
MEM_ARRAYREAD
PARENOPEN
PARAMARR
COMMA
I
MINUS
INTEGER(1)
PARENCLOSE
SEMICOLON
BRACKETCLOSE
ELSE
IF
PARENOPEN
PUSHINGTOK
EQUALS
ZPAR_TOK_PUSHVAR
PARENCLOSE
BRACKETOPEN
//  the syntax check guarantees that an integer was pusht here 
LABELVALUE
ASSIGN
MEM_ARRAYREAD
PARENOPEN
PARAMARR
COMMA
I
MINUS
INTEGER(1)
PARENCLOSE
SEMICOLON
//  this is a symbol index 
VAR
ZCPAR_SYMBOL
SYMB
SEMICOLON
SYMB
ASSIGN
_^
PARENOPEN
MEM_READINTARRAY
PARENOPEN
CONTENTSYMBOLTABLEADDRESS
COMMA
LABELVALUE
PARENCLOSE
PARENCLOSE
SEMICOLON
LABELVALUE
ASSIGN
SYMB
PERIOD
CONTENT
SEMICOLON
BRACKETCLOSE
ELSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"MEMINT_PrepareLoopsAndJumps: Invalid label found. The parameters for MEM_Goto and MEM_Label must be a constant!"
PARENCLOSE
SEMICOLON
I
PLUSASSIGN
INTEGER(1)
SEMICOLON
MEM_STACKPOS
PERIOD
POSITION
ASSIGN
LOOP
SEMICOLON
BRACKETCLOSE
SEMICOLON
IF
PARENOPEN
TYPE
EQUALS
LABEL
PARENCLOSE
BRACKETOPEN
MEM_ARRAYPUSH
PARENOPEN
LABELSARR
COMMA
LABELVALUE
PARENCLOSE
SEMICOLON
MEM_ARRAYPUSH
PARENOPEN
LABELPOSARR
COMMA
MEM_ARRAYREAD
PARENOPEN
POSARR
COMMA
I
PLUS
INTEGER(1)
PARENCLOSE
PARENCLOSE
SEMICOLON
//  note: There is always a return after me 
BRACKETCLOSE
ELSE
BRACKETOPEN
MEM_ARRAYPUSH
PARENOPEN
GOTOARR
COMMA
LABELVALUE
PARENCLOSE
SEMICOLON
MEM_ARRAYPUSH
PARENOPEN
GOTOPOSARR
COMMA
MEM_ARRAYREAD
PARENOPEN
POSARR
COMMA
I
MINUS
INTEGER(1)
PARENCLOSE
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
I
PLUSASSIGN
INTEGER(1)
SEMICOLON
MEM_STACKPOS
PERIOD
POSITION
ASSIGN
LOOP
SEMICOLON
BRACKETCLOSE
SEMICOLON
//  make all gotos to jumps 
I
ASSIGN
INTEGER(0)
SEMICOLON
LOOP
ASSIGN
MEM_STACKPOS
PERIOD
POSITION
SEMICOLON
IF
PARENOPEN
I
LOWER
MEM_ARRAYSIZE
PARENOPEN
GOTOARR
PARENCLOSE
PARENCLOSE
BRACKETOPEN
LABELVALUE
ASSIGN
MEM_ARRAYREAD
PARENOPEN
GOTOARR
COMMA
I
PARENCLOSE
SEMICOLON
VAR
INT
GOTOPOS
SEMICOLON
GOTOPOS
ASSIGN
MEM_ARRAYREAD
PARENOPEN
GOTOPOSARR
COMMA
I
PARENCLOSE
SEMICOLON
VAR
INT
LABELINDEX
SEMICOLON
LABELINDEX
ASSIGN
MEM_ARRAYINDEXOF
PARENOPEN
LABELSARR
COMMA
LABELVALUE
PARENCLOSE
SEMICOLON
VAR
INT
LABELPOS
SEMICOLON
IF
PARENOPEN
LABELINDEX
EQUALS
MINUS
INTEGER(1)
PARENCLOSE
BRACKETOPEN
VAR
STRING
ERR
SEMICOLON
ERR
ASSIGN
"MEMINT_PrepareLoopsAndJumps: Goto to non-existing label found: "
SEMICOLON
ERR
ASSIGN
CONCATSTRINGS
PARENOPEN
ERR
COMMA
MEMINT_GETLABELNAME
PARENOPEN
LABELVALUE
PARENCLOSE
PARENCLOSE
SEMICOLON
ERR
ASSIGN
CONCATSTRINGS
PARENOPEN
ERR
COMMA
"."
PARENCLOSE
SEMICOLON
MEM_ERROR
PARENOPEN
ERR
PARENCLOSE
SEMICOLON
LABELPOS
ASSIGN
GOTOPOS
PLUS
INTEGER(10)
SEMICOLON
BRACKETCLOSE
ELSE
BRACKETOPEN
LABELPOS
ASSIGN
MEM_ARRAYREAD
PARENOPEN
LABELPOSARR
COMMA
LABELINDEX
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
LABELPOS
MINUSASSIGN
CURRPARSERSTACKADDRESS
SEMICOLON
//  relative to stack start 
//  overwrite parameter push and call to MEM_Goto 
MEM_WRITEBYTE
PARENOPEN
GOTOPOS
COMMA
ZPAR_TOK_JUMP
PARENCLOSE
SEMICOLON
GOTOPOS
PLUSASSIGN
INTEGER(1)
SEMICOLON
MEM_WRITEINT
PARENOPEN
GOTOPOS
COMMA
LABELPOS
PARENCLOSE
SEMICOLON
GOTOPOS
PLUSASSIGN
INTEGER(4)
SEMICOLON
MEM_WRITEBYTE
PARENOPEN
GOTOPOS
COMMA
ZPAR_TOK_JUMP
PARENCLOSE
SEMICOLON
GOTOPOS
PLUSASSIGN
INTEGER(1)
SEMICOLON
MEM_WRITEINT
PARENOPEN
GOTOPOS
COMMA
LABELPOS
PARENCLOSE
SEMICOLON
GOTOPOS
PLUSASSIGN
INTEGER(4)
SEMICOLON
MEM_ARRAYINSERT
PARENOPEN
USEDLABELS
COMMA
LABELVALUE
PARENCLOSE
SEMICOLON
I
PLUSASSIGN
INTEGER(1)
SEMICOLON
MEM_STACKPOS
PERIOD
POSITION
ASSIGN
LOOP
SEMICOLON
BRACKETCLOSE
SEMICOLON
//  consistency check: All Labels used? Labels declared multiple times? 
LOOP
ASSIGN
MEM_STACKPOS
PERIOD
POSITION
SEMICOLON
IF
PARENOPEN
MEM_ARRAYSIZE
PARENOPEN
LABELSARR
PARENCLOSE
PARENCLOSE
BRACKETOPEN
LABELVALUE
ASSIGN
MEM_ARRAYREAD
PARENOPEN
LABELSARR
COMMA
INTEGER(0)
PARENCLOSE
SEMICOLON
MEM_ARRAYREMOVEINDEX
PARENOPEN
LABELSARR
COMMA
INTEGER(0)
PARENCLOSE
SEMICOLON
//  discard this entry 
IF
PARENOPEN
MEM_ARRAYINDEXOF
PARENOPEN
LABELSARR
COMMA
LABELVALUE
PARENCLOSE
NOTEQUALS
MINUS
INTEGER(1)
PARENCLOSE
BRACKETOPEN
//  still in there? 
VAR
STRING
ERROR
SEMICOLON
ERROR
ASSIGN
"MEMINT_PrepareLoopsAndJumps: Label declared more than once: "
SEMICOLON
ERROR
ASSIGN
CONCATSTRINGS
PARENOPEN
ERROR
COMMA
MEMINT_GETLABELNAME
PARENOPEN
LABELVALUE
PARENCLOSE
PARENCLOSE
SEMICOLON
ERROR
ASSIGN
CONCATSTRINGS
PARENOPEN
ERROR
COMMA
"."
PARENCLOSE
SEMICOLON
MEM_ERROR
PARENOPEN
ERROR
PARENCLOSE
SEMICOLON
BRACKETCLOSE
ELSE
IF
PARENOPEN
MEM_ARRAYINDEXOF
PARENOPEN
USEDLABELS
COMMA
LABELVALUE
PARENCLOSE
EQUALS
MINUS
INTEGER(1)
PARENCLOSE
BRACKETOPEN
ERROR
ASSIGN
"MEMINT_PrepareLoopsAndJumps: Unused Label: "
SEMICOLON
ERROR
ASSIGN
CONCATSTRINGS
PARENOPEN
ERROR
COMMA
MEMINT_GETLABELNAME
PARENOPEN
LABELVALUE
PARENCLOSE
PARENCLOSE
SEMICOLON
ERROR
ASSIGN
CONCATSTRINGS
PARENOPEN
ERROR
COMMA
"."
PARENCLOSE
SEMICOLON
MEM_WARN
PARENOPEN
ERROR
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
MEM_STACKPOS
PERIOD
POSITION
ASSIGN
LOOP
SEMICOLON
BRACKETCLOSE
SEMICOLON
MEM_ARRAYFREE
PARENOPEN
LABELSARR
PARENCLOSE
SEMICOLON
MEM_ARRAYFREE
PARENOPEN
LABELPOSARR
PARENCLOSE
SEMICOLON
MEM_ARRAYFREE
PARENOPEN
GOTOARR
PARENCLOSE
SEMICOLON
MEM_ARRAYFREE
PARENOPEN
GOTOPOSARR
PARENCLOSE
SEMICOLON
MEM_ARRAYFREE
PARENOPEN
USEDLABELS
PARENCLOSE
SEMICOLON
//  Handle while 
VAR
INT
WHILEOFFSET
SEMICOLON
WHILEOFFSET
ASSIGN
MEM_GETFUNCOFFSET
PARENOPEN
WHILE
PARENCLOSE
SEMICOLON
VAR
INT
REPEATOFFSET
SEMICOLON
REPEATOFFSET
ASSIGN
MEM_GETFUNCOFFSET
PARENOPEN
REPEAT
PARENCLOSE
SEMICOLON
VAR
INT
ENDID
SEMICOLON
ENDID
ASSIGN
MEM_FINDPARSERSYMBOL
PARENOPEN
"END"
PARENCLOSE
SEMICOLON
VAR
INT
BREAKID
SEMICOLON
BREAKID
ASSIGN
MEM_FINDPARSERSYMBOL
PARENOPEN
"BREAK"
PARENCLOSE
SEMICOLON
VAR
INT
CONTINUEID
SEMICOLON
CONTINUEID
ASSIGN
MEM_FINDPARSERSYMBOL
PARENOPEN
"CONTINUE"
PARENCLOSE
SEMICOLON
VAR
INT
LOOPTYPE
SEMICOLON
LOOPTYPE
ASSIGN
MINUS
INTEGER(1)
SEMICOLON
CONST
INT
W
ASSIGN
INTEGER(0)
SEMICOLON
CONST
INT
R
ASSIGN
INTEGER(1)
SEMICOLON
VAR
INT
CONTTARGET
SEMICOLON
CONTTARGET
ASSIGN
MINUS
INTEGER(1)
SEMICOLON
VAR
INT
LOOPSTACK
SEMICOLON
LOOPSTACK
ASSIGN
MEM_ARRAYCREATE
PARENOPEN
PARENCLOSE
SEMICOLON
//  contains saved data when nesting loops 
VAR
INT
JUMPENDSTACK
SEMICOLON
JUMPENDSTACK
ASSIGN
MEM_ARRAYCREATE
PARENOPEN
PARENCLOSE
SEMICOLON
//  position of break statements and -1 as seperator for nesting 
I
ASSIGN
INTEGER(0)
SEMICOLON
LOOP
ASSIGN
MEM_STACKPOS
PERIOD
POSITION
SEMICOLON
IF
PARENOPEN
I
LOWER
SIZE
PARENCLOSE
BRACKETOPEN
VAR
INT
TOK
SEMICOLON
TOK
ASSIGN
MEM_ARRAYREAD
PARENOPEN
TOKENARR
COMMA
I
PARENCLOSE
SEMICOLON
VAR
INT
PARAM
SEMICOLON
PARAM
ASSIGN
MEM_ARRAYREAD
PARENOPEN
PARAMARR
COMMA
I
PARENCLOSE
SEMICOLON
VAR
INT
POS
SEMICOLON
POS
ASSIGN
MEM_ARRAYREAD
PARENOPEN
POSARR
COMMA
I
PARENCLOSE
SEMICOLON
IF
PARENOPEN
TOK
EQUALS
ZPAR_TOK_CALL
AND
PARAM
EQUALS
WHILEOFFSET
PARENCLOSE
BRACKETOPEN
MEM_ARRAYPUSH
PARENOPEN
LOOPSTACK
COMMA
LOOPTYPE
PARENCLOSE
SEMICOLON
MEM_ARRAYPUSH
PARENOPEN
LOOPSTACK
COMMA
CONTTARGET
PARENCLOSE
SEMICOLON
MEM_WRITEBYTE
PARENOPEN
POS
COMMA
ZPAR_TOK_JUMPF
PARENCLOSE
SEMICOLON
CONTTARGET
ASSIGN
MEM_ARRAYREAD
PARENOPEN
POSARR
COMMA
MEMINT_TRACEPARAMETER
PARENOPEN
I
COMMA
TOKENARR
COMMA
PARAMARR
PARENCLOSE
PARENCLOSE
SEMICOLON
LOOPTYPE
ASSIGN
W
SEMICOLON
MEM_ARRAYPUSH
PARENOPEN
JUMPENDSTACK
COMMA
MINUS
INTEGER(1)
PARENCLOSE
SEMICOLON
//  seperator 
MEM_ARRAYPUSH
PARENOPEN
JUMPENDSTACK
COMMA
POS
PLUS
INTEGER(1)
PARENCLOSE
SEMICOLON
//  insert the end-Pos of the loop here, as soon as I know it 
BRACKETCLOSE
ELSE
IF
PARENOPEN
TOK
EQUALS
ZPAR_TOK_CALL
AND
PARAM
EQUALS
REPEATOFFSET
PARENCLOSE
BRACKETOPEN
//  for repeat I need a new code segment to jump into 
MEM_ARRAYPUSH
PARENOPEN
LOOPSTACK
COMMA
LOOPTYPE
PARENCLOSE
SEMICOLON
MEM_ARRAYPUSH
PARENOPEN
LOOPSTACK
COMMA
CONTTARGET
PARENCLOSE
SEMICOLON
LOOPTYPE
ASSIGN
R
SEMICOLON
VAR
INT
CODE
SEMICOLON
CODE
ASSIGN
MEM_ALLOC
PARENOPEN
INTEGER(30)
PARENCLOSE
SEMICOLON
//  jump to the new code 
MEM_WRITEBYTE
PARENOPEN
POS
COMMA
ZPAR_TOK_JUMP
PARENCLOSE
SEMICOLON
MEM_WRITEINT
PARENOPEN
POS
PLUS
INTEGER(1)
COMMA
CODE
MINUS
CURRPARSERSTACKADDRESS
PARENCLOSE
SEMICOLON
//  create a MEMINT_RepeatData 
VAR
INT
DATAPTR
SEMICOLON
DATAPTR
ASSIGN
MEM_ALLOC
PARENOPEN
INTEGER(8)
PARENCLOSE
SEMICOLON
VAR
INT
ENTRYFIDDLER
SEMICOLON
ENTRYFIDDLER
ASSIGN
MEM_GETFUNCOFFSET
PARENOPEN
MEMINT_REPEATENTRYFIDDLE
PARENCLOSE
SEMICOLON
VAR
INT
REDOCHECKER
SEMICOLON
REDOCHECKER
ASSIGN
MEM_GETFUNCOFFSET
PARENOPEN
MEMINT_REPEATREDOCHECK
PARENCLOSE
SEMICOLON
//  let my entry handler fill the variable with 0 and remember the limit 
MEM_WRITEBYTE
PARENOPEN
CODE
COMMA
ZPAR_TOK_PUSHINT
PARENCLOSE
SEMICOLON
CODE
PLUSASSIGN
INTEGER(1)
SEMICOLON
MEM_WRITEINT
PARENOPEN
CODE
COMMA
DATAPTR
PARENCLOSE
SEMICOLON
CODE
PLUSASSIGN
INTEGER(4)
SEMICOLON
MEM_WRITEBYTE
PARENOPEN
CODE
COMMA
ZPAR_TOK_CALL
PARENCLOSE
SEMICOLON
CODE
PLUSASSIGN
INTEGER(1)
SEMICOLON
MEM_WRITEINT
PARENOPEN
CODE
COMMA
ENTRYFIDDLER
PARENCLOSE
SEMICOLON
CODE
PLUSASSIGN
INTEGER(4)
SEMICOLON
//  directly after that check for valid bounds.\n             * this is where a continue jumps to 
CONTTARGET
ASSIGN
CODE
SEMICOLON
MEM_WRITEBYTE
PARENOPEN
CODE
COMMA
ZPAR_TOK_PUSHINT
PARENCLOSE
SEMICOLON
CODE
PLUSASSIGN
INTEGER(1)
SEMICOLON
MEM_WRITEINT
PARENOPEN
CODE
COMMA
DATAPTR
PARENCLOSE
SEMICOLON
CODE
PLUSASSIGN
INTEGER(4)
SEMICOLON
MEM_WRITEBYTE
PARENOPEN
CODE
COMMA
ZPAR_TOK_CALL
PARENCLOSE
SEMICOLON
CODE
PLUSASSIGN
INTEGER(1)
SEMICOLON
MEM_WRITEINT
PARENOPEN
CODE
COMMA
REDOCHECKER
PARENCLOSE
SEMICOLON
CODE
PLUSASSIGN
INTEGER(4)
SEMICOLON
//  jump to the end if the redochecker says so 
MEM_WRITEBYTE
PARENOPEN
CODE
COMMA
ZPAR_TOK_JUMPF
PARENCLOSE
SEMICOLON
CODE
PLUSASSIGN
INTEGER(1)
SEMICOLON
MEM_ARRAYPUSH
PARENOPEN
JUMPENDSTACK
COMMA
MINUS
INTEGER(1)
PARENCLOSE
SEMICOLON
//  seperator 
MEM_ARRAYPUSH
PARENOPEN
JUMPENDSTACK
COMMA
CODE
PARENCLOSE
SEMICOLON
//  insert the end-Pos of the loop here, as soon as I know it 
CODE
PLUSASSIGN
INTEGER(4)
SEMICOLON
//  If i chose to continue, unconditional jump back to the code: 
MEM_WRITEBYTE
PARENOPEN
CODE
COMMA
ZPAR_TOK_JUMP
PARENCLOSE
SEMICOLON
CODE
PLUSASSIGN
INTEGER(1)
SEMICOLON
MEM_WRITEINT
PARENOPEN
CODE
COMMA
POS
PLUS
INTEGER(5)
MINUS
CURRPARSERSTACKADDRESS
PARENCLOSE
SEMICOLON
CODE
PLUSASSIGN
INTEGER(4)
SEMICOLON
BRACKETCLOSE
ELSE
IF
PARENOPEN
TOK
EQUALS
ZPAR_TOK_PUSHVAR
AND
PARAM
EQUALS
ENDID
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
LOOPTYPE
EQUALS
MINUS
INTEGER(1)
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"MEMINT_PrepareLoopsAndJumps: end found outside of loop!"
PARENCLOSE
SEMICOLON
I
PLUSASSIGN
INTEGER(1)
SEMICOLON
MEM_STACKPOS
PERIOD
POSITION
ASSIGN
LOOP
SEMICOLON
BRACKETCLOSE
SEMICOLON
MEM_WRITEBYTE
PARENOPEN
POS
COMMA
ZPAR_TOK_JUMP
PARENCLOSE
SEMICOLON
MEM_WRITEINT
PARENOPEN
POS
PLUS
INTEGER(1)
COMMA
CONTTARGET
MINUS
CURRPARSERSTACKADDRESS
PARENCLOSE
SEMICOLON
//  handle all the breaks now: 
VAR
INT
BRKLOOP
SEMICOLON
BRKLOOP
ASSIGN
MEM_STACKPOS
PERIOD
POSITION
SEMICOLON
VAR
INT
JMPENDPOS
SEMICOLON
JMPENDPOS
ASSIGN
MEM_ARRAYPOP
PARENOPEN
JUMPENDSTACK
PARENCLOSE
SEMICOLON
IF
PARENOPEN
JMPENDPOS
NOTEQUALS
MINUS
INTEGER(1)
PARENCLOSE
BRACKETOPEN
//  this is the guardian 
MEM_WRITEINT
PARENOPEN
JMPENDPOS
COMMA
POS
PLUS
INTEGER(5)
MINUS
CURRPARSERSTACKADDRESS
PARENCLOSE
SEMICOLON
MEM_STACKPOS
PERIOD
POSITION
ASSIGN
BRKLOOP
SEMICOLON
BRACKETCLOSE
SEMICOLON
CONTTARGET
ASSIGN
MEM_ARRAYPOP
PARENOPEN
LOOPSTACK
PARENCLOSE
SEMICOLON
LOOPTYPE
ASSIGN
MEM_ARRAYPOP
PARENOPEN
LOOPSTACK
PARENCLOSE
SEMICOLON
BRACKETCLOSE
ELSE
IF
PARENOPEN
TOK
EQUALS
ZPAR_TOK_PUSHVAR
AND
PARAM
EQUALS
BREAKID
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
LOOPTYPE
EQUALS
MINUS
INTEGER(1)
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"MEMINT_PrepareLoopsAndJumps: break found outside of loop!"
PARENCLOSE
SEMICOLON
BRACKETCLOSE
ELSE
BRACKETOPEN
MEM_WRITEBYTE
PARENOPEN
POS
COMMA
ZPAR_TOK_JUMP
PARENCLOSE
SEMICOLON
MEM_ARRAYPUSH
PARENOPEN
JUMPENDSTACK
COMMA
POS
PLUS
INTEGER(1)
PARENCLOSE
SEMICOLON
//  insert the end address here as soon as I know it 
BRACKETCLOSE
SEMICOLON
BRACKETCLOSE
ELSE
IF
PARENOPEN
TOK
EQUALS
ZPAR_TOK_PUSHVAR
AND
PARAM
EQUALS
CONTINUEID
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
LOOPTYPE
EQUALS
MINUS
INTEGER(1)
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"MEMINT_PrepareLoopsAndJumps: continue found outside of loop!"
PARENCLOSE
SEMICOLON
BRACKETCLOSE
ELSE
BRACKETOPEN
MEM_WRITEBYTE
PARENOPEN
POS
COMMA
ZPAR_TOK_JUMP
PARENCLOSE
SEMICOLON
MEM_WRITEINT
PARENOPEN
POS
PLUS
INTEGER(1)
COMMA
CONTTARGET
MINUS
CURRPARSERSTACKADDRESS
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
I
PLUSASSIGN
INTEGER(1)
SEMICOLON
MEM_STACKPOS
PERIOD
POSITION
ASSIGN
LOOP
SEMICOLON
BRACKETCLOSE
SEMICOLON
IF
PARENOPEN
LOOPTYPE
NOTEQUALS
MINUS
INTEGER(1)
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"MEMINT_PrepareLoopsAndJumps: Loop not closed with 'end;'."
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
MEM_ARRAYFREE
PARENOPEN
LOOPSTACK
PARENCLOSE
SEMICOLON
MEM_ARRAYFREE
PARENOPEN
JUMPENDSTACK
PARENCLOSE
SEMICOLON
//  cleanup 
MEM_ARRAYFREE
PARENOPEN
TOKENARR
PARENCLOSE
SEMICOLON
MEM_ARRAYFREE
PARENOPEN
PARAMARR
PARENCLOSE
SEMICOLON
MEM_ARRAYFREE
PARENOPEN
POSARR
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// --------------------------------------
//    while
// --------------------------------------
CLASS
C_LABEL
BRACKETOPEN
BRACKETCLOSE
SEMICOLON
//  so it is possible to declare var C_Label lbl 
CONST
INT
BREAK
ASSIGN
MINUS
INTEGER(42)
SEMICOLON
CONST
INT
CONTINUE
ASSIGN
MINUS
INTEGER(23)
SEMICOLON
CONST
INT
END
ASSIGN
MINUS
INTEGER(72)
SEMICOLON
FUNC
VOID
WHILE
PARENOPEN
VAR
INT
B
PARENCLOSE
BRACKETOPEN
//  consistency check 
VAR
INT
CALLEDFROM
SEMICOLON
CALLEDFROM
ASSIGN
MEM_GETCALLERSTACKPOS
PARENOPEN
PARENCLOSE
MINUS
INTEGER(5)
SEMICOLON
IF
PARENOPEN
MEM_READBYTE
PARENOPEN
CALLEDFROM
PLUS
CURRPARSERSTACKADDRESS
PARENCLOSE
NOTEQUALS
ZPAR_TOK_CALL
PARENCLOSE
OR
PARENOPEN
MEM_READINT
PARENOPEN
CALLEDFROM
PLUS
INTEGER(1)
PLUS
CURRPARSERSTACKADDRESS
PARENCLOSE
NOTEQUALS
MEM_GETFUNCOFFSET
PARENOPEN
WHILE
PARENCLOSE
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"while: While was called in an unorthodox way! This cannot be handled."
PARENCLOSE
SEMICOLON
RETURN
SEMICOLON
BRACKETCLOSE
SEMICOLON
MEMINT_PREPARELOOPSANDJUMPS
PARENOPEN
CALLEDFROM
PARENCLOSE
SEMICOLON
B
SEMICOLON
//  repush b 
MEM_SETCALLERSTACKPOS
PARENOPEN
CALLEDFROM
PARENCLOSE
SEMICOLON
//  get before the call to while which is now a jumpf 
BRACKETCLOSE
SEMICOLON
// --------------------------------------
//    label / goto
// --------------------------------------
FUNC
VOID
MEM_LABEL
PARENOPEN
VAR
INT
LBL
PARENCLOSE
BRACKETOPEN
BRACKETCLOSE
SEMICOLON
//  nothing to do 
FUNC
VOID
MEM_GOTO
PARENOPEN
VAR
INT
LBL
PARENCLOSE
BRACKETOPEN
VAR
INT
CALLEDFROM
SEMICOLON
CALLEDFROM
ASSIGN
MEM_GETCALLERSTACKPOS
PARENOPEN
PARENCLOSE
MINUS
INTEGER(5)
SEMICOLON
//  consistency check 
IF
PARENOPEN
MEM_READBYTE
PARENOPEN
CALLEDFROM
PLUS
CURRPARSERSTACKADDRESS
PARENCLOSE
NOTEQUALS
ZPAR_TOK_CALL
PARENCLOSE
OR
PARENOPEN
MEM_READINT
PARENOPEN
CALLEDFROM
PLUS
INTEGER(1)
PLUS
CURRPARSERSTACKADDRESS
PARENCLOSE
NOTEQUALS
MEM_GETFUNCOFFSET
PARENOPEN
MEM_GOTO
PARENCLOSE
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"MEM_Goto: MEM_Goto was called in an unorthodox way! This cannot be handled."
PARENCLOSE
SEMICOLON
RETURN
SEMICOLON
BRACKETCLOSE
SEMICOLON
MEMINT_PREPARELOOPSANDJUMPS
PARENOPEN
CALLEDFROM
PARENCLOSE
SEMICOLON
MEM_SETCALLERSTACKPOS
PARENOPEN
CALLEDFROM
PARENCLOSE
SEMICOLON
//  get before the call to MEM_Goto which is now a jump 
BRACKETCLOSE
SEMICOLON
// --------------------------------------
//    repeat
// --------------------------------------
FUNC
VOID
REPEAT
PARENOPEN
VAR
INT
VARIABLE
COMMA
VAR
INT
LIMIT
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"MEM_Repat was called before MEM_InitRepeat / MEM_InitAll"
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEMINT_REPEAT
PARENOPEN
PARENCLOSE
BRACKETOPEN
VAR
INT
CALLEDFROM
SEMICOLON
CALLEDFROM
ASSIGN
MEM_GETCALLERSTACKPOS
PARENOPEN
PARENCLOSE
MINUS
INTEGER(5)
SEMICOLON
//  consistency check 
IF
PARENOPEN
MEM_READBYTE
PARENOPEN
CALLEDFROM
PLUS
CURRPARSERSTACKADDRESS
PARENCLOSE
NOTEQUALS
ZPAR_TOK_CALL
PARENCLOSE
OR
PARENOPEN
MEM_READINT
PARENOPEN
CALLEDFROM
PLUS
INTEGER(1)
PLUS
CURRPARSERSTACKADDRESS
PARENCLOSE
NOTEQUALS
MEM_GETFUNCOFFSET
PARENOPEN
REPEAT
PARENCLOSE
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"repeat: repeat was called in an unorthodox way! This cannot be handled."
PARENCLOSE
SEMICOLON
RETURN
SEMICOLON
BRACKETCLOSE
SEMICOLON
MEMINT_PREPARELOOPSANDJUMPS
PARENOPEN
CALLEDFROM
PARENCLOSE
SEMICOLON
//  I left the two parameters on the stack, we can start 
MEM_SETCALLERSTACKPOS
PARENOPEN
CALLEDFROM
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEM_INITREPEAT
PARENOPEN
PARENCLOSE
BRACKETOPEN
CONST
INT
DONE
ASSIGN
INTEGER(0)
SEMICOLON
IF
PARENOPEN
NOT
DONE
PARENCLOSE
BRACKETOPEN
MEM_REPLACEFUNC
PARENOPEN
REPEAT
COMMA
MEMINT_REPEAT
PARENCLOSE
SEMICOLON
DONE
ASSIGN
TRUE
SEMICOLON
BRACKETCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
CLASS
MEMINT_REPEATDATA
BRACKETOPEN
VAR
INT
VARADR
SEMICOLON
VAR
INT
LIMIT
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEMINT_REPEATENTRYFIDDLE
PARENOPEN
//  var int VAR 
VAR
INT
LIMIT
COMMA
VAR
INT
LOOPDATA
PARENCLOSE
BRACKETOPEN
VAR
INT
TOK
SEMICOLON
TOK
ASSIGN
MEMINT_STACKPOPINSTASINT
PARENOPEN
PARENCLOSE
SEMICOLON
IF
PARENOPEN
TOK
NOTEQUALS
ZPAR_TOK_PUSHVAR
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"MEMINT_RepeatEntryFiddle: First Parameter given to MEM_Repeat is not an lValue (not modifiable)."
PARENCLOSE
SEMICOLON
RETURN
SEMICOLON
BRACKETCLOSE
SEMICOLON
VAR
INT
VARADR
SEMICOLON
VARADR
ASSIGN
MEMINT_STACKPOPINSTASINT
PARENOPEN
PARENCLOSE
SEMICOLON
MEM_WRITEINT
PARENOPEN
VARADR
COMMA
MINUS
INTEGER(1)
PARENCLOSE
SEMICOLON
// starts with 0 (will be incremented immediately)
MEM_WRITEINT
PARENOPEN
LOOPDATA
COMMA
VARADR
PARENCLOSE
SEMICOLON
//  the variable 
MEM_WRITEINT
PARENOPEN
LOOPDATA
PLUS
INTEGER(4)
COMMA
LIMIT
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
MEMINT_REPEATREDOCHECK
PARENOPEN
VAR
INT
LOOPDATA
PARENCLOSE
BRACKETOPEN
VAR
MEMINT_REPEATDATA
DATA
SEMICOLON
DATA
ASSIGN
_^
PARENOPEN
LOOPDATA
PARENCLOSE
SEMICOLON
VAR
INT
VAL
SEMICOLON
VAL
ASSIGN
MEM_READINT
PARENOPEN
DATA
PERIOD
VARADR
PARENCLOSE
SEMICOLON
VAL
PLUSASSIGN
INTEGER(1)
SEMICOLON
MEM_WRITEINT
PARENOPEN
DATA
PERIOD
VARADR
COMMA
VAL
PARENCLOSE
SEMICOLON
RETURN
VAL
LOWER
DATA
PERIOD
LIMIT
SEMICOLON
BRACKETCLOSE
SEMICOLON
// ######################################################
// 
//   Access Menu Objects
// 
// ######################################################
// \n    Leider werden manche Menüs jedesmal neu erzeugt (vom Script aus),\n    andere dagegen werden beim ersten mal nach dem Spielstart erzeugt und dann behalten.\n    Abhängig davon und von dem, was man eigentlich tun will, kann es nötig sein\n    in den Menüscripten Änderungen einzubringen (indem man\n    in den Variablen dort schreibt) oder es ist nötig sich das Menü\n    als Objekt zu holen und in dem fertigen Objekt selbst herumzuschmieren.\n
FUNC
INT
MEM_GETMENUBYSTRING
PARENOPEN
VAR
STRING
MENUNAME
PARENCLOSE
BRACKETOPEN
VAR
ZCARRAY
MENUS
SEMICOLON
MENUS
ASSIGN
_^
PARENOPEN
MEMINT_MENUARRAYOFFSET
PARENCLOSE
SEMICOLON
VAR
INT
POS
SEMICOLON
POS
ASSIGN
INTEGER(0)
SEMICOLON
VAR
INT
LOOPSTART
SEMICOLON
LOOPSTART
ASSIGN
MEM_STACKPOS
PERIOD
POSITION
SEMICOLON
IF
PARENOPEN
POS
GREATEREQUALS
MENUS
PERIOD
NUMINARRAY
PARENCLOSE
BRACKETOPEN
//  Liste durch und nichts gefunden? 
//  Warnung nervt:\n            MEM_Warn (ConcatStrings ("MEM_GetMenuByString: No Menu with the following name found: ", menuName));\n        
RETURN
INTEGER(0)
SEMICOLON
BRACKETCLOSE
SEMICOLON
VAR
INT
MENUADDR
SEMICOLON
MENUADDR
ASSIGN
MEM_READINTARRAY
PARENOPEN
MENUS
PERIOD
ARRAY
COMMA
POS
PARENCLOSE
SEMICOLON
VAR
ZCMENU
MENU
SEMICOLON
MENU
ASSIGN
_^
PARENOPEN
MENUADDR
PARENCLOSE
SEMICOLON
IF
PARENOPEN
HLP_STRCMP
PARENOPEN
MENU
PERIOD
NAME
COMMA
MENUNAME
PARENCLOSE
PARENCLOSE
BRACKETOPEN
RETURN
MENUADDR
SEMICOLON
BRACKETCLOSE
SEMICOLON
POS
PLUSASSIGN
INTEGER(1)
SEMICOLON
MEM_STACKPOS
PERIOD
POSITION
ASSIGN
LOOPSTART
SEMICOLON
BRACKETCLOSE
SEMICOLON
// --------------------------------------
//  MenuItem Zugriff
// --------------------------------------
//  Selbe Bemerkung wie zu Menüs 
FUNC
INT
MEM_GETMENUITEMBYSTRING
PARENOPEN
VAR
STRING
MENUITEMNAME
PARENCLOSE
BRACKETOPEN
VAR
ZCARRAY
MENUITEMS
SEMICOLON
MENUITEMS
ASSIGN
_^
PARENOPEN
MEMINT_MENUITEMARRAYADDRES
PARENCLOSE
SEMICOLON
VAR
INT
POS
SEMICOLON
POS
ASSIGN
INTEGER(0)
SEMICOLON
VAR
INT
LOOPSTART
SEMICOLON
LOOPSTART
ASSIGN
MEM_STACKPOS
PERIOD
POSITION
SEMICOLON
IF
PARENOPEN
POS
GREATEREQUALS
MENUITEMS
PERIOD
NUMINARRAY
PARENCLOSE
BRACKETOPEN
//  Liste durch und nichts gefunden? 
// Warnung rausgenommen: Die nervt extrem.
// MEM_Warn (ConcatStrings ("MEM_GetMenuItemByString: No Menu with the following name found: ", menuItemName));
RETURN
INTEGER(0)
SEMICOLON
BRACKETCLOSE
SEMICOLON
VAR
INT
MENUITEMADDR
SEMICOLON
MENUITEMADDR
ASSIGN
MEM_READINTARRAY
PARENOPEN
MENUITEMS
PERIOD
ARRAY
COMMA
POS
PARENCLOSE
SEMICOLON
VAR
ZCMENUITEM
MENUITEM
SEMICOLON
MENUITEM
ASSIGN
_^
PARENOPEN
MENUITEMADDR
PARENCLOSE
SEMICOLON
IF
PARENOPEN
HLP_STRCMP
PARENOPEN
MENUITEM
PERIOD
ID
COMMA
MENUITEMNAME
PARENCLOSE
PARENCLOSE
BRACKETOPEN
RETURN
MENUITEMADDR
SEMICOLON
BRACKETCLOSE
SEMICOLON
POS
PLUSASSIGN
INTEGER(1)
SEMICOLON
MEM_STACKPOS
PERIOD
POSITION
ASSIGN
LOOPSTART
SEMICOLON
BRACKETCLOSE
SEMICOLON
// ######################################################
// 
//   zCObjects
// 
// ######################################################
// ************************************************
//   Locate some commonly used objects
// ************************************************
INSTANCE
MEM_GAME
PARENOPEN
OCGAME
PARENCLOSE
SEMICOLON
INSTANCE
MEM_WORLD
PARENOPEN
OWORLD
PARENCLOSE
SEMICOLON
INSTANCE
MEM_TIMER
PARENOPEN
ZCTIMER
PARENCLOSE
SEMICOLON
INSTANCE
MEM_WORLDTIMER
PARENOPEN
OCWORLDTIMER
PARENCLOSE
SEMICOLON
INSTANCE
MEM_VOBTREE
PARENOPEN
ZCTREE
PARENCLOSE
SEMICOLON
INSTANCE
MEM_INFOMAN
PARENOPEN
OCINFOMANAGER
PARENCLOSE
SEMICOLON
INSTANCE
MEM_INFORMATIONMAN
PARENOPEN
OCINFORMATIONMANAGER
PARENCLOSE
SEMICOLON
INSTANCE
MEM_WAYNET
PARENOPEN
ZCWAYNET
PARENCLOSE
SEMICOLON
INSTANCE
MEM_CAMERA
PARENOPEN
ZCCAMERA
PARENCLOSE
SEMICOLON
INSTANCE
MEM_SKYCONTROLLER
PARENOPEN
ZCSKYCONTROLLER_OUTDOOR
PARENCLOSE
SEMICOLON
INSTANCE
MEM_SPAWNMANAGER
PARENOPEN
OCSPAWNMANAGER
PARENCLOSE
SEMICOLON
INSTANCE
MEM_GAMEMANANGER
PARENOPEN
CGAMEMANAGER
PARENCLOSE
SEMICOLON
INSTANCE
MEM_GAMEMANAGER
PARENOPEN
CGAMEMANAGER
PARENCLOSE
SEMICOLON
INSTANCE
MEM_PARSER
PARENOPEN
ZCPARSER
PARENCLOSE
SEMICOLON
FUNC
VOID
MEM_INITGLOBALINST
PARENOPEN
PARENCLOSE
BRACKETOPEN
// Game:
MEM_GAME
ASSIGN
_^
PARENOPEN
MEM_READINT
PARENOPEN
MEMINT_OGAME_POINTER_ADDRESS
PARENCLOSE
PARENCLOSE
SEMICOLON
// World:
MEM_WORLD
ASSIGN
_^
PARENOPEN
MEM_GAME
PERIOD
_ZCSESSION_WORLD
PARENCLOSE
SEMICOLON
// Vobtree:
MEM_VOBTREE
ASSIGN
_^
PARENOPEN
MEM_GAME
PERIOD
_ZCSESSION_WORLD
PLUS
INTEGER(36)
PARENCLOSE
SEMICOLON
// + 0x0024
// InfoManager:
MEM_INFOMAN
ASSIGN
_^
PARENOPEN
MEM_GAME
PERIOD
INFOMAN
PARENCLOSE
SEMICOLON
// InformationManager
MEM_INFORMATIONMAN
ASSIGN
_^
PARENOPEN
MEMINT_OCINFORMATIONMANAGER_ADDRESS
PARENCLOSE
SEMICOLON
// Waynet:
MEM_WAYNET
ASSIGN
_^
PARENOPEN
MEM_WORLD
PERIOD
WAYNET
PARENCLOSE
SEMICOLON
// Camera
MEM_CAMERA
ASSIGN
_^
PARENOPEN
MEM_GAME
PERIOD
_ZCSESSION_CAMERA
PARENCLOSE
SEMICOLON
// SkyController:
IF
PARENOPEN
MEM_WORLD
PERIOD
SKYCONTROLEROUTDOOR
PARENCLOSE
BRACKETOPEN
MEM_SKYCONTROLLER
ASSIGN
_^
PARENOPEN
MEM_WORLD
PERIOD
SKYCONTROLEROUTDOOR
PARENCLOSE
SEMICOLON
BRACKETCLOSE
ELSE
BRACKETOPEN
MEM_ASSIGNINSTNULL
PARENOPEN
MEM_SKYCONTROLLER
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// Spawnmanager
MEM_SPAWNMANAGER
ASSIGN
_^
PARENOPEN
MEM_GAME
PERIOD
SPAWNMAN
PARENCLOSE
SEMICOLON
// zTimer:
MEM_TIMER
ASSIGN
_^
PARENOPEN
MEMINT_ZTIMER_ADDRESS
PARENCLOSE
SEMICOLON
// WorldTimer:
MEM_WORLDTIMER
ASSIGN
_^
PARENOPEN
MEM_GAME
PERIOD
WLDTIMER
PARENCLOSE
SEMICOLON
// GameManager
MEM_GAMEMANANGER
ASSIGN
_^
PARENOPEN
MEM_READINT
PARENOPEN
MEMINT_GAMEMAN_POINTER_ADDRESS
PARENCLOSE
PARENCLOSE
SEMICOLON
//  shit: Typo! Keep it as to not break code 
MEM_GAMEMANAGER
ASSIGN
_^
PARENOPEN
MEM_READINT
PARENOPEN
MEMINT_GAMEMAN_POINTER_ADDRESS
PARENCLOSE
PARENCLOSE
SEMICOLON
// The Content Parser
MEM_PARSER
ASSIGN
_^
PARENOPEN
CONTENTPARSERADDRESS
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// ************************************************
//  Validity checks
// ************************************************
FUNC
INT
HLP_IS_OCMOBFIRE
PARENOPEN
VAR
INT
PTR
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
NOT
PTR
PARENCLOSE
BRACKETOPEN
RETURN
INTEGER(0)
SEMICOLON
BRACKETCLOSE
SEMICOLON
RETURN
PARENOPEN
MEM_READINT
PARENOPEN
PTR
PARENCLOSE
EQUALS
OCMOBFIRE_VTBL
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
HLP_IS_ZCMOVER
PARENOPEN
VAR
INT
PTR
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
NOT
PTR
PARENCLOSE
BRACKETOPEN
RETURN
INTEGER(0)
SEMICOLON
BRACKETCLOSE
SEMICOLON
RETURN
PARENOPEN
MEM_READINT
PARENOPEN
PTR
PARENCLOSE
EQUALS
ZCMOVER_VTBL
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
HLP_IS_OCMOB
PARENOPEN
VAR
INT
PTR
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
NOT
PTR
PARENCLOSE
BRACKETOPEN
RETURN
INTEGER(0)
SEMICOLON
BRACKETCLOSE
SEMICOLON
VAR
INT
VTBL
SEMICOLON
VTBL
ASSIGN
MEM_READINT
PARENOPEN
PTR
PARENCLOSE
SEMICOLON
//  Schreibweise so bescheuert, weil Gothic Sourcer bei || meckert. 
RETURN
PARENOPEN
VTBL
EQUALS
OCMOB_VTBL
PARENCLOSE
BITOR
PARENOPEN
VTBL
EQUALS
OCMOBINTER_VTBL
PARENCLOSE
BITOR
PARENOPEN
VTBL
EQUALS
OCMOBCONTAINER_VTBL
PARENCLOSE
BITOR
PARENOPEN
VTBL
EQUALS
OCMOBDOOR_VTBL
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
HLP_IS_OCMOBINTER
PARENOPEN
VAR
INT
PTR
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
NOT
PTR
PARENCLOSE
BRACKETOPEN
RETURN
INTEGER(0)
SEMICOLON
BRACKETCLOSE
SEMICOLON
VAR
INT
VTBL
SEMICOLON
VTBL
ASSIGN
MEM_READINT
PARENOPEN
PTR
PARENCLOSE
SEMICOLON
RETURN
PARENOPEN
VTBL
EQUALS
OCMOBINTER_VTBL
PARENCLOSE
BITOR
PARENOPEN
VTBL
EQUALS
OCMOBCONTAINER_VTBL
PARENCLOSE
BITOR
PARENOPEN
VTBL
EQUALS
OCMOBDOOR_VTBL
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
HLP_IS_OCMOBLOCKABLE
PARENOPEN
VAR
INT
PTR
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
NOT
PTR
PARENCLOSE
BRACKETOPEN
RETURN
INTEGER(0)
SEMICOLON
BRACKETCLOSE
SEMICOLON
//  Gibt es Lockables die weder Türen noch Truhe sind?\n     * nutzt aber eh keiner => zu faul zum nachforschen. 
VAR
INT
VTBL
SEMICOLON
VTBL
ASSIGN
MEM_READINT
PARENOPEN
PTR
PARENCLOSE
SEMICOLON
RETURN
PARENOPEN
VTBL
EQUALS
OCMOBCONTAINER_VTBL
PARENCLOSE
BITOR
PARENOPEN
VTBL
EQUALS
OCMOBDOOR_VTBL
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
HLP_IS_OCMOBCONTAINER
PARENOPEN
VAR
INT
PTR
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
NOT
PTR
PARENCLOSE
BRACKETOPEN
RETURN
INTEGER(0)
SEMICOLON
BRACKETCLOSE
SEMICOLON
RETURN
PARENOPEN
MEM_READINT
PARENOPEN
PTR
PARENCLOSE
EQUALS
OCMOBCONTAINER_VTBL
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
HLP_IS_OCMOBDOOR
PARENOPEN
VAR
INT
PTR
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
NOT
PTR
PARENCLOSE
BRACKETOPEN
RETURN
INTEGER(0)
SEMICOLON
BRACKETCLOSE
SEMICOLON
RETURN
PARENOPEN
MEM_READINT
PARENOPEN
PTR
PARENCLOSE
EQUALS
OCMOBDOOR_VTBL
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
HLP_IS_OCNPC
PARENOPEN
VAR
INT
PTR
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
NOT
PTR
PARENCLOSE
BRACKETOPEN
RETURN
INTEGER(0)
SEMICOLON
BRACKETCLOSE
SEMICOLON
RETURN
PARENOPEN
MEM_READINT
PARENOPEN
PTR
PARENCLOSE
EQUALS
OCNPC_VTBL
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
HLP_IS_OCITEM
PARENOPEN
VAR
INT
PTR
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
NOT
PTR
PARENCLOSE
BRACKETOPEN
RETURN
INTEGER(0)
SEMICOLON
BRACKETCLOSE
SEMICOLON
RETURN
PARENOPEN
MEM_READINT
PARENOPEN
PTR
PARENCLOSE
EQUALS
OCITEM_VTBL
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
HLP_IS_ZCVOBLIGHT
PARENOPEN
VAR
INT
PTR
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
NOT
PTR
PARENCLOSE
BRACKETOPEN
RETURN
INTEGER(0)
SEMICOLON
BRACKETCLOSE
SEMICOLON
RETURN
PARENOPEN
MEM_READINT
PARENOPEN
PTR
PARENCLOSE
EQUALS
ZCVOBLIGHT_VTBL
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// ************************************************
//    Find zCClassDef
// ************************************************
FUNC
INT
MEM_GETCLASSDEF
PARENOPEN
VAR
INT
OBJPTR
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
NOT
OBJPTR
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"MEMINT_GetClassDef: ObjPtr == 0."
PARENCLOSE
SEMICOLON
RETURN
INTEGER(0)
SEMICOLON
BRACKETCLOSE
SEMICOLON
// In obj._vtbl[0] steht die Adresse der Funktion, die ClassDef zurückgibt.
// Diese Funktion besteht aus einem einfachen "mov eax" (1 byte), der Adresse (4 byte) und einem "retn" (1 byte).
// obj._vtbl[0] contains the address of a virtual function that returns
// the classDef of the class of the object.
// This function contains of a single "mov" command (1 byte) that is followed by the address that is of interest here.
RETURN
MEM_READINT
PARENOPEN
INTEGER(1)
PLUS
MEM_READINT
PARENOPEN
MEM_READINT
PARENOPEN
OBJPTR
PARENCLOSE
PARENCLOSE
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
STRING
MEM_GETCLASSNAME
PARENOPEN
VAR
INT
OBJPTR
PARENCLOSE
BRACKETOPEN
VAR
INT
CLASSDEF
SEMICOLON
CLASSDEF
ASSIGN
MEM_GETCLASSDEF
PARENOPEN
OBJPTR
PARENCLOSE
SEMICOLON
IF
PARENOPEN
CLASSDEF
PARENCLOSE
BRACKETOPEN
RETURN
MEM_READSTRING
PARENOPEN
CLASSDEF
PARENCLOSE
SEMICOLON
// gleich die erste Eigenschaft / first property of zCClassDef.
BRACKETCLOSE
SEMICOLON
RETURN
""
SEMICOLON
BRACKETCLOSE
SEMICOLON
// ************************************************
//     Create and delete Vobs
// ************************************************
//  Danke an Gottfried für die Entdeckung von Wld_InsertObject! 
FUNC
INT
MEM_INSERTVOB
PARENOPEN
VAR
STRING
VIS
COMMA
VAR
STRING
WP
PARENCLOSE
BRACKETOPEN
//  oCMob von Gothic konstruieren lassen 
CONST
INT
OCNPC__PLAYER_G1
ASSIGN
INTEGER(9288624)
SEMICOLON
// 0x8DBBB0
CONST
INT
OCNPC__PLAYER_G2
ASSIGN
INTEGER(11216516)
SEMICOLON
// 0xAB2684
VAR
INT
PLAYERADR
SEMICOLON
PLAYERADR
ASSIGN
MEMINT_SWITCHG1G2
PARENOPEN
OCNPC__PLAYER_G1
COMMA
OCNPC__PLAYER_G2
PARENCLOSE
SEMICOLON
VAR
INT
WASINVALID
SEMICOLON
WASINVALID
ASSIGN
INTEGER(0)
SEMICOLON
//  Wld_InsertObject crashed wenn es keinen Player gibt!\n     * Das ist z.B. der Fall, wenn man dies hier aus der Startup aufruft. 
IF
PARENOPEN
NOT
HLP_IS_OCNPC
PARENOPEN
MEM_READINT
PARENOPEN
PLAYERADR
PARENCLOSE
PARENCLOSE
PARENCLOSE
BRACKETOPEN
WASINVALID
ASSIGN
INTEGER(1)
SEMICOLON
MEMINT_GETMEMHELPER
PARENOPEN
PARENCLOSE
SEMICOLON
MEM_WRITEINT
PARENOPEN
PLAYERADR
COMMA
MEM_INSTGETOFFSET
PARENOPEN
MEM_HELPER
PARENCLOSE
PARENCLOSE
SEMICOLON
VAR
INT
OLDWORLD
SEMICOLON
OLDWORLD
ASSIGN
MEM_HELPER
PERIOD
_ZCVOB_HOMEWORLD
SEMICOLON
// player braucht auch Homeworld.
MEM_HELPER
PERIOD
_ZCVOB_HOMEWORLD
ASSIGN
MEM_INSTGETOFFSET
PARENOPEN
MEM_WORLD
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
WLD_INSERTOBJECT
PARENOPEN
VIS
COMMA
WP
PARENCLOSE
SEMICOLON
//  wieder invalidieren 
IF
PARENOPEN
WASINVALID
PARENCLOSE
BRACKETOPEN
MEM_WRITEINT
PARENOPEN
PLAYERADR
COMMA
INTEGER(0)
PARENCLOSE
SEMICOLON
MEM_HELPER
PERIOD
_ZCVOB_HOMEWORLD
ASSIGN
OLDWORLD
SEMICOLON
BRACKETCLOSE
SEMICOLON
//  Ein Pointer auf das neue Objekt findet sich im Vobtree\n     * stets als erstes Kind des globalen Vobtrees 
VAR
ZCTREE
NEWTREENODE
SEMICOLON
NEWTREENODE
ASSIGN
_^
PARENOPEN
MEM_WORLD
PERIOD
GLOBALVOBTREE_FIRSTCHILD
PARENCLOSE
SEMICOLON
RETURN
NEWTREENODE
PERIOD
DATA
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEM_DELETEVOB
PARENOPEN
VAR
INT
VOBPTR
PARENCLOSE
BRACKETOPEN
VAR
INT
WORLD
SEMICOLON
WORLD
ASSIGN
MEM_GAME
PERIOD
_ZCSESSION_WORLD
SEMICOLON
CONST
INT
CALL
ASSIGN
INTEGER(0)
SEMICOLON
IF
PARENOPEN
CALL_BEGIN
PARENOPEN
CALL
PARENCLOSE
PARENCLOSE
BRACKETOPEN
//  oCWorld.RemoveVob 
CALL_INTPARAM
PARENOPEN
_@
PARENOPEN
VOBPTR
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL__THISCALL
PARENOPEN
_@
PARENOPEN
WORLD
PARENCLOSE
COMMA
MEMINT_SWITCHG1G2
PARENOPEN
INTEGER(7171824)
COMMA
INTEGER(7864512)
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL
ASSIGN
CALL_END
PARENOPEN
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// ************************************************
//  Hashing
// ************************************************
// --------------------------------------
//   Evaluate hash function
// --------------------------------------
FUNC
INT
MEM_GETBUFFERCRC32
PARENOPEN
VAR
INT
BUF
COMMA
VAR
INT
BUFLEN
PARENCLOSE
BRACKETOPEN
CONST
INT
GETBUFFERCRC32_G1
ASSIGN
INTEGER(6088464)
SEMICOLON
// 0x5CE710
CONST
INT
GETBUFFERCRC32_G2
ASSIGN
INTEGER(6265360)
SEMICOLON
// 0x5F9A10
VAR
INT
NULL
SEMICOLON
CONST
INT
CALL
ASSIGN
INTEGER(0)
SEMICOLON
IF
PARENOPEN
CALL_BEGIN
PARENOPEN
CALL
PARENCLOSE
PARENCLOSE
BRACKETOPEN
CALL_INTPARAM
PARENOPEN
_@
PARENOPEN
NULL
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL_INTPARAM
PARENOPEN
_@
PARENOPEN
BUFLEN
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL_PTRPARAM
PARENOPEN
_@
PARENOPEN
BUF
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL_PUTRETVALTO
PARENOPEN
_@
PARENOPEN
RET
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL__CDECL
PARENOPEN
MEMINT_SWITCHG1G2
PARENOPEN
GETBUFFERCRC32_G1
COMMA
GETBUFFERCRC32_G2
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL
ASSIGN
CALL_END
PARENOPEN
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
VAR
INT
RET
SEMICOLON
RETURN
PLUS
RET
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
MEM_GETSTRINGHASH
PARENOPEN
VAR
STRING
STR
PARENCLOSE
BRACKETOPEN
RETURN
MEM_GETBUFFERCRC32
PARENOPEN
STR_TOCHAR
PARENOPEN
STR
PARENCLOSE
COMMA
STR_LEN
PARENOPEN
STR
PARENCLOSE
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
MEMINT_GETWORLDHASHBUCKET
PARENOPEN
VAR
INT
HASH
PARENCLOSE
BRACKETOPEN
VAR
INT
BUCKETPTR
SEMICOLON
BUCKETPTR
ASSIGN
_@
PARENOPEN
MEM_WORLD
PARENCLOSE
SEMICOLON
BUCKETPTR
PLUSASSIGN
ZCWORLD_VOBHASHTABLE_OFFSET
PLUS
//  sizeof (zCArray) 
INTEGER(12)
MULTIPLY
HASH
SEMICOLON
RETURN
BUCKETPTR
SEMICOLON
BRACKETCLOSE
SEMICOLON
// --------------------------------------
//    Find Vob in hash function
// --------------------------------------
FUNC
INT
MEM_SEARCHVOBBYNAME
PARENOPEN
VAR
STRING
STR
PARENCLOSE
BRACKETOPEN
CONST
INT
OCWORLD__SEARCHVOBBYNAME_G1
ASSIGN
INTEGER(7173120)
SEMICOLON
// 0x6D7400
CONST
INT
OCWORLD__SEARCHVOBBYNAME_G2
ASSIGN
INTEGER(7865872)
SEMICOLON
// 0x780610
VAR
INT
PTR
SEMICOLON
PTR
ASSIGN
_@S
PARENOPEN
STR
PARENCLOSE
SEMICOLON
VAR
INT
WORLD
SEMICOLON
WORLD
ASSIGN
_@
PARENOPEN
MEM_WORLD
PARENCLOSE
SEMICOLON
CONST
INT
CALL
ASSIGN
INTEGER(0)
SEMICOLON
IF
PARENOPEN
CALL_BEGIN
PARENOPEN
CALL
PARENCLOSE
PARENCLOSE
BRACKETOPEN
CALL_PTRPARAM
PARENOPEN
_@
PARENOPEN
PTR
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL_PUTRETVALTO
PARENOPEN
_@
PARENOPEN
RET
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL__THISCALL
PARENOPEN
_@
PARENOPEN
WORLD
PARENCLOSE
COMMA
MEMINT_SWITCHG1G2
PARENOPEN
OCWORLD__SEARCHVOBBYNAME_G1
COMMA
OCWORLD__SEARCHVOBBYNAME_G2
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL
ASSIGN
CALL_END
PARENOPEN
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
VAR
INT
RET
SEMICOLON
RETURN
PLUS
RET
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
MEM_SEARCHALLVOBSBYNAME
PARENOPEN
VAR
STRING
STR
PARENCLOSE
BRACKETOPEN
CONST
INT
OCWORLD__SEARCHVOBLISTBYNAME_G1
ASSIGN
INTEGER(7173296)
SEMICOLON
// 0x6D74B0
CONST
INT
OCWORLD__SEARCHVOBLISTBYNAME_G2
ASSIGN
INTEGER(7866048)
SEMICOLON
// 0x7806C0
VAR
INT
ARR
SEMICOLON
ARR
ASSIGN
MEM_ARRAYCREATE
PARENOPEN
PARENCLOSE
SEMICOLON
VAR
INT
PTR
SEMICOLON
PTR
ASSIGN
_@S
PARENOPEN
STR
PARENCLOSE
SEMICOLON
VAR
INT
WORLD
SEMICOLON
WORLD
ASSIGN
_@
PARENOPEN
MEM_WORLD
PARENCLOSE
SEMICOLON
CONST
INT
CALL
ASSIGN
INTEGER(0)
SEMICOLON
IF
PARENOPEN
CALL_BEGIN
PARENOPEN
CALL
PARENCLOSE
PARENCLOSE
BRACKETOPEN
CALL_PTRPARAM
PARENOPEN
_@
PARENOPEN
ARR
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL_PTRPARAM
PARENOPEN
_@
PARENOPEN
PTR
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL_PUTRETVALTO
PARENOPEN
INTEGER(0)
PARENCLOSE
SEMICOLON
CALL__THISCALL
PARENOPEN
_@
PARENOPEN
WORLD
PARENCLOSE
COMMA
MEMINT_SWITCHG1G2
PARENOPEN
OCWORLD__SEARCHVOBLISTBYNAME_G1
COMMA
OCWORLD__SEARCHVOBLISTBYNAME_G2
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL
ASSIGN
CALL_END
PARENOPEN
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
MEM_ARRAYSORT
PARENOPEN
ARR
PARENCLOSE
SEMICOLON
MEM_ARRAYUNIQUE
PARENOPEN
ARR
PARENCLOSE
SEMICOLON
RETURN
PLUS
ARR
SEMICOLON
BRACKETCLOSE
SEMICOLON
// --------------------------------------
//  Vob umbenennen
// --------------------------------------
FUNC
VOID
MEM_RENAMEVOB
PARENOPEN
VAR
INT
VOBPTR
COMMA
VAR
STRING
NEWNAME
PARENCLOSE
BRACKETOPEN
CONST
INT
ZCVOB_SETVOBNAME_G1
ASSIGN
INTEGER(6113648)
SEMICOLON
// 0x5D4970
CONST
INT
ZCVOB_SETVOBNAME_G2
ASSIGN
INTEGER(6290896)
SEMICOLON
// 0x5FFDD0
VAR
INT
PTR
SEMICOLON
PTR
ASSIGN
_@S
PARENOPEN
NEWNAME
PARENCLOSE
SEMICOLON
CONST
INT
CALL
ASSIGN
INTEGER(0)
SEMICOLON
IF
PARENOPEN
CALL_BEGIN
PARENOPEN
CALL
PARENCLOSE
PARENCLOSE
BRACKETOPEN
CALL_PTRPARAM
PARENOPEN
_@
PARENOPEN
PTR
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL_PUTRETVALTO
PARENOPEN
INTEGER(0)
PARENCLOSE
SEMICOLON
CALL__THISCALL
PARENOPEN
_@
PARENOPEN
VOBPTR
PARENCLOSE
COMMA
MEMINT_SWITCHG1G2
PARENOPEN
ZCVOB_SETVOBNAME_G1
COMMA
ZCVOB_SETVOBNAME_G2
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL
ASSIGN
CALL_END
PARENOPEN
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// ************************************************
//   Trigger / Untrigger
// ************************************************
FUNC
INT
MEMINT_VOBGETEM
PARENOPEN
VAR
INT
VOBPTR
PARENCLOSE
BRACKETOPEN
CONST
INT
ZCVOB__GETEM_G1
ASSIGN
INTEGER(6113712)
SEMICOLON
// 5D49B0
CONST
INT
ZCVOB__GETEM_G2
ASSIGN
INTEGER(6290960)
SEMICOLON
// 5FFE10
CONST
INT
NULL
ASSIGN
INTEGER(0)
SEMICOLON
CONST
INT
CALL
ASSIGN
INTEGER(0)
SEMICOLON
IF
PARENOPEN
CALL_BEGIN
PARENOPEN
CALL
PARENCLOSE
PARENCLOSE
BRACKETOPEN
CALL_PUTRETVALTO
PARENOPEN
_@
PARENOPEN
RET
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL__FASTCALL
PARENOPEN
_@
PARENOPEN
VOBPTR
PARENCLOSE
COMMA
_@
PARENOPEN
NULL
PARENCLOSE
COMMA
MEMINT_SWITCHG1G2
PARENOPEN
ZCVOB__GETEM_G1
COMMA
ZCVOB__GETEM_G2
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL
ASSIGN
CALL_END
PARENOPEN
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
VAR
INT
RET
SEMICOLON
RETURN
PLUS
RET
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEM_TRIGGERVOB
PARENOPEN
VAR
INT
VOBPTR
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
NOT
VOBPTR
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"MEM_TriggerVob: VobPtr may not be null!"
PARENCLOSE
SEMICOLON
RETURN
SEMICOLON
BRACKETCLOSE
SEMICOLON
CONST
INT
ZCEVENTMANAGER_ONTRIGGER_G1
ASSIGN
INTEGER(7202656)
SEMICOLON
// 0x6DE760
CONST
INT
ZCEVENTMANAGER_ONTRIGGER_G2
ASSIGN
INTEGER(7895536)
SEMICOLON
// 0x7879F0
VAR
ZCVOB
VOB
SEMICOLON
VOB
ASSIGN
_^
PARENOPEN
VOBPTR
PARENCLOSE
SEMICOLON
VAR
INT
EVENTMAN
SEMICOLON
EVENTMAN
ASSIGN
MEMINT_VOBGETEM
PARENOPEN
VOBPTR
PARENCLOSE
SEMICOLON
CONST
INT
CALL
ASSIGN
INTEGER(0)
SEMICOLON
IF
PARENOPEN
CALL_BEGIN
PARENOPEN
CALL
PARENCLOSE
PARENCLOSE
BRACKETOPEN
CALL_PTRPARAM
PARENOPEN
_@
PARENOPEN
VOBPTR
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL_PTRPARAM
PARENOPEN
_@
PARENOPEN
VOBPTR
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL_PUTRETVALTO
PARENOPEN
INTEGER(0)
PARENCLOSE
SEMICOLON
CALL__THISCALL
PARENOPEN
_@
PARENOPEN
EVENTMAN
PARENCLOSE
COMMA
MEMINT_SWITCHG1G2
PARENOPEN
ZCEVENTMANAGER_ONTRIGGER_G1
COMMA
ZCEVENTMANAGER_ONTRIGGER_G2
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL
ASSIGN
CALL_END
PARENOPEN
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEM_UNTRIGGERVOB
PARENOPEN
VAR
INT
VOBPTR
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
NOT
VOBPTR
PARENCLOSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
"MEM_UntriggerVob: VobPtr may not be null!"
PARENCLOSE
SEMICOLON
RETURN
SEMICOLON
BRACKETCLOSE
SEMICOLON
CONST
INT
ZCEVENTMANAGER_ONUNTRIGGER_G1
ASSIGN
INTEGER(7202848)
SEMICOLON
// 6DE820
CONST
INT
ZCEVENTMANAGER_ONUNTRIGGER_G2
ASSIGN
INTEGER(7895728)
SEMICOLON
// 787AB0
VAR
ZCVOB
VOB
SEMICOLON
VOB
ASSIGN
_^
PARENOPEN
VOBPTR
PARENCLOSE
SEMICOLON
VAR
INT
EVENTMAN
SEMICOLON
EVENTMAN
ASSIGN
MEMINT_VOBGETEM
PARENOPEN
VOBPTR
PARENCLOSE
SEMICOLON
CONST
INT
CALL
ASSIGN
INTEGER(0)
SEMICOLON
IF
PARENOPEN
CALL_BEGIN
PARENOPEN
CALL
PARENCLOSE
PARENCLOSE
BRACKETOPEN
CALL_PTRPARAM
PARENOPEN
_@
PARENOPEN
VOBPTR
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL_PTRPARAM
PARENOPEN
_@
PARENOPEN
VOBPTR
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL_PUTRETVALTO
PARENOPEN
INTEGER(0)
PARENCLOSE
SEMICOLON
CALL__THISCALL
PARENOPEN
_@
PARENOPEN
EVENTMAN
PARENCLOSE
COMMA
MEMINT_SWITCHG1G2
PARENOPEN
ZCEVENTMANAGER_ONUNTRIGGER_G1
COMMA
ZCEVENTMANAGER_ONUNTRIGGER_G2
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL
ASSIGN
CALL_END
PARENOPEN
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// ######################################################
// 
//   Keyboard interaction
// 
// ######################################################
// Rückgabewerte
CONST
INT
KEY_UP
ASSIGN
INTEGER(0)
SEMICOLON
CONST
INT
KEY_PRESSED
ASSIGN
INTEGER(1)
SEMICOLON
CONST
INT
KEY_HOLD
ASSIGN
INTEGER(2)
SEMICOLON
CONST
INT
KEY_RELEASED
ASSIGN
INTEGER(3)
SEMICOLON
// --------------------------------------
//   Grundlage: Ist die Taste gedrückt?
// --------------------------------------
// etwas ungeschickt, dass die Methode, die auf KEY_HOLD prüft KeyPressed heißt... :-(
// aber jetzt ist es so und ich wills nicht ändern.
FUNC
INT
MEM_KEYPRESSED
PARENOPEN
VAR
INT
KEY
PARENCLOSE
BRACKETOPEN
RETURN
MEM_READINT
PARENOPEN
MEMINT_KEYEVENT_OFFSET
PLUS
KEY
PARENCLOSE
BITAND
INTEGER(255)
SEMICOLON
BRACKETCLOSE
SEMICOLON
// --------------------------------------
//   Darauf aufbauend: Erkennung
//   wann das erste mal gedrückt
//   und wann gehalten
// --------------------------------------
// Hier merke ich mir die Zustände seit der letzten Abfrage:
VAR
INT
MEMINT_KEYSTATE
SQUAREOPEN
INTEGER(1024)
SQUARECLOSE
SEMICOLON
// lieber mal etwas mehr, gibt noch JoystickButtons usw.
FUNC
INT
MEM_KEYSTATE
PARENOPEN
VAR
INT
KEY
PARENCLOSE
BRACKETOPEN
VAR
INT
PRESSED
SEMICOLON
PRESSED
ASSIGN
MEM_KEYPRESSED
PARENOPEN
KEY
PARENCLOSE
SEMICOLON
// Adresse als Int runterholen:
VAR
INT
ADR
SEMICOLON
ADR
ASSIGN
_@
PARENOPEN
MEMINT_KEYSTATE
PARENCLOSE
SEMICOLON
ADR
PLUSASSIGN
INTEGER(4)
MULTIPLY
KEY
SEMICOLON
// State holen:
VAR
INT
KEYSTATE
SEMICOLON
KEYSTATE
ASSIGN
MEM_READINT
PARENOPEN
ADR
PARENCLOSE
SEMICOLON
// State bearbeiten:
IF
PARENOPEN
KEYSTATE
EQUALS
KEY_UP
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
PRESSED
PARENCLOSE
BRACKETOPEN
KEYSTATE
ASSIGN
KEY_PRESSED
SEMICOLON
BRACKETCLOSE
SEMICOLON
BRACKETCLOSE
ELSE
IF
PARENOPEN
KEYSTATE
EQUALS
KEY_PRESSED
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
PRESSED
PARENCLOSE
BRACKETOPEN
KEYSTATE
ASSIGN
KEY_HOLD
SEMICOLON
BRACKETCLOSE
ELSE
BRACKETOPEN
KEYSTATE
ASSIGN
KEY_RELEASED
SEMICOLON
BRACKETCLOSE
SEMICOLON
BRACKETCLOSE
ELSE
IF
PARENOPEN
KEYSTATE
EQUALS
KEY_HOLD
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
NOT
PRESSED
PARENCLOSE
BRACKETOPEN
KEYSTATE
ASSIGN
KEY_RELEASED
SEMICOLON
BRACKETCLOSE
SEMICOLON
BRACKETCLOSE
ELSE
//  keyState == KEY_RELEASED 
BRACKETOPEN
IF
PARENOPEN
PRESSED
PARENCLOSE
BRACKETOPEN
KEYSTATE
ASSIGN
KEY_PRESSED
SEMICOLON
BRACKETCLOSE
ELSE
BRACKETOPEN
KEYSTATE
ASSIGN
KEY_UP
SEMICOLON
BRACKETCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// Neuen State merken
MEM_WRITEINT
PARENOPEN
ADR
COMMA
KEYSTATE
PARENCLOSE
SEMICOLON
RETURN
KEYSTATE
SEMICOLON
// zurückgeben.
BRACKETCLOSE
SEMICOLON
// --------------------------------------
//   Key-Event einfügen
// --------------------------------------
//  Problematisch, vielleicht gibt es irgendwann eine bessere Lösung.\n * Aber einiges kann man damit schon machen.\n * Beispiel:\n *   -Inventar öffnen.\n *   -Quicksave\n *   -Charaktermenü öffnen\n *   -Pause togglen (Marvin Modus)\n *   -Log-Öffnen\n *   -Hauptmenü öffnen (ESC)\n *   ...\n *\n * An anderen Stellen will die Engine aber, dass der Key "getoggled"\n * wurde, das wird anderweitig verwaltet und ist hiervon nicht betroffen.\n * Daher kann man zum Beispiel das Inventar mit Hilfe dieser Funktion\n * nicht wieder schließen. 
FUNC
VOID
MEM_INSERTKEYEVENT
PARENOPEN
VAR
INT
KEY
PARENCLOSE
BRACKETOPEN
MEM_ARRAYINSERT
PARENOPEN
MEMINT_KEYBUFFER_OFFSET
COMMA
KEY
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// #################################################################
// 
//   zCOptions Access:
// 
// #################################################################
VAR
ZCOPTION
MEMINT_OPT_SET
SEMICOLON
VAR
ZCOPTIONSECTION
MEMINT_OPT_SECTION
SEMICOLON
VAR
ZCOPTIONENTRY
MEMINT_OPT_ENTRY
SEMICOLON
// ************************************************
//   reading
// ************************************************
// --------------------------------------
//   read in zCOptions
// --------------------------------------
//  Search the current section for an entry 
FUNC
INT
MEMINT_OPT_FINDENTRY
PARENOPEN
VAR
STRING
OPTNAME
PARENCLOSE
BRACKETOPEN
// Anzahl Einträge == 0 ausschließen (weil nur do-while schleife möglich, keine while-do).
IF
PARENOPEN
NOT
MEMINT_OPT_SECTION
PERIOD
ENTRYLIST_NUMINARRAY
PARENCLOSE
BRACKETOPEN
RETURN
FALSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
VAR
INT
I
SEMICOLON
I
ASSIGN
INTEGER(0)
SEMICOLON
VAR
INT
LOOPSTART
SEMICOLON
LOOPSTART
ASSIGN
MEM_STACKPOS
PERIOD
POSITION
SEMICOLON
//  while 
IF
PARENOPEN
I
LOWER
MEMINT_OPT_SECTION
PERIOD
ENTRYLIST_NUMINARRAY
PARENCLOSE
BRACKETOPEN
VAR
INT
PTR
SEMICOLON
PTR
ASSIGN
MEM_READINTARRAY
PARENOPEN
MEMINT_OPT_SECTION
PERIOD
ENTRYLIST_ARRAY
COMMA
I
PARENCLOSE
SEMICOLON
MEMINT_OPT_ENTRY
ASSIGN
_^
PARENOPEN
PTR
PARENCLOSE
SEMICOLON
IF
PARENOPEN
HLP_STRCMP
PARENOPEN
MEMINT_OPT_ENTRY
PERIOD
VARNAME
COMMA
OPTNAME
PARENCLOSE
PARENCLOSE
BRACKETOPEN
RETURN
TRUE
SEMICOLON
BRACKETCLOSE
SEMICOLON
I
PLUSASSIGN
INTEGER(1)
SEMICOLON
MEM_STACKPOS
PERIOD
POSITION
ASSIGN
LOOPSTART
SEMICOLON
BRACKETCLOSE
SEMICOLON
//  end while 
RETURN
FALSE
SEMICOLON
// nichts gefunden.
BRACKETCLOSE
SEMICOLON
//  Search the current option set for a section 
FUNC
INT
MEMINT_OPT_FINDSECTION
PARENOPEN
VAR
STRING
SECTNAME
PARENCLOSE
BRACKETOPEN
// Anzahl Sektionen == 0 ausschließen (weil nur do-while schleife möglich, keine while-do).
IF
PARENOPEN
NOT
MEMINT_OPT_SET
PERIOD
SECTIONLIST_NUMINARRAY
PARENCLOSE
BRACKETOPEN
RETURN
FALSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
VAR
INT
I
SEMICOLON
I
ASSIGN
INTEGER(0)
SEMICOLON
VAR
INT
LOOPSTART
SEMICOLON
LOOPSTART
ASSIGN
MEM_STACKPOS
PERIOD
POSITION
SEMICOLON
//  while 
IF
PARENOPEN
I
LOWER
MEMINT_OPT_SET
PERIOD
SECTIONLIST_NUMINARRAY
PARENCLOSE
BRACKETOPEN
VAR
INT
PTR
SEMICOLON
PTR
ASSIGN
MEM_READINTARRAY
PARENOPEN
MEMINT_OPT_SET
PERIOD
SECTIONLIST_ARRAY
COMMA
I
PARENCLOSE
SEMICOLON
MEMINT_OPT_SECTION
ASSIGN
_^
PARENOPEN
PTR
PARENCLOSE
SEMICOLON
IF
PARENOPEN
HLP_STRCMP
PARENOPEN
MEMINT_OPT_SECTION
PERIOD
SECNAME
COMMA
SECTNAME
PARENCLOSE
PARENCLOSE
BRACKETOPEN
RETURN
TRUE
SEMICOLON
BRACKETCLOSE
SEMICOLON
I
PLUSASSIGN
INTEGER(1)
SEMICOLON
MEM_STACKPOS
PERIOD
POSITION
ASSIGN
LOOPSTART
SEMICOLON
BRACKETCLOSE
SEMICOLON
//  end while 
RETURN
FALSE
SEMICOLON
// nichts gefunden.
BRACKETCLOSE
SEMICOLON
// --------------------------------------
//   Search the Gothic.ini
// --------------------------------------
FUNC
STRING
MEM_GETGOTHOPT
PARENOPEN
VAR
STRING
SECTIONNAME
COMMA
VAR
STRING
OPTIONNAME
PARENCLOSE
BRACKETOPEN
MEMINT_OPT_SET
ASSIGN
_^
PARENOPEN
MEM_READINT
PARENOPEN
ZOPTIONS_POINTER_ADDRESS
PARENCLOSE
PARENCLOSE
SEMICOLON
IF
PARENOPEN
NOT
MEMINT_OPT_FINDSECTION
PARENOPEN
SECTIONNAME
PARENCLOSE
PARENCLOSE
BRACKETOPEN
RETURN
""
SEMICOLON
BRACKETCLOSE
SEMICOLON
IF
PARENOPEN
NOT
MEMINT_OPT_FINDENTRY
PARENOPEN
OPTIONNAME
PARENCLOSE
PARENCLOSE
BRACKETOPEN
RETURN
""
SEMICOLON
BRACKETCLOSE
SEMICOLON
RETURN
MEMINT_OPT_ENTRY
PERIOD
VARVALUE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
MEM_GOTHOPTSECTIONEXISTS
PARENOPEN
VAR
STRING
SECTIONNAME
PARENCLOSE
BRACKETOPEN
MEMINT_OPT_SET
ASSIGN
_^
PARENOPEN
MEM_READINT
PARENOPEN
ZOPTIONS_POINTER_ADDRESS
PARENCLOSE
PARENCLOSE
SEMICOLON
RETURN
MEMINT_OPT_FINDSECTION
PARENOPEN
SECTIONNAME
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
MEM_GOTHOPTEXISTS
PARENOPEN
VAR
STRING
SECTIONNAME
COMMA
VAR
STRING
OPTIONNAME
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
NOT
MEM_GOTHOPTSECTIONEXISTS
PARENOPEN
SECTIONNAME
PARENCLOSE
PARENCLOSE
BRACKETOPEN
RETURN
FALSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
RETURN
MEMINT_OPT_FINDENTRY
PARENOPEN
OPTIONNAME
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// --------------------------------------
//   Search the Mod.ini
// --------------------------------------
FUNC
STRING
MEM_GETMODOPT
PARENOPEN
VAR
STRING
SECTIONNAME
COMMA
VAR
STRING
OPTIONNAME
PARENCLOSE
BRACKETOPEN
MEMINT_OPT_SET
ASSIGN
_^
PARENOPEN
MEM_READINT
PARENOPEN
ZGAMEOPTIONS_POINTER_ADDRESS
PARENCLOSE
PARENCLOSE
SEMICOLON
IF
PARENOPEN
NOT
MEMINT_OPT_FINDSECTION
PARENOPEN
SECTIONNAME
PARENCLOSE
PARENCLOSE
BRACKETOPEN
RETURN
""
SEMICOLON
BRACKETCLOSE
SEMICOLON
IF
PARENOPEN
NOT
MEMINT_OPT_FINDENTRY
PARENOPEN
OPTIONNAME
PARENCLOSE
PARENCLOSE
BRACKETOPEN
RETURN
""
SEMICOLON
BRACKETCLOSE
SEMICOLON
RETURN
MEMINT_OPT_ENTRY
PERIOD
VARVALUE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
MEM_MODOPTSECTIONEXISTS
PARENOPEN
VAR
STRING
SECTIONNAME
PARENCLOSE
BRACKETOPEN
MEMINT_OPT_SET
ASSIGN
_^
PARENOPEN
MEM_READINT
PARENOPEN
ZGAMEOPTIONS_POINTER_ADDRESS
PARENCLOSE
PARENCLOSE
SEMICOLON
RETURN
MEMINT_OPT_FINDSECTION
PARENOPEN
SECTIONNAME
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
MEM_MODOPTEXISTS
PARENOPEN
VAR
STRING
SECTIONNAME
COMMA
VAR
STRING
OPTIONNAME
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
NOT
MEM_MODOPTSECTIONEXISTS
PARENOPEN
SECTIONNAME
PARENCLOSE
PARENCLOSE
BRACKETOPEN
RETURN
FALSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
RETURN
MEMINT_OPT_FINDENTRY
PARENOPEN
OPTIONNAME
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// --------------------------------------
//   Get the command line
// --------------------------------------
FUNC
STRING
MEM_GETCOMMANDLINE
PARENOPEN
PARENCLOSE
BRACKETOPEN
MEMINT_OPT_SET
ASSIGN
_^
PARENOPEN
MEM_READINT
PARENOPEN
ZOPTIONS_POINTER_ADDRESS
PARENCLOSE
PARENCLOSE
SEMICOLON
RETURN
MEMINT_OPT_SET
PERIOD
COMMANDLINE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// #####################################################
//   writing
// #####################################################
//  Mod configuration is never saved to disk, therefore\n * there are no seperate functions for writing in it 
FUNC
VOID
MEM_SETGOTHOPT
PARENOPEN
VAR
STRING
SECTION
COMMA
VAR
STRING
OPTION
COMMA
VAR
STRING
VALUE
PARENCLOSE
BRACKETOPEN
VAR
INT
OPTSETPTR
SEMICOLON
OPTSETPTR
ASSIGN
MEM_READINT
PARENOPEN
ZOPTIONS_POINTER_ADDRESS
PARENCLOSE
SEMICOLON
MEMINT_OPT_SET
ASSIGN
_^
PARENOPEN
OPTSETPTR
PARENCLOSE
SEMICOLON
IF
PARENOPEN
NOT
MEMINT_OPT_FINDSECTION
PARENOPEN
SECTION
PARENCLOSE
PARENCLOSE
BRACKETOPEN
MEM_INFO
PARENOPEN
CONCATSTRINGS
PARENOPEN
"MEM_SetGothOpt: Creating new Section: "
COMMA
SECTION
PARENCLOSE
PARENCLOSE
SEMICOLON
VAR
INT
NEWSECT_PTR
SEMICOLON
NEWSECT_PTR
ASSIGN
MEM_ALLOC
PARENOPEN
SIZEOF_ZCOPTIONSECTION
PARENCLOSE
SEMICOLON
MEMINT_OPT_SECTION
ASSIGN
_^
PARENOPEN
NEWSECT_PTR
PARENCLOSE
SEMICOLON
MEMINT_OPT_SECTION
PERIOD
SECNAME
ASSIGN
SECTION
SEMICOLON
MEM_ARRAYINSERT
PARENOPEN
OPTSETPTR
PLUS
INTEGER(8)
COMMA
NEWSECT_PTR
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
IF
PARENOPEN
NOT
MEMINT_OPT_FINDENTRY
PARENOPEN
OPTION
PARENCLOSE
PARENCLOSE
BRACKETOPEN
MEM_INFO
PARENOPEN
CONCATSTRINGS
PARENOPEN
"MEM_SetGothOpt: Creating new entry: "
COMMA
OPTION
PARENCLOSE
PARENCLOSE
SEMICOLON
VAR
INT
NEWENTRY_PTR
SEMICOLON
NEWENTRY_PTR
ASSIGN
MEM_ALLOC
PARENOPEN
SIZEOF_ZCOPTIONENTRY
PARENCLOSE
SEMICOLON
MEMINT_OPT_ENTRY
ASSIGN
_^
PARENOPEN
NEWENTRY_PTR
PARENCLOSE
SEMICOLON
MEMINT_OPT_ENTRY
PERIOD
VARNAME
ASSIGN
OPTION
SEMICOLON
VAR
INT
SECTPTR
SEMICOLON
SECTPTR
ASSIGN
MEM_INSTGETOFFSET
PARENOPEN
MEMINT_OPT_SECTION
PARENCLOSE
SEMICOLON
MEM_ARRAYINSERT
PARENOPEN
SECTPTR
PLUS
INTEGER(20)
COMMA
NEWENTRY_PTR
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
MEMINT_OPT_ENTRY
PERIOD
VARVALUE
ASSIGN
VALUE
SEMICOLON
MEMINT_OPT_ENTRY
PERIOD
VARVALUETEMP
ASSIGN
VALUE
SEMICOLON
//  dont forget temp value 
BRACKETCLOSE
SEMICOLON
// --------------------------------------
//  Apply some changes
//  and write ini to disk
// --------------------------------------
FUNC
VOID
MEM_APPLYGOTHOPT
PARENOPEN
PARENCLOSE
BRACKETOPEN
CONST
INT
CALL
ASSIGN
INTEGER(0)
SEMICOLON
IF
PARENOPEN
CALL_BEGIN
PARENOPEN
CALL
PARENCLOSE
PARENCLOSE
BRACKETOPEN
//  CGameManager.ApplySomeSettings 
CALL__THISCALL
PARENOPEN
MEMINT_GAMEMAN_POINTER_ADDRESS
COMMA
MEMINT_SWITCHG1G2
PARENOPEN
INTEGER(4351936)
COMMA
INTEGER(4355760)
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL
ASSIGN
CALL_END
PARENOPEN
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// --------------------------------------
//   Get a key
// --------------------------------------
FUNC
INT
MEMINT_HEXCHARTOINT
PARENOPEN
VAR
INT
C
PARENCLOSE
BRACKETOPEN
CONST
INT
ASCII_A
ASSIGN
INTEGER(97)
SEMICOLON
CONST
INT
ASCII_0
ASSIGN
INTEGER(48)
SEMICOLON
IF
PARENOPEN
C
GREATEREQUALS
ASCII_0
AND
C
LOWER
ASCII_0
PLUS
INTEGER(10)
PARENCLOSE
BRACKETOPEN
RETURN
C
MINUS
ASCII_0
SEMICOLON
BRACKETCLOSE
ELSE
IF
PARENOPEN
C
GREATEREQUALS
ASCII_A
AND
C
LOWER
ASCII_A
PLUS
INTEGER(6)
PARENCLOSE
BRACKETOPEN
RETURN
INTEGER(10)
PLUS
C
MINUS
ASCII_A
SEMICOLON
BRACKETCLOSE
ELSE
BRACKETOPEN
MEM_ERROR
PARENOPEN
CONCATSTRINGS
PARENOPEN
"Invalid Hex Char: "
COMMA
INTTOSTRING
PARENOPEN
C
PARENCLOSE
PARENCLOSE
PARENCLOSE
SEMICOLON
RETURN
INTEGER(0)
SEMICOLON
BRACKETCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
MEMINT_KEYSTRINGTOKEY
PARENOPEN
VAR
STRING
HEX
PARENCLOSE
BRACKETOPEN
VAR
ZSTRING
STR
SEMICOLON
STR
ASSIGN
_^
PARENOPEN
_@S
PARENOPEN
HEX
PARENCLOSE
PARENCLOSE
SEMICOLON
VAR
INT
RES
SEMICOLON
RES
ASSIGN
INTEGER(0)
SEMICOLON
RES
PLUSASSIGN
MEMINT_HEXCHARTOINT
PARENOPEN
MEM_READBYTE
PARENOPEN
STR
PERIOD
PTR
PLUS
INTEGER(0)
PARENCLOSE
PARENCLOSE
SHIFTLEFT
INTEGER(4)
SEMICOLON
RES
PLUSASSIGN
MEMINT_HEXCHARTOINT
PARENOPEN
MEM_READBYTE
PARENOPEN
STR
PERIOD
PTR
PLUS
INTEGER(1)
PARENCLOSE
PARENCLOSE
SHIFTLEFT
INTEGER(0)
SEMICOLON
RES
PLUSASSIGN
MEMINT_HEXCHARTOINT
PARENOPEN
MEM_READBYTE
PARENOPEN
STR
PERIOD
PTR
PLUS
INTEGER(2)
PARENCLOSE
PARENCLOSE
SHIFTLEFT
INTEGER(12)
SEMICOLON
RES
PLUSASSIGN
MEMINT_HEXCHARTOINT
PARENOPEN
MEM_READBYTE
PARENOPEN
STR
PERIOD
PTR
PLUS
INTEGER(3)
PARENCLOSE
PARENCLOSE
SHIFTLEFT
INTEGER(8)
SEMICOLON
RETURN
RES
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
MEM_GETKEY
PARENOPEN
VAR
STRING
NAME
PARENCLOSE
BRACKETOPEN
VAR
STRING
RAW
SEMICOLON
RAW
ASSIGN
MEM_GETGOTHOPT
PARENOPEN
"KEYS"
COMMA
NAME
PARENCLOSE
SEMICOLON
IF
PARENOPEN
STR_LEN
PARENOPEN
RAW
PARENCLOSE
LOWER
INTEGER(4)
PARENCLOSE
BRACKETOPEN
MEM_WARN
PARENOPEN
CONCATSTRINGS
PARENOPEN
"Could not find key with name: "
COMMA
NAME
PARENCLOSE
PARENCLOSE
SEMICOLON
RETURN
INTEGER(0)
SEMICOLON
BRACKETCLOSE
SEMICOLON
RETURN
MEMINT_KEYSTRINGTOKEY
PARENOPEN
RAW
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
MEM_GETSECONDARYKEY
PARENOPEN
VAR
STRING
NAME
PARENCLOSE
BRACKETOPEN
VAR
STRING
RAW
SEMICOLON
RAW
ASSIGN
MEM_GETGOTHOPT
PARENOPEN
"KEYS"
COMMA
NAME
PARENCLOSE
SEMICOLON
//  Nur wenn auch zwei angegeben: 
IF
PARENOPEN
STR_LEN
PARENOPEN
RAW
PARENCLOSE
LOWER
INTEGER(8)
PARENCLOSE
BRACKETOPEN
RETURN
INTEGER(0)
SEMICOLON
// no secondary key
BRACKETCLOSE
SEMICOLON
RAW
ASSIGN
STR_SUBSTR
PARENOPEN
RAW
COMMA
INTEGER(4)
COMMA
INTEGER(4)
PARENCLOSE
SEMICOLON
RETURN
MEMINT_KEYSTRINGTOKEY
PARENOPEN
RAW
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
STRING
MEMINT_BYTETOKEYHEX
PARENOPEN
VAR
INT
BYTE
PARENCLOSE
BRACKETOPEN
CONST
INT
ASCII_0
ASSIGN
INTEGER(48)
SEMICOLON
BYTE
ASSIGN
BYTE
BITAND
INTEGER(255)
SEMICOLON
CONST
INT
MEM
ASSIGN
INTEGER(0)
SEMICOLON
IF
PARENOPEN
NOT
MEM
PARENCLOSE
BRACKETOPEN
MEM
ASSIGN
MEM_ALLOC
PARENOPEN
INTEGER(3)
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
MEM_WRITEBYTE
PARENOPEN
MEM
COMMA
PARENOPEN
BYTE
SHIFTRIGHT
INTEGER(4)
PARENCLOSE
PLUS
ASCII_0
PARENCLOSE
SEMICOLON
MEM_WRITEBYTE
PARENOPEN
MEM
PLUS
INTEGER(1)
COMMA
PARENOPEN
BYTE
BITAND
INTEGER(15)
PARENCLOSE
PLUS
ASCII_0
PARENCLOSE
SEMICOLON
RETURN
STR_FROMCHAR
PARENOPEN
MEM
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEM_SETKEYS
PARENOPEN
VAR
STRING
NAME
COMMA
VAR
INT
PRIMARY
COMMA
VAR
INT
SECONDARY
PARENCLOSE
BRACKETOPEN
VAR
STRING
STR
SEMICOLON
STR
ASSIGN
""
SEMICOLON
STR
ASSIGN
CONCATSTRINGS
PARENOPEN
STR
COMMA
MEMINT_BYTETOKEYHEX
PARENOPEN
PRIMARY
PARENCLOSE
PARENCLOSE
SEMICOLON
STR
ASSIGN
CONCATSTRINGS
PARENOPEN
STR
COMMA
MEMINT_BYTETOKEYHEX
PARENOPEN
PARENOPEN
PRIMARY
SHIFTRIGHT
INTEGER(8)
PARENCLOSE
PARENCLOSE
PARENCLOSE
SEMICOLON
STR
ASSIGN
CONCATSTRINGS
PARENOPEN
STR
COMMA
MEMINT_BYTETOKEYHEX
PARENOPEN
SECONDARY
PARENCLOSE
PARENCLOSE
SEMICOLON
STR
ASSIGN
CONCATSTRINGS
PARENOPEN
STR
COMMA
MEMINT_BYTETOKEYHEX
PARENOPEN
PARENOPEN
SECONDARY
SHIFTRIGHT
INTEGER(8)
PARENCLOSE
PARENCLOSE
PARENCLOSE
SEMICOLON
MEM_SETGOTHOPT
PARENOPEN
"KEYS"
COMMA
NAME
COMMA
STR
PARENCLOSE
SEMICOLON
//  Rebind the keys 
CONST
INT
CALL
ASSIGN
INTEGER(0)
SEMICOLON
IF
PARENOPEN
CALL_BEGIN
PARENOPEN
CALL
PARENCLOSE
PARENCLOSE
BRACKETOPEN
VAR
INT
ZINPUTPTR
SEMICOLON
ZINPUTPTR
ASSIGN
MEMINT_SWITCHG1G2
PARENOPEN
INTEGER(8834208)
COMMA
INTEGER(9246288)
PARENCLOSE
SEMICOLON
VAR
INT
ZCINPUT__BINDKEYS
SEMICOLON
ZCINPUT__BINDKEYS
ASSIGN
MEMINT_SWITCHG1G2
PARENOPEN
INTEGER(5003568)
COMMA
INTEGER(5045760)
PARENCLOSE
SEMICOLON
VAR
INT
NULL
SEMICOLON
CALL_INTPARAM
PARENOPEN
_@
PARENOPEN
NULL
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL__THISCALL
PARENOPEN
ZINPUTPTR
COMMA
ZCINPUT__BINDKEYS
PARENCLOSE
SEMICOLON
CALL
ASSIGN
CALL_END
PARENOPEN
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEM_SETKEY
PARENOPEN
VAR
STRING
NAME
COMMA
VAR
INT
KEY
PARENCLOSE
BRACKETOPEN
MEM_SETKEYS
PARENOPEN
NAME
COMMA
KEY
COMMA
MEM_GETSECONDARYKEY
PARENOPEN
NAME
PARENCLOSE
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEM_SETSECONDARYKEY
PARENOPEN
VAR
STRING
NAME
COMMA
VAR
INT
KEY
PARENCLOSE
BRACKETOPEN
MEM_SETKEYS
PARENOPEN
NAME
COMMA
MEM_GETKEY
PARENOPEN
NAME
PARENCLOSE
COMMA
KEY
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// #################################################
// 
//     Zeitmessung / Benchmark / Speedup
// 
// #################################################
// ************************************************
//  Time Measurement
// ************************************************
FUNC
INT
MEM_GETSYSTEMTIME
PARENOPEN
PARENCLOSE
BRACKETOPEN
CONST
INT
SYSGETTIMEPTR_G1
ASSIGN
INTEGER(5204320)
SEMICOLON
// 0x4F6960;
CONST
INT
SYSGETTIMEPTR_G2
ASSIGN
INTEGER(5264000)
SEMICOLON
// 0x505280;
CONST
INT
CALL
ASSIGN
INTEGER(0)
SEMICOLON
IF
PARENOPEN
CALL_BEGIN
PARENOPEN
CALL
PARENCLOSE
PARENCLOSE
BRACKETOPEN
CALL_PUTRETVALTO
PARENOPEN
_@
PARENOPEN
RET
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL__CDECL
PARENOPEN
MEMINT_SWITCHG1G2
PARENOPEN
SYSGETTIMEPTR_G1
COMMA
SYSGETTIMEPTR_G2
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL
ASSIGN
CALL_END
PARENOPEN
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
VAR
INT
RET
SEMICOLON
RETURN
PLUS
RET
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
MEM_GETPERFORMANCECOUNTER
PARENOPEN
PARENCLOSE
BRACKETOPEN
VAR
INT
BUF
SQUAREOPEN
INTEGER(2)
SQUARECLOSE
SEMICOLON
VAR
INT
SPACE
SEMICOLON
SPACE
ASSIGN
_@
PARENOPEN
BUF
PARENCLOSE
SEMICOLON
CONST
INT
QUERYPERFORMANCECOUNTER_G1
ASSIGN
INTEGER(7712432)
SEMICOLON
// 0x75AEB0
CONST
INT
QUERYPERFORMANCECOUNTER_G2
ASSIGN
INTEGER(8079382)
SEMICOLON
// 0x7B4816
CONST
INT
CALL
ASSIGN
INTEGER(0)
SEMICOLON
IF
PARENOPEN
CALL_BEGIN
PARENOPEN
CALL
PARENCLOSE
PARENCLOSE
BRACKETOPEN
CALL_INTPARAM
PARENOPEN
_@
PARENOPEN
SPACE
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL_PUTRETVALTO
PARENOPEN
INTEGER(0)
PARENCLOSE
SEMICOLON
CALL__STDCALL
PARENOPEN
MEMINT_SWITCHG1G2
PARENOPEN
QUERYPERFORMANCECOUNTER_G1
COMMA
QUERYPERFORMANCECOUNTER_G2
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL
ASSIGN
CALL_END
PARENOPEN
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
RETURN
BUF
SQUAREOPEN
INTEGER(0)
SQUARECLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// ************************************************
//  Benchmark
// ************************************************
FUNC
VOID
MEMINT_BENCHMARK_HELPER
PARENOPEN
PARENCLOSE
BRACKETOPEN
MEMINT_BENCHMARK_HELPER
PARENOPEN
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
CONST
INT
MEMINT_BENCHMARK_MS
ASSIGN
INTEGER(0)
SEMICOLON
CONST
INT
MEMINT_BENCHMARK_PC
ASSIGN
INTEGER(1)
SEMICOLON
CONST
INT
MEMINT_BENCHMARK_MMS
ASSIGN
INTEGER(2)
SEMICOLON
FUNC
INT
MEMINT_BENCHMARK
PARENOPEN
VAR
FUNC
F
COMMA
VAR
INT
TIMES
COMMA
VAR
INT
UNIT
PARENCLOSE
BRACKETOPEN
MEM_WRITEINT
PARENOPEN
MEM_GETFUNCPTR
PARENOPEN
MEMINT_BENCHMARK_HELPER
PARENCLOSE
PLUS
INTEGER(1)
COMMA
// the helper function should call...
MEM_GETFUNCOFFSET
PARENOPEN
F
PARENCLOSE
PARENCLOSE
SEMICOLON
// ... f
VAR
INT
I
SEMICOLON
I
ASSIGN
INTEGER(0)
SEMICOLON
VAR
INT
STARTTIME
SEMICOLON
IF
PARENOPEN
UNIT
EQUALS
MEMINT_BENCHMARK_MS
PARENCLOSE
BRACKETOPEN
STARTTIME
ASSIGN
MEM_GETSYSTEMTIME
PARENOPEN
PARENCLOSE
SEMICOLON
BRACKETCLOSE
ELSE
BRACKETOPEN
STARTTIME
ASSIGN
MEM_GETPERFORMANCECOUNTER
PARENOPEN
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
VAR
INT
LOOP
SEMICOLON
LOOP
ASSIGN
MEM_STACKPOS
PERIOD
POSITION
SEMICOLON
IF
PARENOPEN
I
LOWER
TIMES
PARENCLOSE
BRACKETOPEN
MEMINT_BENCHMARK_HELPER
PARENOPEN
PARENCLOSE
SEMICOLON
I
PLUSASSIGN
INTEGER(1)
SEMICOLON
MEM_STACKPOS
PERIOD
POSITION
ASSIGN
LOOP
SEMICOLON
BRACKETCLOSE
SEMICOLON
IF
PARENOPEN
UNIT
EQUALS
MEMINT_BENCHMARK_MS
PARENCLOSE
BRACKETOPEN
RETURN
MEM_GETSYSTEMTIME
PARENOPEN
PARENCLOSE
MINUS
STARTTIME
SEMICOLON
BRACKETCLOSE
ELSE
BRACKETOPEN
VAR
INT
PC
SEMICOLON
PC
ASSIGN
MEM_GETPERFORMANCECOUNTER
PARENOPEN
PARENCLOSE
MINUS
STARTTIME
SEMICOLON
IF
PARENOPEN
UNIT
EQUALS
MEMINT_BENCHMARK_PC
PARENCLOSE
BRACKETOPEN
RETURN
PC
SEMICOLON
BRACKETCLOSE
ELSE
BRACKETOPEN
IF
PARENOPEN
PC
GREATER
INTEGER(2147483)
PARENCLOSE
BRACKETOPEN
//  cannot multiply by 1000, but the number is large enough\n                 * I do not lose a lot if I divide first. 
RETURN
PARENOPEN
PC
DIVIDE
MEM_READINT
PARENOPEN
PC_TICKSPERMS_ADDRESS
PARENCLOSE
PARENCLOSE
MULTIPLY
INTEGER(1000)
SEMICOLON
BRACKETCLOSE
ELSE
BRACKETOPEN
RETURN
PARENOPEN
PC
MULTIPLY
INTEGER(1000)
PARENCLOSE
DIVIDE
MEM_READINT
PARENOPEN
PC_TICKSPERMS_ADDRESS
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
MEM_BENCHMARKMS
PARENOPEN
VAR
FUNC
F
PARENCLOSE
BRACKETOPEN
RETURN
MEMINT_BENCHMARK
PARENOPEN
F
COMMA
INTEGER(1)
COMMA
MEMINT_BENCHMARK_MS
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
MEM_BENCHMARKMS_N
PARENOPEN
VAR
FUNC
F
COMMA
VAR
INT
N
PARENCLOSE
BRACKETOPEN
RETURN
MEMINT_BENCHMARK
PARENOPEN
F
COMMA
N
COMMA
MEMINT_BENCHMARK_MS
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
MEM_BENCHMARKMMS
PARENOPEN
VAR
FUNC
F
PARENCLOSE
BRACKETOPEN
RETURN
MEMINT_BENCHMARK
PARENOPEN
F
COMMA
INTEGER(1)
COMMA
MEMINT_BENCHMARK_MMS
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
MEM_BENCHMARKMMS_N
PARENOPEN
VAR
FUNC
F
COMMA
VAR
INT
N
PARENCLOSE
BRACKETOPEN
RETURN
MEMINT_BENCHMARK
PARENOPEN
F
COMMA
N
COMMA
MEMINT_BENCHMARK_MMS
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
MEM_BENCHMARKPC
PARENOPEN
VAR
FUNC
F
PARENCLOSE
BRACKETOPEN
RETURN
MEMINT_BENCHMARK
PARENOPEN
F
COMMA
INTEGER(1)
COMMA
MEMINT_BENCHMARK_PC
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
MEM_BENCHMARKPC_N
PARENOPEN
VAR
FUNC
F
COMMA
VAR
INT
N
PARENCLOSE
BRACKETOPEN
RETURN
MEMINT_BENCHMARK
PARENOPEN
F
COMMA
N
COMMA
MEMINT_BENCHMARK_PC
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// #################################################
// 
//     Logging and Debug
// 
// #################################################
// ************************************************
//    SendToSpy
// ************************************************
FUNC
VOID
MEMINT_SENDTOSPY_IMPLEMENTATION
PARENOPEN
VAR
INT
ERRORTYPE
COMMA
VAR
STRING
TEXT
PARENCLOSE
BRACKETOPEN
TEXT
ASSIGN
CONCATSTRINGS
PARENOPEN
"Q: "
COMMA
TEXT
PARENCLOSE
SEMICOLON
// ! = Ikarus
CONST
INT
ZERR_G1
ASSIGN
INTEGER(8821208)
SEMICOLON
// 0x8699D8
CONST
INT
ZERR_G2
ASSIGN
INTEGER(9231568)
SEMICOLON
// 0x8CDCD0
VAR
INT
ZERRPTR
SEMICOLON
ZERRPTR
ASSIGN
MEMINT_SWITCHG1G2
PARENOPEN
ZERR_G1
COMMA
ZERR_G2
PARENCLOSE
SEMICOLON
VAR
ZERROR
ZERR
SEMICOLON
ZERR
ASSIGN
_^
PARENOPEN
ZERRPTR
PARENCLOSE
SEMICOLON
VAR
INT
OLD_ACK_TYPE
SEMICOLON
OLD_ACK_TYPE
ASSIGN
ZERR
PERIOD
ACK_TYPE
SEMICOLON
IF
PARENOPEN
MEMINT_FORCEERRORBOX
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
GOTHIC_BASE_VERSION
EQUALS
INTEGER(1)
PARENCLOSE
BRACKETOPEN
//  There is a warning "lost focus",\n             * that will be printed constantly, unless\n             * I reduce its priority here 
MEMORYPROTECTIONOVERRIDE
PARENOPEN
// 0x4F55C2
INTEGER(5199298)
COMMA
INTEGER(1)
PARENCLOSE
SEMICOLON
MEM_WRITEBYTE
PARENOPEN
INTEGER(5199298)
COMMA
INTEGER(1)
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
ZERR
PERIOD
ACK_TYPE
ASSIGN
ZERR_TYPE_WARN
SEMICOLON
//  Cannot enable Error Box for Infos, because\n         * creating in Error Box creates Infos 
IF
PARENOPEN
ERRORTYPE
LOWER
ZERR_TYPE_WARN
PARENCLOSE
BRACKETOPEN
ERRORTYPE
ASSIGN
ZERR_TYPE_WARN
SEMICOLON
BRACKETCLOSE
SEMICOLON
MEMINT_FORCEERRORBOX
ASSIGN
INTEGER(0)
SEMICOLON
BRACKETCLOSE
ELSE
BRACKETOPEN
ZERR
PERIOD
ACK_TYPE
ASSIGN
ZERR_TYPE_FATAL
SEMICOLON
BRACKETCLOSE
SEMICOLON
CONST
INT
ZERROR_REPORT_G1
ASSIGN
INTEGER(4489808)
SEMICOLON
// 0x448250
CONST
INT
ZERROR_REPORT_G2
ASSIGN
INTEGER(4507856)
SEMICOLON
// 0x44C8D0
VAR
INT
NULL
SEMICOLON
VAR
INT
PTR
SEMICOLON
PTR
ASSIGN
_@S
PARENOPEN
TEXT
PARENCLOSE
SEMICOLON
CONST
INT
CALL
ASSIGN
INTEGER(0)
SEMICOLON
IF
PARENOPEN
CALL_BEGIN
PARENOPEN
CALL
PARENCLOSE
PARENCLOSE
BRACKETOPEN
CALL_PTRPARAM
PARENOPEN
_@
PARENOPEN
NULL
PARENCLOSE
PARENCLOSE
SEMICOLON
// char * function
CALL_PTRPARAM
PARENOPEN
_@
PARENOPEN
NULL
PARENCLOSE
PARENCLOSE
SEMICOLON
// char * file
CALL_INTPARAM
PARENOPEN
_@
PARENOPEN
NULL
PARENCLOSE
PARENCLOSE
SEMICOLON
// int line
CALL_INTPARAM
PARENOPEN
_@
PARENOPEN
NULL
PARENCLOSE
PARENCLOSE
SEMICOLON
// uint flags
CALL_INTPARAM
PARENOPEN
_@
PARENOPEN
NULL
PARENCLOSE
PARENCLOSE
SEMICOLON
// uint level (useless?)
CALL_PTRPARAM
PARENOPEN
_@
PARENOPEN
PTR
PARENCLOSE
PARENCLOSE
SEMICOLON
// zString * message
CALL_PTRPARAM
PARENOPEN
_@
PARENOPEN
NULL
PARENCLOSE
PARENCLOSE
SEMICOLON
// int errorID (useless)
CALL_PTRPARAM
PARENOPEN
_@
PARENOPEN
ERRORTYPE
PARENCLOSE
PARENCLOSE
SEMICOLON
// zERROR_TYPE errorType
CALL_PUTRETVALTO
PARENOPEN
INTEGER(0)
PARENCLOSE
SEMICOLON
CALL__THISCALL
PARENOPEN
_@
PARENOPEN
ZERRPTR
PARENCLOSE
COMMA
MEMINT_SWITCHG1G2
PARENOPEN
ZERROR_REPORT_G1
COMMA
ZERROR_REPORT_G2
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL
ASSIGN
CALL_END
PARENOPEN
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
ZERR
PERIOD
ACK_TYPE
ASSIGN
OLD_ACK_TYPE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// ************************************************
//    Print Stacktrace
// ************************************************
// --------------------------------------
//    Print one line of a stack trace
// --------------------------------------
// Pretty Print
FUNC
VOID
MEMINT_PRINTSTACKTRACELINE
PARENOPEN
VAR
INT
POPPOS
PARENCLOSE
BRACKETOPEN
VAR
INT
VALID
SEMICOLON
IF
PARENOPEN
POPPOS
LOWER
INTEGER(0)
OR
POPPOS
GREATEREQUALS
MEM_PARSER
PERIOD
STACK_STACKSIZE
PARENCLOSE
BRACKETOPEN
VALID
ASSIGN
FALSE
SEMICOLON
BRACKETCLOSE
ELSE
BRACKETOPEN
VALID
ASSIGN
TRUE
SEMICOLON
VAR
INT
FUNCID
SEMICOLON
VAR
ZCPAR_SYMBOL
SYMB
SEMICOLON
FUNCID
ASSIGN
MEM_GETFUNCIDBYOFFSET
PARENOPEN
POPPOS
PARENCLOSE
SEMICOLON
SYMB
ASSIGN
_^
PARENOPEN
MEM_READINTARRAY
PARENOPEN
CONTENTSYMBOLTABLEADDRESS
COMMA
FUNCID
PARENCLOSE
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
CONST
STRING
SPACES
ASSIGN
"                                                                                                    "
SEMICOLON
VAR
STRING
PRT
SEMICOLON
PRT
ASSIGN
STR_PREFIX
PARENOPEN
SPACES
COMMA
INTEGER(8)
PARENCLOSE
SEMICOLON
IF
PARENOPEN
VALID
PARENCLOSE
BRACKETOPEN
PRT
ASSIGN
CONCATSTRINGS
PARENOPEN
PRT
COMMA
SYMB
PERIOD
NAME
PARENCLOSE
SEMICOLON
//  include parameters 
PRT
ASSIGN
CONCATSTRINGS
PARENOPEN
PRT
COMMA
"("
PARENCLOSE
SEMICOLON
VAR
INT
LOOP
SEMICOLON
VAR
INT
I
SEMICOLON
I
ASSIGN
INTEGER(1)
SEMICOLON
LOOP
ASSIGN
MEM_STACKPOS
PERIOD
POSITION
SEMICOLON
IF
PARENOPEN
I
LOWEREQUALS
PARENOPEN
SYMB
PERIOD
BITFIELD
BITAND
ZCPAR_SYMBOL_BITFIELD_ELE
PARENCLOSE
PARENCLOSE
BRACKETOPEN
VAR
ZCPAR_SYMBOL
PARAM
SEMICOLON
PARAM
ASSIGN
_^
PARENOPEN
MEM_READINTARRAY
PARENOPEN
CURRSYMBOLTABLEADDRESS
COMMA
FUNCID
PLUS
I
PARENCLOSE
PARENCLOSE
SEMICOLON
IF
PARENOPEN
I
GREATER
INTEGER(1)
PARENCLOSE
BRACKETOPEN
PRT
ASSIGN
CONCATSTRINGS
PARENOPEN
PRT
COMMA
", "
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
IF
PARENOPEN
PARENOPEN
PARAM
PERIOD
BITFIELD
BITAND
ZCPAR_SYMBOL_BITFIELD_TYPE
PARENCLOSE
EQUALS
ZPAR_TYPE_INT
PARENCLOSE
BRACKETOPEN
PRT
ASSIGN
CONCATSTRINGS
PARENOPEN
PRT
COMMA
INTTOSTRING
PARENOPEN
PARAM
PERIOD
CONTENT
PARENCLOSE
PARENCLOSE
SEMICOLON
BRACKETCLOSE
ELSE
IF
PARENOPEN
PARENOPEN
PARAM
PERIOD
BITFIELD
BITAND
ZCPAR_SYMBOL_BITFIELD_TYPE
PARENCLOSE
EQUALS
ZPAR_TYPE_STRING
PARENCLOSE
BRACKETOPEN
PRT
ASSIGN
CONCATSTRINGS
PARENOPEN
PRT
COMMA
"'"
PARENCLOSE
SEMICOLON
PRT
ASSIGN
CONCATSTRINGS
PARENOPEN
PRT
COMMA
MEM_READSTRING
PARENOPEN
PARAM
PERIOD
CONTENT
PARENCLOSE
PARENCLOSE
SEMICOLON
PRT
ASSIGN
CONCATSTRINGS
PARENOPEN
PRT
COMMA
"'"
PARENCLOSE
SEMICOLON
BRACKETCLOSE
ELSE
IF
PARENOPEN
PARENOPEN
PARAM
PERIOD
BITFIELD
BITAND
ZCPAR_SYMBOL_BITFIELD_TYPE
PARENCLOSE
EQUALS
ZPAR_TYPE_FUNC
PARENCLOSE
BRACKETOPEN
VAR
ZCPAR_SYMBOL
FUNCPARM
SEMICOLON
FUNCPARM
ASSIGN
_^
PARENOPEN
MEM_READINTARRAY
PARENOPEN
CURRSYMBOLTABLEADDRESS
COMMA
PARAM
PERIOD
CONTENT
PARENCLOSE
PARENCLOSE
SEMICOLON
PRT
ASSIGN
CONCATSTRINGS
PARENOPEN
PRT
COMMA
FUNCPARM
PERIOD
NAME
PARENCLOSE
SEMICOLON
//  too lazy to follow the chain back in case there is one 
BRACKETCLOSE
ELSE
IF
PARENOPEN
PARENOPEN
PARAM
PERIOD
BITFIELD
BITAND
ZCPAR_SYMBOL_BITFIELD_TYPE
PARENCLOSE
EQUALS
ZPAR_TYPE_INSTANCE
PARENCLOSE
BRACKETOPEN
PRT
ASSIGN
CONCATSTRINGS
PARENOPEN
PRT
COMMA
"(instance)"
PARENCLOSE
SEMICOLON
PRT
ASSIGN
CONCATSTRINGS
PARENOPEN
PRT
COMMA
INTTOSTRING
PARENOPEN
PARAM
PERIOD
OFFSET
PARENCLOSE
PARENCLOSE
SEMICOLON
BRACKETCLOSE
ELSE
BRACKETOPEN
PRT
ASSIGN
CONCATSTRINGS
PARENOPEN
PRT
COMMA
"[Parameter of Unknown type]"
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
I
PLUSASSIGN
INTEGER(1)
SEMICOLON
MEM_STACKPOS
PERIOD
POSITION
ASSIGN
LOOP
SEMICOLON
BRACKETCLOSE
SEMICOLON
PRT
ASSIGN
CONCATSTRINGS
PARENOPEN
PRT
COMMA
")"
PARENCLOSE
SEMICOLON
BRACKETCLOSE
ELSE
BRACKETOPEN
PRT
ASSIGN
CONCATSTRINGS
PARENOPEN
PRT
COMMA
"[UNKNOWN]"
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
IF
PARENOPEN
STR_LEN
PARENOPEN
PRT
PARENCLOSE
LOWER
INTEGER(70)
PARENCLOSE
BRACKETOPEN
PRT
ASSIGN
CONCATSTRINGS
PARENOPEN
PRT
COMMA
STR_PREFIX
PARENOPEN
SPACES
COMMA
INTEGER(70)
MINUS
STR_LEN
PARENOPEN
PRT
PARENCLOSE
PARENCLOSE
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
PRT
ASSIGN
CONCATSTRINGS
PARENOPEN
PRT
COMMA
" +"
PARENCLOSE
SEMICOLON
VAR
STRING
BYTES
SEMICOLON
IF
PARENOPEN
VALID
PARENCLOSE
BRACKETOPEN
BYTES
ASSIGN
INTTOSTRING
PARENOPEN
POPPOS
MINUS
SYMB
PERIOD
CONTENT
PARENCLOSE
SEMICOLON
BRACKETCLOSE
ELSE
BRACKETOPEN
BYTES
ASSIGN
INTTOSTRING
PARENOPEN
POPPOS
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
IF
PARENOPEN
STR_LEN
PARENOPEN
BYTES
PARENCLOSE
LOWER
INTEGER(5)
PARENCLOSE
BRACKETOPEN
BYTES
ASSIGN
CONCATSTRINGS
PARENOPEN
STR_PREFIX
PARENOPEN
SPACES
COMMA
INTEGER(5)
MINUS
STR_LEN
PARENOPEN
BYTES
PARENCLOSE
PARENCLOSE
COMMA
BYTES
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
BYTES
ASSIGN
CONCATSTRINGS
PARENOPEN
BYTES
COMMA
" bytes"
PARENCLOSE
SEMICOLON
PRT
ASSIGN
CONCATSTRINGS
PARENOPEN
PRT
COMMA
BYTES
PARENCLOSE
SEMICOLON
MEM_SENDTOSPY
PARENOPEN
ZERR_TYPE_FAULT
COMMA
PRT
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// --------------------------------------
//    Print Stack Trace when
//    called from a daedalus function
// --------------------------------------
FUNC
VOID
MEMINT_PRINTSTACKTRACE_IMPLEMENTATION
PARENOPEN
PARENCLOSE
BRACKETOPEN
MEM_SENDTOSPY
PARENOPEN
ZERR_TYPE_FAULT
COMMA
"[start of stacktrace]"
PARENCLOSE
SEMICOLON
VAR
INT
ESP
SEMICOLON
ESP
ASSIGN
MEMINT_FINDFRAMEBOUNDARY
PARENOPEN
MEMINT_GETESP
PARENOPEN
PARENCLOSE
COMMA
MINUS
INTEGER(1)
PARENCLOSE
SEMICOLON
//  the first thing that looks like a frame boundary\n     * for MEMINT_FindFrameBoundary WILL NOT look like that\n     * from here, because I am further down in the stack: 
ESP
PLUSASSIGN
MEMINT_DOSTACKFRAMESIZE
SEMICOLON
//  sehr ungünstig: Im Stackframe der Funktion steht gar nicht die\n     * aktuelle PopPos, die steht nur im Stackframe desjenigen obendrüber\n     * wo der sie eben grade pushen wollte: 
VAR
INT
PASSEDMYSELF
SEMICOLON
PASSEDMYSELF
ASSIGN
INTEGER(0)
SEMICOLON
VAR
INT
MYSELF
SEMICOLON
MYSELF
ASSIGN
MEM_GETFUNCID
PARENOPEN
MEMINT_PRINTSTACKTRACE_IMPLEMENTATION
PARENCLOSE
SEMICOLON
VAR
INT
LOOP
SEMICOLON
LOOP
ASSIGN
MEM_STACKPOS
PERIOD
POSITION
SEMICOLON
//  while 
//  I am at the start of a DoStack Frame,\n         * get the function that is called here: 
VAR
INT
POPPOS
SEMICOLON
POPPOS
ASSIGN
MEM_READINT
PARENOPEN
ESP
MINUS
MEMINT_DOSTACKPOPPOSOFFSET
PARENCLOSE
SEMICOLON
IF
PARENOPEN
PASSEDMYSELF
PARENCLOSE
BRACKETOPEN
MEMINT_PRINTSTACKTRACELINE
PARENOPEN
POPPOS
PARENCLOSE
SEMICOLON
BRACKETCLOSE
ELSE
IF
PARENOPEN
POPPOS
LOWER
MEM_PARSER
PERIOD
STACK_STACKSIZE
PARENCLOSE
BRACKETOPEN
VAR
INT
FUNCID
SEMICOLON
FUNCID
ASSIGN
MEM_GETFUNCIDBYOFFSET
PARENOPEN
POPPOS
PARENCLOSE
SEMICOLON
PASSEDMYSELF
ASSIGN
PARENOPEN
FUNCID
EQUALS
MYSELF
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
//  Is there another DoStack directly und me? 
IF
PARENOPEN
MEMINT_ISFRAMEBOUNDARY
PARENOPEN
ESP
PARENCLOSE
PARENCLOSE
BRACKETOPEN
//  go on searching! 
ESP
PLUSASSIGN
MEMINT_DOSTACKFRAMESIZE
SEMICOLON
MEM_STACKPOS
PERIOD
POSITION
ASSIGN
LOOP
SEMICOLON
BRACKETCLOSE
SEMICOLON
//  end while 
MEM_SENDTOSPY
PARENOPEN
ZERR_TYPE_FAULT
COMMA
"[end of stacktrace]"
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// --------------------------------------
//    Print Stack Trace when the SEH
//    of DoStack is called.
// --------------------------------------
VAR
INT
MEMINT_EXCEPTIONHANDLERESP
SEMICOLON
//  where start looking for stacktrace? 
VAR
INT
MEMINT_TOPPOPPOS
SEMICOLON
//  the PopPos of the (probably crashed) DoStack Instance. 
FUNC
VOID
MEMINT_EXCEPTIONHANDLER
PARENOPEN
PARENCLOSE
BRACKETOPEN
CONST
INT
INVOKED_ONCE
ASSIGN
INTEGER(0)
SEMICOLON
IF
PARENOPEN
NOT
INVOKED_ONCE
PARENCLOSE
BRACKETOPEN
INVOKED_ONCE
ASSIGN
TRUE
SEMICOLON
MEM_SENDTOSPY
PARENOPEN
ZERR_TYPE_FAULT
COMMA
"[start of stacktrace]"
PARENCLOSE
SEMICOLON
MEMINT_PRINTSTACKTRACELINE
PARENOPEN
MEMINT_TOPPOPPOS
MINUS
MEM_PARSER
PERIOD
STACK_STACK
PARENCLOSE
SEMICOLON
VAR
INT
ESP
SEMICOLON
ESP
ASSIGN
MEMINT_FINDFRAMEBOUNDARY
PARENOPEN
MEMINT_EXCEPTIONHANDLERESP
COMMA
INTEGER(500)
PARENCLOSE
SEMICOLON
//  There may not be a frame boundary if there is a crash in the bottommost function 
IF
PARENOPEN
ESP
PARENCLOSE
BRACKETOPEN
//  note: the first has to be handled differently and was handled above 
ESP
PLUSASSIGN
MEMINT_DOSTACKFRAMESIZE
SEMICOLON
VAR
INT
LOOP
SEMICOLON
LOOP
ASSIGN
MEM_STACKPOS
PERIOD
POSITION
SEMICOLON
MEMINT_PRINTSTACKTRACELINE
PARENOPEN
MEM_READINT
PARENOPEN
ESP
MINUS
MEMINT_DOSTACKPOPPOSOFFSET
PARENCLOSE
PARENCLOSE
SEMICOLON
IF
PARENOPEN
MEMINT_ISFRAMEBOUNDARY
PARENOPEN
ESP
PARENCLOSE
PARENCLOSE
BRACKETOPEN
ESP
PLUSASSIGN
MEMINT_DOSTACKFRAMESIZE
SEMICOLON
MEM_STACKPOS
PERIOD
POSITION
ASSIGN
LOOP
SEMICOLON
BRACKETCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
MEM_SENDTOSPY
PARENOPEN
ZERR_TYPE_FAULT
COMMA
"[end of stacktrace]"
PARENCLOSE
SEMICOLON
MEM_ERRORBOX
PARENOPEN
"Exception handler was invoked. Ikarus tried to print a Daedalus-Stacktrace to zSpy. Gothic will now crash and probably give you a stacktrace of its own."
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
//  Try to catch exceptions: 
FUNC
VOID
MEMINT_SETUPEXCEPTIONHANDLER
PARENOPEN
PARENCLOSE
BRACKETOPEN
CONST
INT
CALL
ASSIGN
INTEGER(0)
SEMICOLON
IF
PARENOPEN
NOT
CALL
PARENCLOSE
BRACKETOPEN
CALL_OPEN
PARENOPEN
PARENCLOSE
SEMICOLON
VAR
INT
HANDLEROFFSET
SEMICOLON
HANDLEROFFSET
ASSIGN
MEM_GETFUNCOFFSET
PARENOPEN
MEMINT_EXCEPTIONHANDLER
PARENCLOSE
SEMICOLON
ASM_1
PARENOPEN
ASMINT_OP_MOVMEMTOEAX
PARENCLOSE
SEMICOLON
ASM_4
PARENOPEN
_@
PARENOPEN
MEM_PARSER
PERIOD
STACK_STACKPTR
PARENCLOSE
PARENCLOSE
SEMICOLON
ASM_2
PARENOPEN
ASMINT_OP_MOVEAXTOMEM
PARENCLOSE
SEMICOLON
ASM_4
PARENOPEN
_@
PARENOPEN
MEMINT_TOPPOPPOS
PARENCLOSE
PARENCLOSE
SEMICOLON
ASM_2
PARENOPEN
ASMINT_OP_MOVESPTOEAX
PARENCLOSE
SEMICOLON
ASM_2
PARENOPEN
ASMINT_OP_MOVEAXTOMEM
PARENCLOSE
SEMICOLON
ASM_4
PARENOPEN
_@
PARENOPEN
MEMINT_EXCEPTIONHANDLERESP
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL_INTPARAM
PARENOPEN
_@
PARENOPEN
HANDLEROFFSET
PARENCLOSE
PARENCLOSE
SEMICOLON
CONST
INT
ZCPARSER__DOSTACK_G1
ASSIGN
INTEGER(7243264)
SEMICOLON
// 0x6E8600
CONST
INT
ZCPARSER__DOSTACK_G2
ASSIGN
INTEGER(7936352)
SEMICOLON
// 0x791960
CALL_PUTRETVALTO
PARENOPEN
INTEGER(0)
PARENCLOSE
SEMICOLON
CALL__THISCALL
PARENOPEN
_@
PARENOPEN
CONTENTPARSERADDRESS
PARENCLOSE
COMMA
MEMINT_SWITCHG1G2
PARENOPEN
ZCPARSER__DOSTACK_G1
COMMA
ZCPARSER__DOSTACK_G2
PARENCLOSE
PARENCLOSE
SEMICOLON
//  now jump to the original handler (whatever that one is doing) 
CONST
INT
ZCPARSER__DOSTACK_SEH_G1
ASSIGN
INTEGER(8146176)
SEMICOLON
// 0x7C4D00
CONST
INT
ZCPARSER__DOSTACK_SEH_G2
ASSIGN
INTEGER(8562816)
SEMICOLON
// 0x82A880
VAR
INT
SEH
SEMICOLON
SEH
ASSIGN
MEMINT_SWITCHG1G2
PARENOPEN
ZCPARSER__DOSTACK_SEH_G1
COMMA
ZCPARSER__DOSTACK_SEH_G2
PARENCLOSE
SEMICOLON
ASM_1
PARENOPEN
ASMINT_OP_JMP
PARENCLOSE
SEMICOLON
ASM_4
PARENOPEN
SEH
MINUS
PARENOPEN
ASM_HERE
PARENOPEN
PARENCLOSE
PLUS
INTEGER(4)
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL
ASSIGN
CALL_CLOSE
PARENOPEN
PARENCLOSE
SEMICOLON
//  install the exception handler: 
CONST
INT
ZCPARSER__DOSTACK_SEH_PUSHER_G1
ASSIGN
INTEGER(7243266)
PLUS
INTEGER(1)
SEMICOLON
// 0x6E8602 + 1
CONST
INT
ZCPARSER__DOSTACK_SEH_PUSHER_G2
ASSIGN
INTEGER(7936354)
PLUS
INTEGER(1)
SEMICOLON
// 0x791962 + 1
VAR
INT
SEHPUSHER
SEMICOLON
SEHPUSHER
ASSIGN
MEMINT_SWITCHG1G2
PARENOPEN
ZCPARSER__DOSTACK_SEH_PUSHER_G1
COMMA
ZCPARSER__DOSTACK_SEH_PUSHER_G2
PARENCLOSE
SEMICOLON
MEMORYPROTECTIONOVERRIDE
PARENOPEN
SEHPUSHER
COMMA
INTEGER(4)
PARENCLOSE
SEMICOLON
MEM_WRITEINT
PARENOPEN
SEHPUSHER
COMMA
CALL
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// ************************************************
//    Setup Print Functions and SEH
// ************************************************
FUNC
VOID
MEMINT_REPLACELOGGINGFUNCTIONS
PARENOPEN
PARENCLOSE
BRACKETOPEN
CONST
INT
INIT
ASSIGN
INTEGER(0)
SEMICOLON
IF
PARENOPEN
NOT
INIT
PARENCLOSE
BRACKETOPEN
INIT
ASSIGN
TRUE
SEMICOLON
MEM_INFO
PARENOPEN
"This will be the last Ikarus message printed with PrintDebug and prefix 'U: Skript:'. Subsequent messages will be printed with prefix 'Q:'."
PARENCLOSE
SEMICOLON
MEM_REPLACEFUNC
PARENOPEN
MEM_SENDTOSPY
COMMA
MEMINT_SENDTOSPY_IMPLEMENTATION
PARENCLOSE
SEMICOLON
MEM_INFO
PARENOPEN
"Ikarus log functions now print in colour with prefix 'Q:'."
PARENCLOSE
SEMICOLON
MEM_REPLACEFUNC
PARENOPEN
MEM_PRINTSTACKTRACE
COMMA
MEMINT_PRINTSTACKTRACE_IMPLEMENTATION
PARENCLOSE
SEMICOLON
MEMINT_SETUPEXCEPTIONHANDLER
PARENOPEN
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// #################################################
// 
//           Revised functions
// 
//   With the more elaborate functions of Ikarus
//   it is possible to speed up the basis of Ikarus.
//   
//   Keep names simular, so they don't confuse people
//   when they see them on the callstack.
// 
// #################################################
// ************************************************
//    Faster  Read / Write
// ************************************************
FUNC
VOID
MEM_READINT_
PARENOPEN
PARENCLOSE
BRACKETOPEN
VAR
INT
I
SEMICOLON
I
ASSIGN
I
SEMICOLON
I
ASSIGN
I
SEMICOLON
I
ASSIGN
I
SEMICOLON
I
ASSIGN
I
SEMICOLON
I
ASSIGN
I
SEMICOLON
I
ASSIGN
I
SEMICOLON
I
ASSIGN
I
SEMICOLON
I
ASSIGN
I
SEMICOLON
I
ASSIGN
I
SEMICOLON
I
ASSIGN
I
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEM_WRITEINT_
PARENOPEN
PARENCLOSE
BRACKETOPEN
VAR
INT
I
SEMICOLON
I
ASSIGN
I
SEMICOLON
I
ASSIGN
I
SEMICOLON
I
ASSIGN
I
SEMICOLON
I
ASSIGN
I
SEMICOLON
I
ASSIGN
I
SEMICOLON
I
ASSIGN
I
SEMICOLON
I
ASSIGN
I
SEMICOLON
I
ASSIGN
I
SEMICOLON
I
ASSIGN
I
SEMICOLON
I
ASSIGN
I
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEMINT_INITFASTERREADWRITE
PARENOPEN
PARENCLOSE
BRACKETOPEN
VAR
MEMINT_HELPERCLASS
SYMB
SEMICOLON
MEMINT_INITOVERIDEFUNC
PARENOPEN
MEM_READINT_
PARENCLOSE
SEMICOLON
//  The following is a fast rewrite of MEM_ReadInt 
// 1. whatever is on the stack, make an RValue out of it:
MEMINT_OFTOK
PARENOPEN
ZPAR_OP_UN_PLUS
PARENCLOSE
SEMICOLON
// 2. exchange PUSHINST with PUSHVAR
MEMINT_OFTOKPAR
PARENOPEN
ZPAR_TOK_PUSHINST
COMMA
SYMB
PARENCLOSE
SEMICOLON
MEMINT_OFTOK
PARENOPEN
ZPAR_TOK_ASSIGNINST
PARENCLOSE
SEMICOLON
MEMINT_OFTOKPAR
PARENOPEN
ZPAR_TOK_PUSHINST
COMMA
ZPAR_TOK_PUSHVAR
PARENCLOSE
SEMICOLON
// 3. Return as RValue:
MEMINT_OFTOK
PARENOPEN
ZPAR_OP_UN_PLUS
PARENCLOSE
SEMICOLON
MEMINT_OFTOK
PARENOPEN
ZPAR_TOK_RET
PARENCLOSE
SEMICOLON
MEM_REPLACEFUNC
PARENOPEN
MEM_READINT
COMMA
MEM_READINT_
PARENCLOSE
SEMICOLON
//  now a faster rewrite of MEM_WriteInt 
VAR
INT
ID
SEMICOLON
ID
ASSIGN
MEM_GETFUNCID
PARENOPEN
MEM_WRITEINT
PARENCLOSE
SEMICOLON
MEMINT_INITOVERIDEFUNC
PARENOPEN
MEM_WRITEINT_
PARENCLOSE
SEMICOLON
// 1. save the second paremter in temporary location:
MEMINT_OFTOKPAR
PARENOPEN
ZPAR_TOK_PUSHVAR
COMMA
ID
PLUS
INTEGER(2)
//  [val] 
PARENCLOSE
SEMICOLON
MEMINT_OFTOK
PARENOPEN
ZPAR_OP_IS
PARENCLOSE
SEMICOLON
// 2. save the first parameter in temporary location:
MEMINT_OFTOKPAR
PARENOPEN
ZPAR_TOK_PUSHVAR
COMMA
ID
PLUS
INTEGER(1)
//  [adr] 
PARENCLOSE
SEMICOLON
MEMINT_OFTOK
PARENOPEN
ZPAR_OP_IS
PARENCLOSE
SEMICOLON
// 3. Push them in reverse order:
MEMINT_OFTOKPAR
PARENOPEN
ZPAR_TOK_PUSHVAR
COMMA
ID
PLUS
INTEGER(2)
//  [val] 
PARENCLOSE
SEMICOLON
MEMINT_OFTOKPAR
PARENOPEN
ZPAR_TOK_PUSHVAR
COMMA
ID
PLUS
INTEGER(1)
//  [adr] 
PARENCLOSE
SEMICOLON
// 4. make an RValue out of the address:
MEMINT_OFTOK
PARENOPEN
ZPAR_OP_UN_PLUS
PARENCLOSE
SEMICOLON
// 5. exchange PUSHINST with PUSHVAR
MEMINT_OFTOKPAR
PARENOPEN
ZPAR_TOK_PUSHINST
COMMA
SYMB
PARENCLOSE
SEMICOLON
MEMINT_OFTOK
PARENOPEN
ZPAR_TOK_ASSIGNINST
PARENCLOSE
SEMICOLON
MEMINT_OFTOKPAR
PARENOPEN
ZPAR_TOK_PUSHINST
COMMA
ZPAR_TOK_PUSHVAR
PARENCLOSE
SEMICOLON
// 6. Assign and return:
MEMINT_OFTOK
PARENOPEN
ZPAR_OP_IS
PARENCLOSE
SEMICOLON
MEMINT_OFTOK
PARENOPEN
ZPAR_TOK_RET
PARENCLOSE
SEMICOLON
//  Vorsicht, MEM_ReplaceFunc(MEM_WriteInt, MEM_WriteInt_);\n     * kann so nicht funktionieren, schließlich wird MEM_WriteInt dazu gebraucht 
VAR
INT
BUF
SEMICOLON
BUF
ASSIGN
MEM_ALLOC
PARENOPEN
INTEGER(5)
PARENCLOSE
SEMICOLON
MEM_WRITEBYTE
PARENOPEN
BUF
COMMA
ZPAR_TOK_JUMP
PARENCLOSE
SEMICOLON
MEM_WRITEINT
PARENOPEN
BUF
PLUS
INTEGER(1)
COMMA
MEM_GETFUNCOFFSET
PARENOPEN
MEM_WRITEINT_
PARENCLOSE
PARENCLOSE
SEMICOLON
MEM_COPYBYTES
PARENOPEN
BUF
COMMA
MEM_GETFUNCPTR
PARENOPEN
MEM_WRITEINT
PARENCLOSE
COMMA
INTEGER(5)
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEMINT_INITFASTERPUSHINST
PARENOPEN
PARENCLOSE
BRACKETOPEN
VAR
MEMINT_HELPERCLASS
SYMB
SEMICOLON
MEMINT_INITOVERIDEFUNC
PARENOPEN
MEMINT_STACKPUSHINST
PARENCLOSE
SEMICOLON
MEMINT_OFTOK
PARENOPEN
ZPAR_OP_UN_PLUS
PARENCLOSE
SEMICOLON
MEMINT_OFTOKPAR
PARENOPEN
ZPAR_TOK_PUSHINST
COMMA
SYMB
PARENCLOSE
SEMICOLON
MEMINT_OFTOK
PARENOPEN
ZPAR_TOK_ASSIGNINST
PARENCLOSE
SEMICOLON
MEMINT_OFTOK
PARENOPEN
ZPAR_TOK_RET
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// ************************************************
//    Faster MEM_Alloc, MEM_Free
// ************************************************
FUNC
INT
MEM_ALLOC_
PARENOPEN
VAR
INT
ELE
PARENCLOSE
BRACKETOPEN
VAR
INT
SIZE
SEMICOLON
SIZE
ASSIGN
INTEGER(1)
SEMICOLON
CONST
INT
CALL
ASSIGN
INTEGER(0)
SEMICOLON
IF
PARENOPEN
CALL_BEGIN
PARENOPEN
CALL
PARENCLOSE
PARENCLOSE
BRACKETOPEN
VAR
INT
CALLOC_PTR
SEMICOLON
CALLOC_PTR
ASSIGN
MEMINT_SWITCHG1G2
PARENOPEN
INTEGER(7712240)
// 0x75ADF0
COMMA
INTEGER(8078576)
// 0x7B44F0
PARENCLOSE
SEMICOLON
CALL_INTPARAM
PARENOPEN
_@
PARENOPEN
SIZE
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL_INTPARAM
PARENOPEN
_@
PARENOPEN
ELE
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL_PUTRETVALTO
PARENOPEN
_@
PARENOPEN
RET
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL__CDECL
PARENOPEN
CALLOC_PTR
PARENCLOSE
SEMICOLON
CALL
ASSIGN
CALL_END
PARENOPEN
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
VAR
INT
RET
SEMICOLON
RETURN
PLUS
RET
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEM_FREE_
PARENOPEN
VAR
INT
PTR
PARENCLOSE
BRACKETOPEN
//  keine Nuller freigeben 
IF
PARENOPEN
NOT
PTR
PARENCLOSE
BRACKETOPEN
MEM_WARN
PARENOPEN
"MEM_Free: ptr is 0. Ignoring request."
PARENCLOSE
SEMICOLON
RETURN
SEMICOLON
BRACKETCLOSE
SEMICOLON
CONST
INT
CALL
ASSIGN
INTEGER(0)
SEMICOLON
IF
PARENOPEN
CALL_BEGIN
PARENOPEN
CALL
PARENCLOSE
PARENCLOSE
BRACKETOPEN
VAR
INT
FREE_PTR
SEMICOLON
FREE_PTR
ASSIGN
MEMINT_SWITCHG1G2
PARENOPEN
INTEGER(7712111)
// 0x75AD6F
COMMA
INTEGER(8078540)
// 0x7B44CC
PARENCLOSE
SEMICOLON
CALL_INTPARAM
PARENOPEN
_@
PARENOPEN
PTR
PARENCLOSE
PARENCLOSE
SEMICOLON
CALL_PUTRETVALTO
PARENOPEN
INTEGER(0)
PARENCLOSE
SEMICOLON
CALL__CDECL
PARENOPEN
FREE_PTR
PARENCLOSE
SEMICOLON
CALL
ASSIGN
CALL_END
PARENOPEN
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// ************************************************
//    The actual replacement
// ************************************************
FUNC
VOID
MEMINT_REPLACESLOWFUNCTIONS
PARENOPEN
PARENCLOSE
BRACKETOPEN
CONST
INT
INIT
ASSIGN
INTEGER(0)
SEMICOLON
IF
PARENOPEN
NOT
INIT
PARENCLOSE
BRACKETOPEN
INIT
ASSIGN
TRUE
SEMICOLON
//  the following line is needed to set up the calls with the OLD\n         * MEM_Alloc function. Call needs MEM_Alloc for setting up\n         * the call, and since the NEW MEM_Alloc needs CALL\n         * this would certainly not be a good idea. ;-)\n         *\n         * Wow this is confusing... 
MEM_FREE_
PARENOPEN
MEM_ALLOC_
PARENOPEN
INTEGER(1)
PARENCLOSE
PARENCLOSE
SEMICOLON
MEM_REPLACEFUNC
PARENOPEN
MEM_ALLOC
COMMA
MEM_ALLOC_
PARENCLOSE
SEMICOLON
MEM_REPLACEFUNC
PARENOPEN
MEM_FREE
COMMA
MEM_FREE_
PARENCLOSE
SEMICOLON
MEMINT_INITFASTERREADWRITE
PARENOPEN
PARENCLOSE
SEMICOLON
MEMINT_INITFASTERPUSHINST
PARENOPEN
PARENCLOSE
SEMICOLON
MEM_REPLACEFUNC
PARENOPEN
_^
COMMA
MEM_PTRTOINST
PARENCLOSE
SEMICOLON
// forwarding so billiger
BRACKETCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
// #################################################################
// 
//   Initialise everything
// 
// #################################################################
FUNC
VOID
MEMINT_VERSIONERROR
PARENOPEN
PARENCLOSE
BRACKETOPEN
CONST
STRING
G1
ASSIGN
"Gothic 1.08k"
SEMICOLON
CONST
STRING
G2
ASSIGN
"der sogenannten 'Report-Version' von Gothic 2"
SEMICOLON
CONST
STRING
G2EN
ASSIGN
"the so-called 'Report-Version' of Gothic 2"
SEMICOLON
VAR
STRING
STR
SEMICOLON
STR
ASSIGN
"Diese Mod funktioniert nur mit "
SEMICOLON
IF
PARENOPEN
GOTHIC_BASE_VERSION
EQUALS
INTEGER(1)
PARENCLOSE
BRACKETOPEN
STR
ASSIGN
CONCATSTRINGS
PARENOPEN
STR
COMMA
G1
PARENCLOSE
SEMICOLON
BRACKETCLOSE
ELSE
BRACKETOPEN
STR
ASSIGN
CONCATSTRINGS
PARENOPEN
STR
COMMA
G2
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
STR
ASSIGN
CONCATSTRINGS
PARENOPEN
STR
COMMA
", da sie Funktionalität aus dem Skriptpaket 'Ikarus' verwendet. Es ist wahrscheinlich, dass Gothic unmittelbar nach dieser Fehlermeldung abstürzt. Die genannte Version von Gothic steht zum Beispiel auf worldofgothic.de zum Download bereit. Der merkwürdige Charakter dieser Fehlermeldung ist leider nicht zu vermeiden. ### This mod only works with "
PARENCLOSE
SEMICOLON
IF
PARENOPEN
GOTHIC_BASE_VERSION
EQUALS
INTEGER(1)
PARENCLOSE
BRACKETOPEN
STR
ASSIGN
CONCATSTRINGS
PARENOPEN
STR
COMMA
G1
PARENCLOSE
SEMICOLON
BRACKETCLOSE
ELSE
BRACKETOPEN
STR
ASSIGN
CONCATSTRINGS
PARENOPEN
STR
COMMA
G2EN
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
STR
ASSIGN
CONCATSTRINGS
PARENOPEN
STR
COMMA
", because it uses parts of the script package 'Ikarus'. Gothic will probably crash immediatly after displaying this error message. Said version of Gothic is available for download at worldofgothic.com. The weirdness of this error message is unavoidable.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                !README!                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           "
PARENCLOSE
SEMICOLON
WLD_INSERTOBJECT
PARENOPEN
STR
COMMA
MEM_FARFARAWAY
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
INT
MEMINT_REPORTVERSIONCHECK
PARENOPEN
PARENCLOSE
BRACKETOPEN
//  In both G1 and G2 the first Instruction at address\n     * 0x401000 is some mov instruction moving some data\n     * from some location within the data section.\n     * This makes this check reliable 
VAR
INT
VAL
SEMICOLON
VAL
ASSIGN
MEMINT_SWITCHG1G2
PARENOPEN
MINUS
INTEGER(521402937)
COMMA
INTEGER(504628679)
PARENCLOSE
SEMICOLON
VAR
INT
PTR
SEMICOLON
PTR
ASSIGN
INTEGER(4198400)
SEMICOLON
// 0x401000
IF
PARENOPEN
MEM_READINT
PARENOPEN
PTR
PARENCLOSE
NOTEQUALS
VAL
PARENCLOSE
BRACKETOPEN
//  Error-Message does not work for Gothic 1. I have no idea how to fix that. 
MEMINT_VERSIONERROR
PARENOPEN
PARENCLOSE
SEMICOLON
RETURN
FALSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
RETURN
TRUE
SEMICOLON
BRACKETCLOSE
SEMICOLON
FUNC
VOID
MEM_INITALL
PARENOPEN
PARENCLOSE
BRACKETOPEN
IF
PARENOPEN
NOT
MEMINT_REPORTVERSIONCHECK
PARENOPEN
PARENCLOSE
PARENCLOSE
BRACKETOPEN
RETURN
SEMICOLON
BRACKETCLOSE
SEMICOLON
MEM_REINITPARSER
PARENOPEN
PARENCLOSE
SEMICOLON
//  depends on nothing 
MEM_INITLABELS
PARENOPEN
PARENCLOSE
SEMICOLON
//  depends in MEM_ReinitParser 
MEM_INITGLOBALINST
PARENOPEN
PARENCLOSE
SEMICOLON
//  depends on MEM_ReinitParser 
//  now I can use MEM_ReplaceFunc, MEM_GetFuncID 
MEM_GETADDRESS_INIT
PARENOPEN
PARENCLOSE
SEMICOLON
//  depends on MEM_ReinitParser and MEM_InitLabels 
//  now the nicer operators are available 
MEM_INITSTATARRS
PARENOPEN
PARENCLOSE
SEMICOLON
//  depends on MEM_ReinitParser and MEM_InitLabels 
ASMINT_INIT
PARENOPEN
PARENCLOSE
SEMICOLON
MEMINT_REPLACELOGGINGFUNCTIONS
PARENOPEN
PARENCLOSE
SEMICOLON
MEMINT_REPLACESLOWFUNCTIONS
PARENOPEN
PARENCLOSE
SEMICOLON
MEM_INITREPEAT
PARENOPEN
PARENCLOSE
SEMICOLON
//  takes a wail the first time it is called.\n        call it to avoid delay later 
VAR
INT
DUMP
SEMICOLON
DUMP
ASSIGN
MEM_GETFUNCIDBYOFFSET
PARENOPEN
INTEGER(0)
PARENCLOSE
SEMICOLON
BRACKETCLOSE
SEMICOLON
EOF